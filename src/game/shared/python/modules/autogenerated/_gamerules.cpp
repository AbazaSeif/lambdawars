// This file has been generated by Py++.

#include "cbase.h"
#ifdef CLIENT_DLL
#include "videocfg/videocfg.h"

#include "cbase.h"

#include "gamerules.h"

#include "multiplay_gamerules.h"

#include "teamplay_gamerules.h"

#include "hl2wars_gamerules.h"

#include "srcpy_gamerules.h"

#include "ammodef.h"

#include "srcpy.h"

#include "tier0/memdbgon.h"

namespace bp = boost::python;

struct C_HL2WarsGameRules_wrapper : C_HL2WarsGameRules, bp::wrapper< C_HL2WarsGameRules > {

    C_HL2WarsGameRules_wrapper()
    : C_HL2WarsGameRules()
      , bp::wrapper< C_HL2WarsGameRules >(){
        // null constructor
        
    }

    virtual void InitGamerules(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InitGamerules: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InitGamerules(  ) of Class: C_HL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InitGamerules = this->get_override( "InitGamerules" );
        if( func_InitGamerules.ptr() != Py_None )
            try {
                func_InitGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2WarsGameRules::InitGamerules(  );
            }
        else
            this->C_HL2WarsGameRules::InitGamerules(  );
    }
    
    void default_InitGamerules(  ) {
        C_HL2WarsGameRules::InitGamerules( );
    }

    virtual bool IsTeamplay(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsTeamplay: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsTeamplay(  ) of Class: C_HL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsTeamplay = this->get_override( "IsTeamplay" );
        if( func_IsTeamplay.ptr() != Py_None )
            try {
                return func_IsTeamplay(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2WarsGameRules::IsTeamplay(  );
            }
        else
            return this->C_HL2WarsGameRules::IsTeamplay(  );
    }
    
    bool default_IsTeamplay(  ) {
        return C_HL2WarsGameRules::IsTeamplay( );
    }

    virtual void ShutdownGamerules(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShutdownGamerules: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShutdownGamerules(  ) of Class: C_HL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShutdownGamerules = this->get_override( "ShutdownGamerules" );
        if( func_ShutdownGamerules.ptr() != Py_None )
            try {
                func_ShutdownGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2WarsGameRules::ShutdownGamerules(  );
            }
        else
            this->C_HL2WarsGameRules::ShutdownGamerules(  );
    }
    
    void default_ShutdownGamerules(  ) {
        C_HL2WarsGameRules::ShutdownGamerules( );
    }

};

BOOST_PYTHON_MODULE(_gamerules){
    bp::docstring_options doc_options( true, true, false );

    bp::class_< CAmmoDef >( "CAmmoDef", bp::init< >() )    
        .def( 
            "AddAmmoType"
            , (void ( ::CAmmoDef::* )( char const *,int,int,int,int,int,float,int,int,int ) )( &::CAmmoDef::AddAmmoType )
            , ( bp::arg("name"), bp::arg("damageType"), bp::arg("tracerType"), bp::arg("plr_dmg"), bp::arg("npc_dmg"), bp::arg("carry"), bp::arg("physicsForceImpulse"), bp::arg("nFlags"), bp::arg("minSplashSize")=(int)(4), bp::arg("maxSplashSize")=(int)(8) ) )    
        .def( 
            "AddAmmoType"
            , (void ( ::CAmmoDef::* )( char const *,int,int,char const *,char const *,char const *,float,int,int,int ) )( &::CAmmoDef::AddAmmoType )
            , ( bp::arg("name"), bp::arg("damageType"), bp::arg("tracerType"), bp::arg("plr_cvar"), bp::arg("npc_var"), bp::arg("carry_cvar"), bp::arg("physicsForceImpulse"), bp::arg("nFlags"), bp::arg("minSplashSize")=(int)(4), bp::arg("maxSplashSize")=(int)(8) ) )    
        .def( 
            "CanCarryInfiniteAmmo"
            , (bool ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::CanCarryInfiniteAmmo )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "DamageForce"
            , (float ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::DamageForce )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "DamageType"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::DamageType )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "Flags"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::Flags )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "Index"
            , (int ( ::CAmmoDef::* )( char const * ) )( &::CAmmoDef::Index )
            , ( bp::arg("psz") ) )    
        .def( 
            "MaxCarry"
            , (int ( ::CAmmoDef::* )( int,::C_BaseCombatCharacter const * ) )( &::CAmmoDef::MaxCarry )
            , ( bp::arg("nAmmoIndex"), bp::arg("owner") ) )    
        .def( 
            "MaxSplashSize"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::MaxSplashSize )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "MinSplashSize"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::MinSplashSize )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "NPCDamage"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::NPCDamage )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "NumAmmoTypes"
            , (int ( ::CAmmoDef::* )(  ) )( &::CAmmoDef::NumAmmoTypes ) )    
        .def( 
            "PlrDamage"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::PlrDamage )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "TracerType"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::TracerType )
            , ( bp::arg("nAmmoIndex") ) )    
        .def_readwrite( "m_nAmmoIndex", &CAmmoDef::m_nAmmoIndex );

    bp::class_< C_HL2WarsGameRules_wrapper, boost::noncopyable >( "CHL2WarsGameRules" )    
        .def( 
            "GetAmmoDamage"
            , (float ( ::C_HL2WarsGameRules::* )( ::C_BaseEntity *,::C_BaseEntity *,int ) )( &::C_HL2WarsGameRules::GetAmmoDamage )
            , ( bp::arg("pAttacker"), bp::arg("pVictim"), bp::arg("nAmmoType") ) )    
        .def( 
            "GetMapElapsedTime"
            , (float ( ::C_HL2WarsGameRules::* )(  ) )( &::C_HL2WarsGameRules::GetMapElapsedTime ) )    
        .def( 
            "InitGamerules"
            , (void ( ::C_HL2WarsGameRules::* )(  ) )(&::C_HL2WarsGameRules::InitGamerules)
            , (void ( C_HL2WarsGameRules_wrapper::* )(  ) )(&C_HL2WarsGameRules_wrapper::default_InitGamerules) )    
        .def( 
            "IsTeamplay"
            , (bool ( ::C_HL2WarsGameRules::* )(  ) )(&::C_HL2WarsGameRules::IsTeamplay)
            , (bool ( C_HL2WarsGameRules_wrapper::* )(  ) )(&C_HL2WarsGameRules_wrapper::default_IsTeamplay) )    
        .def( 
            "ShouldCollide"
            , (bool ( ::C_HL2WarsGameRules::* )( int,int ) )( &::C_HL2WarsGameRules::ShouldCollide )
            , ( bp::arg("collisionGroup0"), bp::arg("collisionGroup1") ) )    
        .def( 
            "ShutdownGamerules"
            , (void ( ::C_HL2WarsGameRules::* )(  ) )(&::C_HL2WarsGameRules::ShutdownGamerules)
            , (void ( C_HL2WarsGameRules_wrapper::* )(  ) )(&C_HL2WarsGameRules_wrapper::default_ShutdownGamerules) );

    { //::GetAmmoDef
    
        typedef ::CAmmoDef * ( *GetAmmoDef_function_type )(  );
        
        bp::def( 
            "GetAmmoDef"
            , GetAmmoDef_function_type( &::GetAmmoDef )
            , bp::return_value_policy< bp::reference_existing_object >() );
    
    }

    { //::PyGameRules
    
        typedef ::boost::python::object ( *GameRules_function_type )(  );
        
        bp::def( 
            "GameRules"
            , GameRules_function_type( &::PyGameRules ) );
    
    }

    { //::PyInstallGameRules
    
        typedef void ( *InstallGameRules_function_type )( ::boost::python::object );
        
        bp::def( 
            "InstallGameRules"
            , InstallGameRules_function_type( &::PyInstallGameRules )
            , ( bp::arg("gamerules") ) );
    
    }
}
#else
#include "cbase.h"

#include "items.h"

#include "gamerules.h"

#include "multiplay_gamerules.h"

#include "teamplay_gamerules.h"

#include "hl2wars_gamerules.h"

#include "srcpy_gamerules.h"

#include "ammodef.h"

#include "srcpy.h"

#include "tier0/memdbgon.h"

namespace bp = boost::python;

struct CHL2WarsGameRules_wrapper : CHL2WarsGameRules, bp::wrapper< CHL2WarsGameRules > {

    CHL2WarsGameRules_wrapper( )
    : CHL2WarsGameRules( )
      , bp::wrapper< CHL2WarsGameRules >(){
        // null constructor
    
    }

    virtual bool AllowAutoTargetCrosshair(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "AllowAutoTargetCrosshair: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling AllowAutoTargetCrosshair(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_AllowAutoTargetCrosshair = this->get_override( "AllowAutoTargetCrosshair" );
        if( func_AllowAutoTargetCrosshair.ptr() != Py_None )
            try {
                return func_AllowAutoTargetCrosshair(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::AllowAutoTargetCrosshair(  );
            }
        else
            return this->CHL2WarsGameRules::AllowAutoTargetCrosshair(  );
    }
    
    bool default_AllowAutoTargetCrosshair(  ) {
        return CHL2WarsGameRules::AllowAutoTargetCrosshair( );
    }

    virtual void ChangeLevel(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ChangeLevel: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ChangeLevel(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ChangeLevel = this->get_override( "ChangeLevel" );
        if( func_ChangeLevel.ptr() != Py_None )
            try {
                func_ChangeLevel(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CHL2WarsGameRules::ChangeLevel(  );
            }
        else
            this->CHL2WarsGameRules::ChangeLevel(  );
    }
    
    void default_ChangeLevel(  ) {
        CHL2WarsGameRules::ChangeLevel( );
    }

    virtual void CreateStandardEntities(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CreateStandardEntities: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CreateStandardEntities(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CreateStandardEntities = this->get_override( "CreateStandardEntities" );
        if( func_CreateStandardEntities.ptr() != Py_None )
            try {
                func_CreateStandardEntities(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CHL2WarsGameRules::CreateStandardEntities(  );
            }
        else
            this->CHL2WarsGameRules::CreateStandardEntities(  );
    }
    
    void default_CreateStandardEntities(  ) {
        CHL2WarsGameRules::CreateStandardEntities( );
    }

    virtual void DeathNotice( ::CBasePlayer * pVictim, ::CTakeDamageInfo const & info ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DeathNotice: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DeathNotice( boost::python::ptr(pVictim), boost::ref(info) ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DeathNotice = this->get_override( "DeathNotice" );
        if( func_DeathNotice.ptr() != Py_None )
            try {
                func_DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CHL2WarsGameRules::DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
            }
        else
            this->CHL2WarsGameRules::DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
    }
    
    void default_DeathNotice( ::CBasePlayer * pVictim, ::CTakeDamageInfo const & info ) {
        CHL2WarsGameRules::DeathNotice( boost::python::ptr(pVictim), boost::ref(info) );
    }

    virtual char const * GetChatFormat( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetChatFormat: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetChatFormat( bTeamOnly, boost::python::ptr(pPlayer) ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetChatFormat = this->get_override( "GetChatFormat" );
        if( func_GetChatFormat.ptr() != Py_None )
            try {
                return func_GetChatFormat( bTeamOnly, boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::GetChatFormat( bTeamOnly, boost::python::ptr(pPlayer) );
            }
        else
            return this->CHL2WarsGameRules::GetChatFormat( bTeamOnly, boost::python::ptr(pPlayer) );
    }
    
    char const * default_GetChatFormat( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        return CHL2WarsGameRules::GetChatFormat( bTeamOnly, boost::python::ptr(pPlayer) );
    }

    virtual char const * GetChatPrefix( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetChatPrefix: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetChatPrefix( bTeamOnly, boost::python::ptr(pPlayer) ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetChatPrefix = this->get_override( "GetChatPrefix" );
        if( func_GetChatPrefix.ptr() != Py_None )
            try {
                return func_GetChatPrefix( bTeamOnly, boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::GetChatPrefix( bTeamOnly, boost::python::ptr(pPlayer) );
            }
        else
            return this->CHL2WarsGameRules::GetChatPrefix( bTeamOnly, boost::python::ptr(pPlayer) );
    }
    
    char const * default_GetChatPrefix( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        return CHL2WarsGameRules::GetChatPrefix( bTeamOnly, boost::python::ptr(pPlayer) );
    }

    virtual char const * GetGameDescription(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGameDescription: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGameDescription(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGameDescription = this->get_override( "GetGameDescription" );
        if( func_GetGameDescription.ptr() != Py_None )
            try {
                return func_GetGameDescription(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::GetGameDescription(  );
            }
        else
            return this->CHL2WarsGameRules::GetGameDescription(  );
    }
    
    char const * default_GetGameDescription(  ) {
        return CHL2WarsGameRules::GetGameDescription( );
    }

    virtual ::boost::python::object GetNextLevelName( bool bRandom=false ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetNextLevelName: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetNextLevelName( bRandom ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetNextLevelName = this->get_override( "GetNextLevelName" );
        if( func_GetNextLevelName.ptr() != Py_None )
            try {
                return func_GetNextLevelName( bRandom );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::GetNextLevelName( bRandom );
            }
        else
            return this->CHL2WarsGameRules::GetNextLevelName( bRandom );
    }
    
    ::boost::python::object default_GetNextLevelName( bool bRandom=false ) {
        return CHL2WarsGameRules::GetNextLevelName( bRandom );
    }

    virtual char const * GetPlayerClassname(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetPlayerClassname: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetPlayerClassname(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetPlayerClassname = this->get_override( "GetPlayerClassname" );
        if( func_GetPlayerClassname.ptr() != Py_None )
            try {
                return func_GetPlayerClassname(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::GetPlayerClassname(  );
            }
        else
            return this->CHL2WarsGameRules::GetPlayerClassname(  );
    }
    
    char const * default_GetPlayerClassname(  ) {
        return CHL2WarsGameRules::GetPlayerClassname( );
    }

    virtual void GoToIntermission(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GoToIntermission: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GoToIntermission(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GoToIntermission = this->get_override( "GoToIntermission" );
        if( func_GoToIntermission.ptr() != Py_None )
            try {
                func_GoToIntermission(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CHL2WarsGameRules::GoToIntermission(  );
            }
        else
            this->CHL2WarsGameRules::GoToIntermission(  );
    }
    
    void default_GoToIntermission(  ) {
        CHL2WarsGameRules::GoToIntermission( );
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::Init(  );
            }
        else
            return this->CHL2WarsGameRules::Init(  );
    }
    
    bool default_Init(  ) {
        return CHL2WarsGameRules::Init( );
    }

    virtual void InitGamerules(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InitGamerules: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InitGamerules(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InitGamerules = this->get_override( "InitGamerules" );
        if( func_InitGamerules.ptr() != Py_None )
            try {
                func_InitGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CHL2WarsGameRules::InitGamerules(  );
            }
        else
            this->CHL2WarsGameRules::InitGamerules(  );
    }
    
    void default_InitGamerules(  ) {
        CHL2WarsGameRules::InitGamerules( );
    }

    virtual void InitHUD( ::CBasePlayer * pl ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "InitHUD: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling InitHUD( boost::python::ptr(pl) ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_InitHUD = this->get_override( "InitHUD" );
        if( func_InitHUD.ptr() != Py_None )
            try {
                func_InitHUD( boost::python::ptr(pl) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CHL2WarsGameRules::InitHUD( boost::python::ptr(pl) );
            }
        else
            this->CHL2WarsGameRules::InitHUD( boost::python::ptr(pl) );
    }
    
    void default_InitHUD( ::CBasePlayer * pl ) {
        CHL2WarsGameRules::InitHUD( boost::python::ptr(pl) );
    }

    virtual bool IsCoOp(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsCoOp: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsCoOp(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsCoOp = this->get_override( "IsCoOp" );
        if( func_IsCoOp.ptr() != Py_None )
            try {
                return func_IsCoOp(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::IsCoOp(  );
            }
        else
            return this->CHL2WarsGameRules::IsCoOp(  );
    }
    
    bool default_IsCoOp(  ) {
        return CHL2WarsGameRules::IsCoOp( );
    }

    virtual bool IsDeathmatch(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsDeathmatch: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsDeathmatch(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsDeathmatch = this->get_override( "IsDeathmatch" );
        if( func_IsDeathmatch.ptr() != Py_None )
            try {
                return func_IsDeathmatch(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::IsDeathmatch(  );
            }
        else
            return this->CHL2WarsGameRules::IsDeathmatch(  );
    }
    
    bool default_IsDeathmatch(  ) {
        return CHL2WarsGameRules::IsDeathmatch( );
    }

    virtual bool IsTeamplay(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsTeamplay: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsTeamplay(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsTeamplay = this->get_override( "IsTeamplay" );
        if( func_IsTeamplay.ptr() != Py_None )
            try {
                return func_IsTeamplay(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::IsTeamplay(  );
            }
        else
            return this->CHL2WarsGameRules::IsTeamplay(  );
    }
    
    bool default_IsTeamplay(  ) {
        return CHL2WarsGameRules::IsTeamplay( );
    }

    virtual void LevelShutdown(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdown: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdown(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdown = this->get_override( "LevelShutdown" );
        if( func_LevelShutdown.ptr() != Py_None )
            try {
                func_LevelShutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CHL2WarsGameRules::LevelShutdown(  );
            }
        else
            this->CHL2WarsGameRules::LevelShutdown(  );
    }
    
    void default_LevelShutdown(  ) {
        CHL2WarsGameRules::LevelShutdown( );
    }

    virtual void Precache(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Precache: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Precache(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Precache = this->get_override( "Precache" );
        if( func_Precache.ptr() != Py_None )
            try {
                func_Precache(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CHL2WarsGameRules::Precache(  );
            }
        else
            this->CHL2WarsGameRules::Precache(  );
    }
    
    void default_Precache(  ) {
        CHL2WarsGameRules::Precache( );
    }

    virtual bool PyClientConnected( int clientindex, char const * name, char const * address, char * reject, int maxrejectlen ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientConnected: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PyClientConnected( clientindex, name, address, reject, maxrejectlen ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientConnected = this->get_override( "ClientConnected" );
        if( func_ClientConnected.ptr() != Py_None )
            try {
                return func_ClientConnected( clientindex, name, address, reject, maxrejectlen );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CHL2WarsGameRules::PyClientConnected( clientindex, name, address, reject, maxrejectlen );
            }
        else
            return this->CHL2WarsGameRules::PyClientConnected( clientindex, name, address, reject, maxrejectlen );
    }
    
    bool default_ClientConnected( int clientindex, char const * name, char const * address, char * reject, int maxrejectlen ) {
        return CHL2WarsGameRules::PyClientConnected( clientindex, name, address, reject, maxrejectlen );
    }

    virtual void ShutdownGamerules(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShutdownGamerules: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShutdownGamerules(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShutdownGamerules = this->get_override( "ShutdownGamerules" );
        if( func_ShutdownGamerules.ptr() != Py_None )
            try {
                func_ShutdownGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CHL2WarsGameRules::ShutdownGamerules(  );
            }
        else
            this->CHL2WarsGameRules::ShutdownGamerules(  );
    }
    
    void default_ShutdownGamerules(  ) {
        CHL2WarsGameRules::ShutdownGamerules( );
    }

    virtual void Think(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Think: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Think(  ) of Class: CHL2WarsGameRules\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Think = this->get_override( "Think" );
        if( func_Think.ptr() != Py_None )
            try {
                func_Think(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CHL2WarsGameRules::Think(  );
            }
        else
            this->CHL2WarsGameRules::Think(  );
    }
    
    void default_Think(  ) {
        CHL2WarsGameRules::Think( );
    }

    virtual PyObject *GetPySelf() const { return boost::python::detail::wrapper_base_::get_owner(*this); }

    virtual void PyClientDisconnected( ::CBasePlayer * client ) {
        boost::python::override func_ClientDisconnected = this->get_override( "ClientDisconnected" );
        if( func_ClientDisconnected.ptr() != Py_None )
            try {
                func_ClientDisconnected( *client );
            } catch(...) {
                PyErr_Print();
                this->CHL2WarsGameRules::PyClientDisconnected( boost::python::ptr(client) );
            }
        else
            this->CHL2WarsGameRules::PyClientDisconnected( boost::python::ptr(client) );
    }

    void default_ClientDisconnected( ::CBasePlayer * client ) {
        CHL2WarsGameRules::PyClientDisconnected( boost::python::ptr(client) );
    }

    virtual void ClientActive( ::CBasePlayer * client ) {
        boost::python::override func_ClientActive = this->get_override( "ClientActive" );
        if( func_ClientActive.ptr() != Py_None )
            try {
                func_ClientActive( *client );
            } catch(...) {
                PyErr_Print();
                this->CHL2WarsGameRules::ClientActive( boost::python::ptr(client) );
            }
        else
            this->CHL2WarsGameRules::ClientActive( boost::python::ptr(client) );
    }

    void default_ClientActive( ::CBasePlayer * client ) {
        CHL2WarsGameRules::ClientActive( boost::python::ptr(client) );
    }

    virtual void PlayerSpawn( ::CBasePlayer * player ) {
        boost::python::override func_PlayerSpawn = this->get_override( "PlayerSpawn" );
        if( func_PlayerSpawn.ptr() != Py_None )
            try {
                func_PlayerSpawn( *player );
            } catch(...) {
                PyErr_Print();
                this->CHL2WarsGameRules::PlayerSpawn( boost::python::ptr(player) );
            }
        else
            this->CHL2WarsGameRules::PlayerSpawn( boost::python::ptr(player) );
    }

    void default_PlayerSpawn( ::CBasePlayer * player ) {
        CHL2WarsGameRules::PlayerSpawn( boost::python::ptr(player) );
    }

    virtual void PlayerThink( ::CBasePlayer * player ) {
        boost::python::override func_PlayerThink = this->get_override( "PlayerThink" );
        if( func_PlayerThink.ptr() != Py_None )
            try {
                func_PlayerThink( *player );
            } catch(...) {
                PyErr_Print();
                this->CHL2WarsGameRules::PlayerThink( boost::python::ptr(player) );
            }
        else
            this->CHL2WarsGameRules::PlayerThink( boost::python::ptr(player) );
    }

    void default_PlayerThink( ::CBasePlayer * player ) {
        CHL2WarsGameRules::PlayerThink( boost::python::ptr(player) );
    }

    virtual bool FPlayerCanRespawn( ::CBasePlayer * player ) {
        boost::python::override func_FPlayerCanRespawn = this->get_override( "FPlayerCanRespawn" );
        if( func_FPlayerCanRespawn.ptr() != Py_None )
            try {
                return func_FPlayerCanRespawn( *player );
            } catch(...) {
                PyErr_Print();
                return this->CHL2WarsGameRules::FPlayerCanRespawn( boost::python::ptr(player) );
            }
        else
            return this->CHL2WarsGameRules::FPlayerCanRespawn( boost::python::ptr(player) );
    }

    bool default_FPlayerCanRespawn( ::CBasePlayer * player ) {
        return CHL2WarsGameRules::FPlayerCanRespawn( boost::python::ptr(player) );
    }

    virtual float FlPlayerSpawnTime( ::CBasePlayer * player ) {
        boost::python::override func_FlPlayerSpawnTime = this->get_override( "FlPlayerSpawnTime" );
        if( func_FlPlayerSpawnTime.ptr() != Py_None )
            try {
                return func_FlPlayerSpawnTime( *player );
            } catch(...) {
                PyErr_Print();
                return this->CHL2WarsGameRules::FlPlayerSpawnTime( boost::python::ptr(player) );
            }
        else
            return this->CHL2WarsGameRules::FlPlayerSpawnTime( boost::python::ptr(player) );
    }

    float default_FlPlayerSpawnTime( ::CBasePlayer * player ) {
        return CHL2WarsGameRules::FlPlayerSpawnTime( boost::python::ptr(player) );
    }

    virtual ::CBaseEntity * GetPlayerSpawnSpot( ::CBasePlayer * player ) {
        boost::python::override func_GetPlayerSpawnSpot = this->get_override( "GetPlayerSpawnSpot" );
        if( func_GetPlayerSpawnSpot.ptr() != Py_None )
            try {
                return func_GetPlayerSpawnSpot( *player );
            } catch(...) {
                PyErr_Print();
                return this->CHL2WarsGameRules::GetPlayerSpawnSpot( boost::python::ptr(player) );
            }
        else
            return this->CHL2WarsGameRules::GetPlayerSpawnSpot( boost::python::ptr(player) );
    }

    ::CBaseEntity * default_GetPlayerSpawnSpot( ::CBasePlayer * player ) {
        return CHL2WarsGameRules::GetPlayerSpawnSpot( boost::python::ptr(player) );
    }

    virtual bool IsSpawnPointValid( ::CBaseEntity * spot, ::CBasePlayer * player ) {
        boost::python::override func_IsSpawnPointValid = this->get_override( "IsSpawnPointValid" );
        if( func_IsSpawnPointValid.ptr() != Py_None )
            try {
                return func_IsSpawnPointValid( *spot, *player );
            } catch(...) {
                PyErr_Print();
                return this->CHL2WarsGameRules::IsSpawnPointValid( boost::python::ptr(spot), boost::python::ptr(player) );
            }
        else
            return this->CHL2WarsGameRules::IsSpawnPointValid( boost::python::ptr(spot), boost::python::ptr(player) );
    }

    bool default_IsSpawnPointValid( ::CBaseEntity * spot, ::CBasePlayer * player ) {
        return CHL2WarsGameRules::IsSpawnPointValid( boost::python::ptr(spot), boost::python::ptr(player) );
    }

    virtual bool ClientCommand( ::CBaseEntity * edict, ::CCommand const & args ) {
        boost::python::override func_ClientCommand = this->get_override( "ClientCommand" );
        if( func_ClientCommand.ptr() != Py_None )
            try {
                return func_ClientCommand( *edict, args );
            } catch(...) {
                PyErr_Print();
                return this->CHL2WarsGameRules::ClientCommand( boost::python::ptr(edict), boost::ref(args) );
            }
        else
            return this->CHL2WarsGameRules::ClientCommand( boost::python::ptr(edict), boost::ref(args) );
    }

    bool default_ClientCommand( ::CBaseEntity * edict, ::CCommand const & args ) {
        return CHL2WarsGameRules::ClientCommand( boost::python::ptr(edict), boost::ref(args) );
    }

    virtual void ClientSettingsChanged( ::CBasePlayer * player ) {
        boost::python::override func_ClientSettingsChanged = this->get_override( "ClientSettingsChanged" );
        if( func_ClientSettingsChanged.ptr() != Py_None )
            try {
                func_ClientSettingsChanged( *player );
            } catch(...) {
                PyErr_Print();
                this->CHL2WarsGameRules::ClientSettingsChanged( boost::python::ptr(player) );
            }
        else
            this->CHL2WarsGameRules::ClientSettingsChanged( boost::python::ptr(player) );
    }

    void default_ClientSettingsChanged( ::CBasePlayer * player ) {
        CHL2WarsGameRules::ClientSettingsChanged( boost::python::ptr(player) );
    }

    virtual void PlayerChangedOwnerNumber( ::CBasePlayer * player, int oldownernumber, int newownernumber ) {
        boost::python::override func_PlayerChangedOwnerNumber = this->get_override( "PlayerChangedOwnerNumber" );
        if( func_PlayerChangedOwnerNumber.ptr() != Py_None )
            try {
                func_PlayerChangedOwnerNumber( *player, oldownernumber, newownernumber );
            } catch(...) {
                PyErr_Print();
                this->CHL2WarsGameRules::PlayerChangedOwnerNumber( boost::python::ptr(player), oldownernumber, newownernumber );
            }
        else
            this->CHL2WarsGameRules::PlayerChangedOwnerNumber( boost::python::ptr(player), oldownernumber, newownernumber );
    }

    void default_PlayerChangedOwnerNumber( ::CBasePlayer * player, int oldownernumber, int newownernumber ) {
        CHL2WarsGameRules::PlayerChangedOwnerNumber( boost::python::ptr(player), oldownernumber, newownernumber );
    }

};

BOOST_PYTHON_MODULE(_gamerules){
    bp::docstring_options doc_options( true, true, false );

    bp::class_< CAmmoDef >( "CAmmoDef", bp::init< >() )    
        .def( 
            "AddAmmoType"
            , (void ( ::CAmmoDef::* )( char const *,int,int,int,int,int,float,int,int,int ) )( &::CAmmoDef::AddAmmoType )
            , ( bp::arg("name"), bp::arg("damageType"), bp::arg("tracerType"), bp::arg("plr_dmg"), bp::arg("npc_dmg"), bp::arg("carry"), bp::arg("physicsForceImpulse"), bp::arg("nFlags"), bp::arg("minSplashSize")=(int)(4), bp::arg("maxSplashSize")=(int)(8) ) )    
        .def( 
            "AddAmmoType"
            , (void ( ::CAmmoDef::* )( char const *,int,int,char const *,char const *,char const *,float,int,int,int ) )( &::CAmmoDef::AddAmmoType )
            , ( bp::arg("name"), bp::arg("damageType"), bp::arg("tracerType"), bp::arg("plr_cvar"), bp::arg("npc_var"), bp::arg("carry_cvar"), bp::arg("physicsForceImpulse"), bp::arg("nFlags"), bp::arg("minSplashSize")=(int)(4), bp::arg("maxSplashSize")=(int)(8) ) )    
        .def( 
            "CanCarryInfiniteAmmo"
            , (bool ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::CanCarryInfiniteAmmo )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "DamageForce"
            , (float ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::DamageForce )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "DamageType"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::DamageType )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "Flags"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::Flags )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "Index"
            , (int ( ::CAmmoDef::* )( char const * ) )( &::CAmmoDef::Index )
            , ( bp::arg("psz") ) )    
        .def( 
            "MaxCarry"
            , (int ( ::CAmmoDef::* )( int,::CBaseCombatCharacter const * ) )( &::CAmmoDef::MaxCarry )
            , ( bp::arg("nAmmoIndex"), bp::arg("owner") ) )    
        .def( 
            "MaxSplashSize"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::MaxSplashSize )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "MinSplashSize"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::MinSplashSize )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "NPCDamage"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::NPCDamage )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "NumAmmoTypes"
            , (int ( ::CAmmoDef::* )(  ) )( &::CAmmoDef::NumAmmoTypes ) )    
        .def( 
            "PlrDamage"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::PlrDamage )
            , ( bp::arg("nAmmoIndex") ) )    
        .def( 
            "TracerType"
            , (int ( ::CAmmoDef::* )( int ) )( &::CAmmoDef::TracerType )
            , ( bp::arg("nAmmoIndex") ) )    
        .def_readwrite( "m_nAmmoIndex", &CAmmoDef::m_nAmmoIndex );

    { //::CHL2WarsGameRules
        typedef bp::class_< CHL2WarsGameRules_wrapper, boost::noncopyable > CHL2WarsGameRules_exposer_t;
        CHL2WarsGameRules_exposer_t CHL2WarsGameRules_exposer = CHL2WarsGameRules_exposer_t( "CHL2WarsGameRules", bp::no_init );
        bp::scope CHL2WarsGameRules_scope( CHL2WarsGameRules_exposer );
        CHL2WarsGameRules_exposer.def( bp::init< >() );
        { //::CHL2WarsGameRules::AllowAutoTargetCrosshair
        
            typedef bool ( ::CHL2WarsGameRules::*AllowAutoTargetCrosshair_function_type )(  ) ;
            typedef bool ( CHL2WarsGameRules_wrapper::*default_AllowAutoTargetCrosshair_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "AllowAutoTargetCrosshair"
                , AllowAutoTargetCrosshair_function_type(&::CHL2WarsGameRules::AllowAutoTargetCrosshair)
                , default_AllowAutoTargetCrosshair_function_type(&CHL2WarsGameRules_wrapper::default_AllowAutoTargetCrosshair) );
        
        }
        { //::CHL2WarsGameRules::ChangeLevel
        
            typedef void ( ::CHL2WarsGameRules::*ChangeLevel_function_type )(  ) ;
            typedef void ( CHL2WarsGameRules_wrapper::*default_ChangeLevel_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "ChangeLevel"
                , ChangeLevel_function_type(&::CHL2WarsGameRules::ChangeLevel)
                , default_ChangeLevel_function_type(&CHL2WarsGameRules_wrapper::default_ChangeLevel) );
        
        }
        { //::CHL2WarsGameRules::CreateStandardEntities
        
            typedef void ( ::CHL2WarsGameRules::*CreateStandardEntities_function_type )(  ) ;
            typedef void ( CHL2WarsGameRules_wrapper::*default_CreateStandardEntities_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "CreateStandardEntities"
                , CreateStandardEntities_function_type(&::CHL2WarsGameRules::CreateStandardEntities)
                , default_CreateStandardEntities_function_type(&CHL2WarsGameRules_wrapper::default_CreateStandardEntities) );
        
        }
        { //::CHL2WarsGameRules::DeathNotice
        
            typedef void ( ::CHL2WarsGameRules::*DeathNotice_function_type )( ::CBasePlayer *,::CTakeDamageInfo const & ) ;
            typedef void ( CHL2WarsGameRules_wrapper::*default_DeathNotice_function_type )( ::CBasePlayer *,::CTakeDamageInfo const & ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "DeathNotice"
                , DeathNotice_function_type(&::CHL2WarsGameRules::DeathNotice)
                , default_DeathNotice_function_type(&CHL2WarsGameRules_wrapper::default_DeathNotice)
                , ( bp::arg("pVictim"), bp::arg("info") ) );
        
        }
        { //::CHL2WarsGameRules::GetChatFormat
        
            typedef char const * ( ::CHL2WarsGameRules::*GetChatFormat_function_type )( bool,::CBasePlayer * ) ;
            typedef char const * ( CHL2WarsGameRules_wrapper::*default_GetChatFormat_function_type )( bool,::CBasePlayer * ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "GetChatFormat"
                , GetChatFormat_function_type(&::CHL2WarsGameRules::GetChatFormat)
                , default_GetChatFormat_function_type(&CHL2WarsGameRules_wrapper::default_GetChatFormat)
                , ( bp::arg("bTeamOnly"), bp::arg("pPlayer") ) );
        
        }
        { //::CHL2WarsGameRules::GetChatPrefix
        
            typedef char const * ( ::CHL2WarsGameRules::*GetChatPrefix_function_type )( bool,::CBasePlayer * ) ;
            typedef char const * ( CHL2WarsGameRules_wrapper::*default_GetChatPrefix_function_type )( bool,::CBasePlayer * ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "GetChatPrefix"
                , GetChatPrefix_function_type(&::CHL2WarsGameRules::GetChatPrefix)
                , default_GetChatPrefix_function_type(&CHL2WarsGameRules_wrapper::default_GetChatPrefix)
                , ( bp::arg("bTeamOnly"), bp::arg("pPlayer") ) );
        
        }
        { //::CHL2WarsGameRules::GetGameDescription
        
            typedef char const * ( ::CHL2WarsGameRules::*GetGameDescription_function_type )(  ) ;
            typedef char const * ( CHL2WarsGameRules_wrapper::*default_GetGameDescription_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "GetGameDescription"
                , GetGameDescription_function_type(&::CHL2WarsGameRules::GetGameDescription)
                , default_GetGameDescription_function_type(&CHL2WarsGameRules_wrapper::default_GetGameDescription) );
        
        }
        { //::CHL2WarsGameRules::GetMapElapsedTime
        
            typedef float ( ::CHL2WarsGameRules::*GetMapElapsedTime_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "GetMapElapsedTime"
                , GetMapElapsedTime_function_type( &::CHL2WarsGameRules::GetMapElapsedTime ) );
        
        }
        { //::CHL2WarsGameRules::GetNextLevelName
        
            typedef ::boost::python::object ( ::CHL2WarsGameRules::*GetNextLevelName_function_type )( bool ) ;
            typedef ::boost::python::object ( CHL2WarsGameRules_wrapper::*default_GetNextLevelName_function_type )( bool ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "GetNextLevelName"
                , GetNextLevelName_function_type(&::CHL2WarsGameRules::GetNextLevelName)
                , default_GetNextLevelName_function_type(&CHL2WarsGameRules_wrapper::default_GetNextLevelName)
                , ( bp::arg("bRandom")=(bool)(false) ) );
        
        }
        { //::CHL2WarsGameRules::GetPlayerClassname
        
            typedef char const * ( ::CHL2WarsGameRules::*GetPlayerClassname_function_type )(  ) ;
            typedef char const * ( CHL2WarsGameRules_wrapper::*default_GetPlayerClassname_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "GetPlayerClassname"
                , GetPlayerClassname_function_type(&::CHL2WarsGameRules::GetPlayerClassname)
                , default_GetPlayerClassname_function_type(&CHL2WarsGameRules_wrapper::default_GetPlayerClassname) );
        
        }
        { //::CHL2WarsGameRules::GoToIntermission
        
            typedef void ( ::CHL2WarsGameRules::*GoToIntermission_function_type )(  ) ;
            typedef void ( CHL2WarsGameRules_wrapper::*default_GoToIntermission_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "GoToIntermission"
                , GoToIntermission_function_type(&::CHL2WarsGameRules::GoToIntermission)
                , default_GoToIntermission_function_type(&CHL2WarsGameRules_wrapper::default_GoToIntermission) );
        
        }
        { //::CHL2WarsGameRules::Init
        
            typedef bool ( ::CHL2WarsGameRules::*Init_function_type )(  ) ;
            typedef bool ( CHL2WarsGameRules_wrapper::*default_Init_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "Init"
                , Init_function_type(&::CHL2WarsGameRules::Init)
                , default_Init_function_type(&CHL2WarsGameRules_wrapper::default_Init) );
        
        }
        { //::CHL2WarsGameRules::InitGamerules
        
            typedef void ( ::CHL2WarsGameRules::*InitGamerules_function_type )(  ) ;
            typedef void ( CHL2WarsGameRules_wrapper::*default_InitGamerules_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "InitGamerules"
                , InitGamerules_function_type(&::CHL2WarsGameRules::InitGamerules)
                , default_InitGamerules_function_type(&CHL2WarsGameRules_wrapper::default_InitGamerules) );
        
        }
        { //::CHL2WarsGameRules::InitHUD
        
            typedef void ( ::CHL2WarsGameRules::*InitHUD_function_type )( ::CBasePlayer * ) ;
            typedef void ( CHL2WarsGameRules_wrapper::*default_InitHUD_function_type )( ::CBasePlayer * ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "InitHUD"
                , InitHUD_function_type(&::CHL2WarsGameRules::InitHUD)
                , default_InitHUD_function_type(&CHL2WarsGameRules_wrapper::default_InitHUD)
                , ( bp::arg("pl") ) );
        
        }
        { //::CHL2WarsGameRules::InitTeams
        
            typedef void ( ::CHL2WarsGameRules::*InitTeams_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "InitTeams"
                , InitTeams_function_type( &::CHL2WarsGameRules::InitTeams ) );
        
        }
        { //::CHL2WarsGameRules::IsCoOp
        
            typedef bool ( ::CHL2WarsGameRules::*IsCoOp_function_type )(  ) ;
            typedef bool ( CHL2WarsGameRules_wrapper::*default_IsCoOp_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "IsCoOp"
                , IsCoOp_function_type(&::CHL2WarsGameRules::IsCoOp)
                , default_IsCoOp_function_type(&CHL2WarsGameRules_wrapper::default_IsCoOp) );
        
        }
        { //::CHL2WarsGameRules::IsDeathmatch
        
            typedef bool ( ::CHL2WarsGameRules::*IsDeathmatch_function_type )(  ) ;
            typedef bool ( CHL2WarsGameRules_wrapper::*default_IsDeathmatch_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "IsDeathmatch"
                , IsDeathmatch_function_type(&::CHL2WarsGameRules::IsDeathmatch)
                , default_IsDeathmatch_function_type(&CHL2WarsGameRules_wrapper::default_IsDeathmatch) );
        
        }
        { //::CHL2WarsGameRules::IsTeamplay
        
            typedef bool ( ::CHL2WarsGameRules::*IsTeamplay_function_type )(  ) ;
            typedef bool ( CHL2WarsGameRules_wrapper::*default_IsTeamplay_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "IsTeamplay"
                , IsTeamplay_function_type(&::CHL2WarsGameRules::IsTeamplay)
                , default_IsTeamplay_function_type(&CHL2WarsGameRules_wrapper::default_IsTeamplay) );
        
        }
        { //::CHL2WarsGameRules::LevelShutdown
        
            typedef void ( ::CHL2WarsGameRules::*LevelShutdown_function_type )(  ) ;
            typedef void ( CHL2WarsGameRules_wrapper::*default_LevelShutdown_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "LevelShutdown"
                , LevelShutdown_function_type(&::CHL2WarsGameRules::LevelShutdown)
                , default_LevelShutdown_function_type(&CHL2WarsGameRules_wrapper::default_LevelShutdown) );
        
        }
        { //::CHL2WarsGameRules::Precache
        
            typedef void ( ::CHL2WarsGameRules::*Precache_function_type )(  ) ;
            typedef void ( CHL2WarsGameRules_wrapper::*default_Precache_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "Precache"
                , Precache_function_type(&::CHL2WarsGameRules::Precache)
                , default_Precache_function_type(&CHL2WarsGameRules_wrapper::default_Precache) );
        
        }
        { //::CHL2WarsGameRules::PyClientConnected
        
            typedef bool ( ::CHL2WarsGameRules::*ClientConnected_function_type )( int,char const *,char const *,char *,int ) ;
            typedef bool ( CHL2WarsGameRules_wrapper::*default_ClientConnected_function_type )( int,char const *,char const *,char *,int ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "ClientConnected"
                , ClientConnected_function_type(&::CHL2WarsGameRules::PyClientConnected)
                , default_ClientConnected_function_type(&CHL2WarsGameRules_wrapper::default_ClientConnected)
                , ( bp::arg("clientindex"), bp::arg("name"), bp::arg("address"), bp::arg("reject"), bp::arg("maxrejectlen") ) );
        
        }
        { //::CHL2WarsGameRules::SelectDefaultTeam
        
            typedef int ( ::CHL2WarsGameRules::*SelectDefaultTeam_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "SelectDefaultTeam"
                , SelectDefaultTeam_function_type( &::CHL2WarsGameRules::SelectDefaultTeam ) );
        
        }
        { //::CHL2WarsGameRules::ShouldCollide
        
            typedef bool ( ::CHL2WarsGameRules::*ShouldCollide_function_type )( int,int ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "ShouldCollide"
                , ShouldCollide_function_type( &::CHL2WarsGameRules::ShouldCollide )
                , ( bp::arg("collisionGroup0"), bp::arg("collisionGroup1") ) );
        
        }
        { //::CHL2WarsGameRules::ShutdownGamerules
        
            typedef void ( ::CHL2WarsGameRules::*ShutdownGamerules_function_type )(  ) ;
            typedef void ( CHL2WarsGameRules_wrapper::*default_ShutdownGamerules_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "ShutdownGamerules"
                , ShutdownGamerules_function_type(&::CHL2WarsGameRules::ShutdownGamerules)
                , default_ShutdownGamerules_function_type(&CHL2WarsGameRules_wrapper::default_ShutdownGamerules) );
        
        }
        { //::CHL2WarsGameRules::Think
        
            typedef void ( ::CHL2WarsGameRules::*Think_function_type )(  ) ;
            typedef void ( CHL2WarsGameRules_wrapper::*default_Think_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "Think"
                , Think_function_type(&::CHL2WarsGameRules::Think)
                , default_Think_function_type(&CHL2WarsGameRules_wrapper::default_Think) );
        
        }
        { //::CHL2WarsGameRules::UpdateVoiceManager
        
            typedef void ( ::CHL2WarsGameRules::*UpdateVoiceManager_function_type )(  ) ;
            
            CHL2WarsGameRules_exposer.def( 
                "UpdateVoiceManager"
                , UpdateVoiceManager_function_type( &::CHL2WarsGameRules::UpdateVoiceManager ) );
        
        }
        { //property "intermissionendtime"[fget=::CHL2WarsGameRules::GetIntermissionEndTime, fset=::CHL2WarsGameRules::SetintermissionEndTime]
        
            typedef float ( ::CHL2WarsGameRules::*fget )(  ) ;
            typedef void ( ::CHL2WarsGameRules::*fset )( float ) ;
            
            CHL2WarsGameRules_exposer.add_property( 
                "intermissionendtime"
                , fget( &::CHL2WarsGameRules::GetIntermissionEndTime )
                , fset( &::CHL2WarsGameRules::SetintermissionEndTime ) );
        
        }
        { //property "gameover"[fget=::CHL2WarsGameRules::GetGameOver, fset=::CHL2WarsGameRules::SetGameOver]
        
            typedef bool ( ::CHL2WarsGameRules::*fget )(  ) ;
            typedef void ( ::CHL2WarsGameRules::*fset )( bool ) ;
            
            CHL2WarsGameRules_exposer.add_property( 
                "gameover"
                , fget( &::CHL2WarsGameRules::GetGameOver )
                , fset( &::CHL2WarsGameRules::SetGameOver ) );
        
        }
        CHL2WarsGameRules_exposer.def( 
            "ClientDisconnected"
            , (void ( ::CHL2WarsGameRules::* )( ::CBasePlayer * ) )(&::CHL2WarsGameRules::PyClientDisconnected)
            , (void ( CHL2WarsGameRules_wrapper::* )( ::CBasePlayer * ) )(&CHL2WarsGameRules_wrapper::default_ClientDisconnected)
            , ( boost::python::arg("client") ) );
        CHL2WarsGameRules_exposer.def( 
            "ClientActive"
            , (void ( ::CHL2WarsGameRules::* )( ::CBasePlayer * ) )(&::CHL2WarsGameRules::ClientActive)
            , (void ( CHL2WarsGameRules_wrapper::* )( ::CBasePlayer * ) )(&CHL2WarsGameRules_wrapper::default_ClientActive)
            , ( boost::python::arg("client") ) );
        CHL2WarsGameRules_exposer.def( 
            "PlayerSpawn"
            , (void ( ::CHL2WarsGameRules::* )( ::CBasePlayer * ) )(&::CHL2WarsGameRules::PlayerSpawn)
            , (void ( CHL2WarsGameRules_wrapper::* )( ::CBasePlayer * ) )(&CHL2WarsGameRules_wrapper::default_PlayerSpawn)
            , ( boost::python::arg("player") ) );
        CHL2WarsGameRules_exposer.def( 
            "PlayerThink"
            , (void ( ::CHL2WarsGameRules::* )( ::CBasePlayer * ) )(&::CHL2WarsGameRules::PlayerThink)
            , (void ( CHL2WarsGameRules_wrapper::* )( ::CBasePlayer * ) )(&CHL2WarsGameRules_wrapper::default_PlayerThink)
            , ( boost::python::arg("player") ) );
        CHL2WarsGameRules_exposer.def( 
            "FPlayerCanRespawn"
            , (bool ( ::CHL2WarsGameRules::* )( ::CBasePlayer * ) )(&::CHL2WarsGameRules::FPlayerCanRespawn)
            , (bool ( CHL2WarsGameRules_wrapper::* )( ::CBasePlayer * ) )(&CHL2WarsGameRules_wrapper::default_FPlayerCanRespawn)
            , ( boost::python::arg("player") ) );
        CHL2WarsGameRules_exposer.def( 
            "FlPlayerSpawnTime"
            , (float ( ::CHL2WarsGameRules::* )( ::CBasePlayer * ) )(&::CHL2WarsGameRules::FlPlayerSpawnTime)
            , (float ( CHL2WarsGameRules_wrapper::* )( ::CBasePlayer * ) )(&CHL2WarsGameRules_wrapper::default_FlPlayerSpawnTime)
            , ( boost::python::arg("player") ) );
        CHL2WarsGameRules_exposer.def( 
            "GetPlayerSpawnSpot"
            , (::CBaseEntity * ( ::CHL2WarsGameRules::* )( ::CBasePlayer * ) )(&::CHL2WarsGameRules::GetPlayerSpawnSpot)
            , (::CBaseEntity * ( CHL2WarsGameRules_wrapper::* )( ::CBasePlayer * ) )(&CHL2WarsGameRules_wrapper::default_GetPlayerSpawnSpot)
            , ( boost::python::arg("player") )
            , boost::python::return_value_policy< boost::python::return_by_value >() );
        CHL2WarsGameRules_exposer.def( 
            "IsSpawnPointValid"
            , (bool ( ::CHL2WarsGameRules::* )( ::CBaseEntity *,::CBasePlayer * ) )(&::CHL2WarsGameRules::IsSpawnPointValid)
            , (bool ( CHL2WarsGameRules_wrapper::* )( ::CBaseEntity *,::CBasePlayer * ) )(&CHL2WarsGameRules_wrapper::default_IsSpawnPointValid)
            , ( boost::python::arg("spot"), boost::python::arg("player") ) );
        CHL2WarsGameRules_exposer.def( 
            "ClientCommand"
            , (bool ( ::CHL2WarsGameRules::* )( ::CBaseEntity *,::CCommand const & ) )(&::CHL2WarsGameRules::ClientCommand)
            , (bool ( CHL2WarsGameRules_wrapper::* )( ::CBaseEntity *,::CCommand const & ) )(&CHL2WarsGameRules_wrapper::default_ClientCommand)
            , ( boost::python::arg("edict"), boost::python::arg("args") ) );
        CHL2WarsGameRules_exposer.def( 
            "ClientSettingsChanged"
            , (void ( ::CHL2WarsGameRules::* )( ::CBasePlayer * ) )(&::CHL2WarsGameRules::ClientSettingsChanged)
            , (void ( CHL2WarsGameRules_wrapper::* )( ::CBasePlayer * ) )(&CHL2WarsGameRules_wrapper::default_ClientSettingsChanged)
            , ( boost::python::arg("player") ) );
        CHL2WarsGameRules_exposer.def( 
            "PlayerChangedOwnerNumber"
            , (void ( ::CHL2WarsGameRules::* )( ::CBasePlayer *,int,int ) )(&::CHL2WarsGameRules::PlayerChangedOwnerNumber)
            , (void ( CHL2WarsGameRules_wrapper::* )( ::CBasePlayer *,int,int ) )(&CHL2WarsGameRules_wrapper::default_PlayerChangedOwnerNumber)
            , ( boost::python::arg("player"), boost::python::arg("oldownernumber"), boost::python::arg("newownernumber") ) );
    }

    { //::GetAmmoDef
    
        typedef ::CAmmoDef * ( *GetAmmoDef_function_type )(  );
        
        bp::def( 
            "GetAmmoDef"
            , GetAmmoDef_function_type( &::GetAmmoDef )
            , bp::return_value_policy< bp::reference_existing_object >() );
    
    }

    { //::PyGameRules
    
        typedef ::boost::python::object ( *GameRules_function_type )(  );
        
        bp::def( 
            "GameRules"
            , GameRules_function_type( &::PyGameRules ) );
    
    }

    { //::PyInstallGameRules
    
        typedef void ( *InstallGameRules_function_type )( ::boost::python::object );
        
        bp::def( 
            "InstallGameRules"
            , InstallGameRules_function_type( &::PyInstallGameRules )
            , ( bp::arg("gamerules") ) );
    
    }
}
#endif

