// This file has been generated by Py++.

#include "cbase.h"

#ifdef CLIENT_DLL

#include "boost/python.hpp"

#include "videocfg/videocfg.h"

#include "cbase.h"

#include "c_baseplayer.h"

#include "c_unit_base.h"

#include "unit_base_shared.h"

#include "unit_component.h"

#include "unit_locomotion.h"

#include "unit_airlocomotion.h"

#include "unit_animstate.h"

#include "src_python.h"

#include "tier0/memdbgon.h"

namespace bp = boost::python;

struct UnitBaseAnimState_wrapper : UnitBaseAnimState, bp::wrapper< UnitBaseAnimState > {

    UnitBaseAnimState_wrapper(UnitBaseAnimState const & arg )
    : UnitBaseAnimState( arg )
      , bp::wrapper< UnitBaseAnimState >(){
        // copy constructor
        
    }

    UnitBaseAnimState_wrapper(::boost::python::object outer )
    : UnitBaseAnimState( outer )
      , bp::wrapper< UnitBaseAnimState >(){
        // constructor
    
    }

    virtual int SelectWeightedSequence( ::Activity activity ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SelectWeightedSequence: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SelectWeightedSequence( activity ) of Class: UnitBaseAnimState\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SelectWeightedSequence = this->get_override( "SelectWeightedSequence" );
        if( func_SelectWeightedSequence.ptr() != Py_None )
            try {
                return func_SelectWeightedSequence( activity );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseAnimState::SelectWeightedSequence( activity );
            }
        else
            return this->UnitBaseAnimState::SelectWeightedSequence( activity );
    }
    
    int default_SelectWeightedSequence( ::Activity activity ) {
        return UnitBaseAnimState::SelectWeightedSequence( activity );
    }

    virtual void Update( float eyeYaw, float eyePitch ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Update: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Update( eyeYaw, eyePitch ) of Class: UnitBaseAnimState\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Update = this->get_override( "Update" );
        if( func_Update.ptr() != Py_None )
            try {
                func_Update( eyeYaw, eyePitch );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseAnimState::Update( eyeYaw, eyePitch );
            }
        else
            this->UnitBaseAnimState::Update( eyeYaw, eyePitch );
    }
    
    void default_Update( float eyeYaw, float eyePitch ) {
        UnitBaseAnimState::Update( eyeYaw, eyePitch );
    }

};

struct UnitAnimState_wrapper : UnitAnimState, bp::wrapper< UnitAnimState > {

    UnitAnimState_wrapper(::boost::python::object outer, ::UnitAnimConfig & animconfig )
    : UnitAnimState( outer, boost::ref(animconfig) )
      , bp::wrapper< UnitAnimState >(){
        // constructor
    
    }

    void ComputePoseParam_BodyPitch( ::CStudioHdr * pStudioHdr ){
        UnitAnimState::ComputePoseParam_BodyPitch( boost::python::ptr(pStudioHdr) );
    }

    void ComputePoseParam_BodyYaw(  ){
        UnitAnimState::ComputePoseParam_BodyYaw(  );
    }

    void ComputePoseParam_Lean(  ){
        UnitAnimState::ComputePoseParam_Lean(  );
    }

    void ComputePoseParam_MoveYaw( ::CStudioHdr * pStudioHdr ){
        UnitAnimState::ComputePoseParam_MoveYaw( boost::python::ptr(pStudioHdr) );
    }

    int ConvergeAngles( float goal, float maxrate, float maxgap, float dt, float & current ){
        return UnitAnimState::ConvergeAngles( goal, maxrate, maxgap, dt, current );
    }

    void EndSpecificActivity(  ){
        UnitAnimState::EndSpecificActivity(  );
    }

    ::Activity GetCurrentMainSequenceActivity(  ) const {
        return UnitAnimState::GetCurrentMainSequenceActivity(  );
    }

    float GetEyeYaw(  ) const {
        return UnitAnimState::GetEyeYaw(  );
    }

    void GetOuterAbsVelocity( ::Vector & vel ) const {
        UnitAnimState::GetOuterAbsVelocity( boost::ref(vel) );
    }

    float GetOuterXYSpeed(  ) const {
        return UnitAnimState::GetOuterXYSpeed(  );
    }

    virtual ::Activity OnEndSpecificActivity( ::Activity specificactivity ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnEndSpecificActivity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnEndSpecificActivity( specificactivity ) of Class: UnitAnimState\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnEndSpecificActivity = this->get_override( "OnEndSpecificActivity" );
        if( func_OnEndSpecificActivity.ptr() != Py_None )
            try {
                return func_OnEndSpecificActivity( specificactivity );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitAnimState::OnEndSpecificActivity( specificactivity );
            }
        else
            return this->UnitAnimState::OnEndSpecificActivity( specificactivity );
    }
    
    ::Activity default_OnEndSpecificActivity( ::Activity specificactivity ) {
        return UnitAnimState::OnEndSpecificActivity( specificactivity );
    }

    virtual void OnNewModel(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnNewModel: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnNewModel(  ) of Class: UnitAnimState\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnNewModel = this->get_override( "OnNewModel" );
        if( func_OnNewModel.ptr() != Py_None )
            try {
                func_OnNewModel(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitAnimState::OnNewModel(  );
            }
        else
            this->UnitAnimState::OnNewModel(  );
    }
    
    void default_OnNewModel(  ) {
        UnitAnimState::OnNewModel( );
    }

    void ResetGroundSpeed(  ){
        UnitAnimState::ResetGroundSpeed(  );
    }

    float TimeSinceLastAnimationStateClear(  ) const {
        return UnitAnimState::TimeSinceLastAnimationStateClear(  );
    }

    void UpdateLayerSequenceGeneric( int iLayer, bool & bEnabled, float & flCurCycle, int & iSequence, bool bWaitAtEnd, float fBlendIn=1.500000059604644775390625e-1f, float fBlendOut=1.500000059604644775390625e-1f, bool bMoveBlend=false, float fPlaybackRate=1.0e+0f, bool bUpdateCycle=true ){
        UnitAnimState::UpdateLayerSequenceGeneric( iLayer, bEnabled, flCurCycle, iSequence, bWaitAtEnd, fBlendIn, fBlendOut, bMoveBlend, fPlaybackRate, bUpdateCycle );
    }

    virtual int SelectWeightedSequence( ::Activity activity ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SelectWeightedSequence: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SelectWeightedSequence( activity ) of Class: UnitBaseAnimState\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SelectWeightedSequence = this->get_override( "SelectWeightedSequence" );
        if( func_SelectWeightedSequence.ptr() != Py_None )
            try {
                return func_SelectWeightedSequence( activity );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseAnimState::SelectWeightedSequence( activity );
            }
        else
            return this->UnitBaseAnimState::SelectWeightedSequence( activity );
    }
    
    int default_SelectWeightedSequence( ::Activity activity ) {
        return UnitBaseAnimState::SelectWeightedSequence( activity );
    }

};

struct UnitBaseLocomotion_wrapper : UnitBaseLocomotion, bp::wrapper< UnitBaseLocomotion > {

    UnitBaseLocomotion_wrapper(UnitBaseLocomotion const & arg )
    : UnitBaseLocomotion( arg )
      , bp::wrapper< UnitBaseLocomotion >(){
        // copy constructor
        
    }

    UnitBaseLocomotion_wrapper(::boost::python::object outer )
    : UnitBaseLocomotion( outer )
      , bp::wrapper< UnitBaseLocomotion >(){
        // constructor
    
    }

    virtual void HandleJump(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "HandleJump: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling HandleJump(  ) of Class: UnitBaseLocomotion\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_HandleJump = this->get_override( "HandleJump" );
        if( func_HandleJump.ptr() != Py_None )
            try {
                func_HandleJump(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseLocomotion::HandleJump(  );
            }
        else
            this->UnitBaseLocomotion::HandleJump(  );
    }
    
    void default_HandleJump(  ) {
        UnitBaseLocomotion::HandleJump( );
    }

};

struct UnitBaseAirLocomotion_wrapper : UnitBaseAirLocomotion, bp::wrapper< UnitBaseAirLocomotion > {

    UnitBaseAirLocomotion_wrapper(UnitBaseAirLocomotion const & arg )
    : UnitBaseAirLocomotion( arg )
      , bp::wrapper< UnitBaseAirLocomotion >(){
        // copy constructor
        
    }

    UnitBaseAirLocomotion_wrapper(::boost::python::object outer )
    : UnitBaseAirLocomotion( outer )
      , bp::wrapper< UnitBaseAirLocomotion >(){
        // constructor
    
    }

    virtual void HandleJump(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "HandleJump: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling HandleJump(  ) of Class: UnitBaseLocomotion\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_HandleJump = this->get_override( "HandleJump" );
        if( func_HandleJump.ptr() != Py_None )
            try {
                func_HandleJump(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseLocomotion::HandleJump(  );
            }
        else
            this->UnitBaseLocomotion::HandleJump(  );
    }
    
    void default_HandleJump(  ) {
        UnitBaseLocomotion::HandleJump( );
    }

};

BOOST_PYTHON_MODULE(unit_helper){
    bp::docstring_options doc_options( true, true, false );

    bp::enum_< LegAnimType_t>("LegAnimType_t")
        .value("LEGANIM_9WAY", LEGANIM_9WAY)
        .value("LEGANIM_8WAY", LEGANIM_8WAY)
        .value("LEGANIM_GOLDSRC", LEGANIM_GOLDSRC)
        .export_values()
        ;

    { //::TranslateActivityMap
        typedef bp::class_< TranslateActivityMap, boost::noncopyable > TranslateActivityMap_exposer_t;
        TranslateActivityMap_exposer_t TranslateActivityMap_exposer = TranslateActivityMap_exposer_t( "TranslateActivityMap", bp::init< >() );
        bp::scope TranslateActivityMap_scope( TranslateActivityMap_exposer );
        TranslateActivityMap_exposer.def( bp::init< TranslateActivityMap & >(( bp::arg("activitymap") )) );
        bp::implicitly_convertible< TranslateActivityMap &, TranslateActivityMap >();
        TranslateActivityMap_exposer.def( bp::init< bp::dict >(( bp::arg("d") )) );
        bp::implicitly_convertible< bp::dict, TranslateActivityMap >();
        TranslateActivityMap_exposer.def( bp::init< TranslateActivityMap &, bp::dict >(( bp::arg("activitymap"), bp::arg("d") )) );
        { //::TranslateActivityMap::AddTranslation
        
            typedef void ( ::TranslateActivityMap::*AddTranslation_function_type )( ::Activity,::Activity ) ;
            
            TranslateActivityMap_exposer.def( 
                "AddTranslation"
                , AddTranslation_function_type( &::TranslateActivityMap::AddTranslation )
                , ( bp::arg("act"), bp::arg("act_translated") ) );
        
        }
        { //::TranslateActivityMap::AddTranslations
        
            typedef void ( ::TranslateActivityMap::*AddTranslations_function_type )( ::boost::python::dict ) ;
            
            TranslateActivityMap_exposer.def( 
                "AddTranslations"
                , AddTranslations_function_type( &::TranslateActivityMap::AddTranslations )
                , ( bp::arg("d") ) );
        
        }
        { //::TranslateActivityMap::DebugPrint
        
            typedef void ( ::TranslateActivityMap::*DebugPrint_function_type )(  ) ;
            
            TranslateActivityMap_exposer.def( 
                "DebugPrint"
                , DebugPrint_function_type( &::TranslateActivityMap::DebugPrint ) );
        
        }
    }

    { //::UnitAnimConfig
        typedef bp::class_< UnitAnimConfig > UnitAnimConfig_exposer_t;
        UnitAnimConfig_exposer_t UnitAnimConfig_exposer = UnitAnimConfig_exposer_t( "UnitAnimConfig", bp::init< >() );
        bp::scope UnitAnimConfig_scope( UnitAnimConfig_exposer );
        UnitAnimConfig_exposer.def( bp::init< float, bp::optional< bool, LegAnimType_t, bool, bool > >(( bp::arg("maxbodyyawdegrees"), bp::arg("bodyyawnormalized")=(bool)(false), bp::arg("leganimtype")=::LEGANIM_8WAY, bp::arg("useaimsequences")=(bool)(false), bp::arg("invertposeparameters")=(bool)(false) )) );
        bp::implicitly_convertible< float, UnitAnimConfig >();
        UnitAnimConfig_exposer.def_readwrite( "leganimtype", &UnitAnimConfig::m_LegAnimType );
        UnitAnimConfig_exposer.def_readwrite( "bodyyawnormalized", &UnitAnimConfig::m_bBodyYawNormalized );
        UnitAnimConfig_exposer.def_readwrite( "invertposeparameters", &UnitAnimConfig::m_bInvertPoseParameters );
        UnitAnimConfig_exposer.def_readwrite( "useaimsequences", &UnitAnimConfig::m_bUseAimSequences );
        UnitAnimConfig_exposer.def_readwrite( "maxbodyyawdegrees", &UnitAnimConfig::m_flMaxBodyYawDegrees );
    }

    { //::UnitComponent
        typedef bp::class_< UnitComponent > UnitComponent_exposer_t;
        UnitComponent_exposer_t UnitComponent_exposer = UnitComponent_exposer_t( "UnitComponent", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitComponent_scope( UnitComponent_exposer );
        bp::implicitly_convertible< bp::object, UnitComponent >();
        { //::UnitComponent::GetAbsAngles
        
            typedef ::QAngle const & ( ::UnitComponent::*GetAbsAngles_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetAbsAngles"
                , GetAbsAngles_function_type( &::UnitComponent::GetAbsAngles )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetAbsOrigin
        
            typedef ::Vector const & ( ::UnitComponent::*GetAbsOrigin_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetAbsOrigin"
                , GetAbsOrigin_function_type( &::UnitComponent::GetAbsOrigin )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetAbsVelocity
        
            typedef ::Vector const & ( ::UnitComponent::*GetAbsVelocity_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetAbsVelocity"
                , GetAbsVelocity_function_type( &::UnitComponent::GetAbsVelocity )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetCollisionGroup
        
            typedef int ( ::UnitComponent::*GetCollisionGroup_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetCollisionGroup"
                , GetCollisionGroup_function_type( &::UnitComponent::GetCollisionGroup ) );
        
        }
        { //::UnitComponent::GetCycle
        
            typedef float ( ::UnitComponent::*GetCycle_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetCycle"
                , GetCycle_function_type( &::UnitComponent::GetCycle ) );
        
        }
        { //::UnitComponent::GetFlags
        
            typedef int ( ::UnitComponent::*GetFlags_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetFlags"
                , GetFlags_function_type( &::UnitComponent::GetFlags ) );
        
        }
        { //::UnitComponent::GetGravity
        
            typedef float ( ::UnitComponent::*GetGravity_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetGravity"
                , GetGravity_function_type( &::UnitComponent::GetGravity ) );
        
        }
        { //::UnitComponent::GetGroundEntity
        
            typedef ::C_BaseEntity * ( ::UnitComponent::*GetGroundEntity_function_type )(  ) ;
            
            UnitComponent_exposer.def( 
                "GetGroundEntity"
                , GetGroundEntity_function_type( &::UnitComponent::GetGroundEntity )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::UnitComponent::GetLocalAngles
        
            typedef ::QAngle const & ( ::UnitComponent::*GetLocalAngles_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetLocalAngles"
                , GetLocalAngles_function_type( &::UnitComponent::GetLocalAngles )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetLocalOrigin
        
            typedef ::Vector const & ( ::UnitComponent::*GetLocalOrigin_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetLocalOrigin"
                , GetLocalOrigin_function_type( &::UnitComponent::GetLocalOrigin )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetLocalVelocity
        
            typedef ::Vector const & ( ::UnitComponent::*GetLocalVelocity_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetLocalVelocity"
                , GetLocalVelocity_function_type( &::UnitComponent::GetLocalVelocity )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetSequence
        
            typedef int ( ::UnitComponent::*GetSequence_function_type )(  ) ;
            
            UnitComponent_exposer.def( 
                "GetSequence"
                , GetSequence_function_type( &::UnitComponent::GetSequence ) );
        
        }
        { //::UnitComponent::GetSolid
        
            typedef ::SolidType_t ( ::UnitComponent::*GetSolid_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetSolid"
                , GetSolid_function_type( &::UnitComponent::GetSolid ) );
        
        }
        { //::UnitComponent::IsActivityFinished
        
            typedef bool ( ::UnitComponent::*IsActivityFinished_function_type )(  ) ;
            
            UnitComponent_exposer.def( 
                "IsActivityFinished"
                , IsActivityFinished_function_type( &::UnitComponent::IsActivityFinished ) );
        
        }
        { //::UnitComponent::IsSequenceFinished
        
            typedef bool ( ::UnitComponent::*IsSequenceFinished_function_type )(  ) ;
            
            UnitComponent_exposer.def( 
                "IsSequenceFinished"
                , IsSequenceFinished_function_type( &::UnitComponent::IsSequenceFinished ) );
        
        }
        { //::UnitComponent::ResetSequence
        
            typedef void ( ::UnitComponent::*ResetSequence_function_type )( int ) ;
            
            UnitComponent_exposer.def( 
                "ResetSequence"
                , ResetSequence_function_type( &::UnitComponent::ResetSequence )
                , ( bp::arg("nSequence") ) );
        
        }
        { //::UnitComponent::SetAbsVelocity
        
            typedef void ( ::UnitComponent::*SetAbsVelocity_function_type )( ::Vector const & ) ;
            
            UnitComponent_exposer.def( 
                "SetAbsVelocity"
                , SetAbsVelocity_function_type( &::UnitComponent::SetAbsVelocity )
                , ( bp::arg("vecVelocity") ) );
        
        }
        { //::UnitComponent::SetCycle
        
            typedef void ( ::UnitComponent::*SetCycle_function_type )( float ) ;
            
            UnitComponent_exposer.def( 
                "SetCycle"
                , SetCycle_function_type( &::UnitComponent::SetCycle )
                , ( bp::arg("flCycle") ) );
        
        }
        { //::UnitComponent::SetGravity
        
            typedef void ( ::UnitComponent::*SetGravity_function_type )( float ) ;
            
            UnitComponent_exposer.def( 
                "SetGravity"
                , SetGravity_function_type( &::UnitComponent::SetGravity )
                , ( bp::arg("flGravity") ) );
        
        }
        { //::UnitComponent::SetGroundEntity
        
            typedef void ( ::UnitComponent::*SetGroundEntity_function_type )( ::C_BaseEntity * ) ;
            
            UnitComponent_exposer.def( 
                "SetGroundEntity"
                , SetGroundEntity_function_type( &::UnitComponent::SetGroundEntity )
                , ( bp::arg("ground") ) );
        
        }
        { //::UnitComponent::SetLocalAngles
        
            typedef void ( ::UnitComponent::*SetLocalAngles_function_type )( ::QAngle const & ) ;
            
            UnitComponent_exposer.def( 
                "SetLocalAngles"
                , SetLocalAngles_function_type( &::UnitComponent::SetLocalAngles )
                , ( bp::arg("angles") ) );
        
        }
        { //::UnitComponent::SetLocalOrigin
        
            typedef void ( ::UnitComponent::*SetLocalOrigin_function_type )( ::Vector const & ) ;
            
            UnitComponent_exposer.def( 
                "SetLocalOrigin"
                , SetLocalOrigin_function_type( &::UnitComponent::SetLocalOrigin )
                , ( bp::arg("origin") ) );
        
        }
        { //::UnitComponent::SetLocalVelocity
        
            typedef void ( ::UnitComponent::*SetLocalVelocity_function_type )( ::Vector const & ) ;
            
            UnitComponent_exposer.def( 
                "SetLocalVelocity"
                , SetLocalVelocity_function_type( &::UnitComponent::SetLocalVelocity )
                , ( bp::arg("vecVelocity") ) );
        
        }
        { //::UnitComponent::SetSequence
        
            typedef void ( ::UnitComponent::*SetSequence_function_type )( int ) ;
            
            UnitComponent_exposer.def( 
                "SetSequence"
                , SetSequence_function_type( &::UnitComponent::SetSequence )
                , ( bp::arg("nSequence") ) );
        
        }
        { //::UnitComponent::SetSolid
        
            typedef void ( ::UnitComponent::*SetSolid_function_type )( ::SolidType_t ) ;
            
            UnitComponent_exposer.def( 
                "SetSolid"
                , SetSolid_function_type( &::UnitComponent::SetSolid )
                , ( bp::arg("val") ) );
        
        }
        { //::UnitComponent::StudioFrameAdvance
        
            typedef void ( ::UnitComponent::*StudioFrameAdvance_function_type )(  ) ;
            
            UnitComponent_exposer.def( 
                "StudioFrameAdvance"
                , StudioFrameAdvance_function_type( &::UnitComponent::StudioFrameAdvance ) );
        
        }
        { //::UnitComponent::WorldAlignMaxs
        
            typedef ::Vector const & ( ::UnitComponent::*WorldAlignMaxs_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "WorldAlignMaxs"
                , WorldAlignMaxs_function_type( &::UnitComponent::WorldAlignMaxs )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::WorldAlignMins
        
            typedef ::Vector const & ( ::UnitComponent::*WorldAlignMins_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "WorldAlignMins"
                , WorldAlignMins_function_type( &::UnitComponent::WorldAlignMins )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::WorldAlignSize
        
            typedef ::Vector const & ( ::UnitComponent::*WorldAlignSize_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "WorldAlignSize"
                , WorldAlignSize_function_type( &::UnitComponent::WorldAlignSize )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::WorldSpaceCenter
        
            typedef ::Vector ( ::UnitComponent::*WorldSpaceCenter_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "WorldSpaceCenter"
                , WorldSpaceCenter_function_type( &::UnitComponent::WorldSpaceCenter ) );
        
        }
        { //property "outer"[fget=::UnitComponent::GetPyOuter]
        
            typedef ::boost::python::object ( ::UnitComponent::*fget )(  ) ;
            
            UnitComponent_exposer.add_property( 
                "outer"
                , fget( &::UnitComponent::GetPyOuter ) );
        
        }
    }

    { //::UnitBaseAnimState
        typedef bp::class_< UnitBaseAnimState_wrapper, bp::bases< UnitComponent > > UnitBaseAnimState_exposer_t;
        UnitBaseAnimState_exposer_t UnitBaseAnimState_exposer = UnitBaseAnimState_exposer_t( "UnitBaseAnimState", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitBaseAnimState_scope( UnitBaseAnimState_exposer );
        bp::implicitly_convertible< bp::object, UnitBaseAnimState >();
        { //::UnitBaseAnimState::GetAnimTimeInterval
        
            typedef float ( ::UnitBaseAnimState::*GetAnimTimeInterval_function_type )(  ) const;
            
            UnitBaseAnimState_exposer.def( 
                "GetAnimTimeInterval"
                , GetAnimTimeInterval_function_type( &::UnitBaseAnimState::GetAnimTimeInterval ) );
        
        }
        { //::UnitBaseAnimState::HasActivity
        
            typedef bool ( ::UnitBaseAnimState::*HasActivity_function_type )( ::Activity ) ;
            
            UnitBaseAnimState_exposer.def( 
                "HasActivity"
                , HasActivity_function_type( &::UnitBaseAnimState::HasActivity )
                , ( bp::arg("actDesired") ) );
        
        }
        { //::UnitBaseAnimState::SelectWeightedSequence
        
            typedef int ( ::UnitBaseAnimState::*SelectWeightedSequence_function_type )( ::Activity ) ;
            typedef int ( UnitBaseAnimState_wrapper::*default_SelectWeightedSequence_function_type )( ::Activity ) ;
            
            UnitBaseAnimState_exposer.def( 
                "SelectWeightedSequence"
                , SelectWeightedSequence_function_type(&::UnitBaseAnimState::SelectWeightedSequence)
                , default_SelectWeightedSequence_function_type(&UnitBaseAnimState_wrapper::default_SelectWeightedSequence)
                , ( bp::arg("activity") ) );
        
        }
        { //::UnitBaseAnimState::Update
        
            typedef void ( ::UnitBaseAnimState::*Update_function_type )( float,float ) ;
            typedef void ( UnitBaseAnimState_wrapper::*default_Update_function_type )( float,float ) ;
            
            UnitBaseAnimState_exposer.def( 
                "Update"
                , Update_function_type(&::UnitBaseAnimState::Update)
                , default_Update_function_type(&UnitBaseAnimState_wrapper::default_Update)
                , ( bp::arg("eyeYaw"), bp::arg("eyePitch") ) );
        
        }
    }

    { //::UnitAnimState
        typedef bp::class_< UnitAnimState_wrapper, bp::bases< UnitBaseAnimState >, boost::noncopyable > UnitAnimState_exposer_t;
        UnitAnimState_exposer_t UnitAnimState_exposer = UnitAnimState_exposer_t( "UnitAnimState", bp::init< bp::object, UnitAnimConfig & >(( bp::arg("outer"), bp::arg("animconfig") )) );
        bp::scope UnitAnimState_scope( UnitAnimState_exposer );
        bp::scope().attr("TURN_NONE") = (int)UnitAnimState::TURN_NONE;
        bp::scope().attr("TURN_LEFT") = (int)UnitAnimState::TURN_LEFT;
        bp::scope().attr("TURN_RIGHT") = (int)UnitAnimState::TURN_RIGHT;
        { //::UnitAnimState::CalcAimLayerSequence
        
            typedef int ( ::UnitAnimState::*CalcAimLayerSequence_function_type )( float *,float *,bool ) ;
            
            UnitAnimState_exposer.def( 
                "CalcAimLayerSequence"
                , CalcAimLayerSequence_function_type( &::UnitAnimState::CalcAimLayerSequence )
                , ( bp::arg("flCycle"), bp::arg("flAimSequenceWeight"), bp::arg("bForceIdle") ) );
        
        }
        { //::UnitAnimState::CalcMainActivity
        
            typedef ::Activity ( ::UnitAnimState::*CalcMainActivity_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "CalcMainActivity"
                , CalcMainActivity_function_type( &::UnitAnimState::CalcMainActivity ) );
        
        }
        { //::UnitAnimState::CalcMovementPlaybackRate
        
            typedef float ( ::UnitAnimState::*CalcMovementPlaybackRate_function_type )( bool * ) ;
            
            UnitAnimState_exposer.def( 
                "CalcMovementPlaybackRate"
                , CalcMovementPlaybackRate_function_type( &::UnitAnimState::CalcMovementPlaybackRate )
                , ( bp::arg("bIsMoving") ) );
        
        }
        { //::UnitAnimState::CanThePlayerMove
        
            typedef bool ( ::UnitAnimState::*CanThePlayerMove_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "CanThePlayerMove"
                , CanThePlayerMove_function_type( &::UnitAnimState::CanThePlayerMove ) );
        
        }
        { //::UnitAnimState::ClearAnimationLayers
        
            typedef void ( ::UnitAnimState::*ClearAnimationLayers_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ClearAnimationLayers"
                , ClearAnimationLayers_function_type( &::UnitAnimState::ClearAnimationLayers ) );
        
        }
        { //::UnitAnimState::ClearAnimationState
        
            typedef void ( ::UnitAnimState::*ClearAnimationState_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ClearAnimationState"
                , ClearAnimationState_function_type( &::UnitAnimState::ClearAnimationState ) );
        
        }
        { //::UnitAnimState::ComputeMiscSequence
        
            typedef void ( ::UnitAnimState::*ComputeMiscSequence_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ComputeMiscSequence"
                , ComputeMiscSequence_function_type( &::UnitAnimState::ComputeMiscSequence ) );
        
        }
        { //::UnitAnimState::ComputePoseParam_BodyPitch
        
            typedef void ( UnitAnimState_wrapper::*ComputePoseParam_BodyPitch_function_type )( ::CStudioHdr * ) ;
            
            UnitAnimState_exposer.def( 
                "ComputePoseParam_BodyPitch"
                , ComputePoseParam_BodyPitch_function_type( &UnitAnimState_wrapper::ComputePoseParam_BodyPitch )
                , ( bp::arg("pStudioHdr") ) );
        
        }
        { //::UnitAnimState::ComputePoseParam_BodyYaw
        
            typedef void ( UnitAnimState_wrapper::*ComputePoseParam_BodyYaw_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ComputePoseParam_BodyYaw"
                , ComputePoseParam_BodyYaw_function_type( &UnitAnimState_wrapper::ComputePoseParam_BodyYaw ) );
        
        }
        { //::UnitAnimState::ComputePoseParam_Lean
        
            typedef void ( UnitAnimState_wrapper::*ComputePoseParam_Lean_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ComputePoseParam_Lean"
                , ComputePoseParam_Lean_function_type( &UnitAnimState_wrapper::ComputePoseParam_Lean ) );
        
        }
        { //::UnitAnimState::ComputePoseParam_MoveYaw
        
            typedef void ( UnitAnimState_wrapper::*ComputePoseParam_MoveYaw_function_type )( ::CStudioHdr * ) ;
            
            UnitAnimState_exposer.def( 
                "ComputePoseParam_MoveYaw"
                , ComputePoseParam_MoveYaw_function_type( &UnitAnimState_wrapper::ComputePoseParam_MoveYaw )
                , ( bp::arg("pStudioHdr") ) );
        
        }
        { //::UnitAnimState::ComputeSequences
        
            typedef void ( ::UnitAnimState::*ComputeSequences_function_type )( ::CStudioHdr * ) ;
            
            UnitAnimState_exposer.def( 
                "ComputeSequences"
                , ComputeSequences_function_type( &::UnitAnimState::ComputeSequences )
                , ( bp::arg("pStudioHdr") ) );
        
        }
        { //::UnitAnimState::ConvergeAngles
        
            typedef int ( UnitAnimState_wrapper::*ConvergeAngles_function_type )( float,float,float,float,float & ) ;
            
            UnitAnimState_exposer.def( 
                "ConvergeAngles"
                , ConvergeAngles_function_type( &UnitAnimState_wrapper::ConvergeAngles )
                , ( bp::arg("goal"), bp::arg("maxrate"), bp::arg("maxgap"), bp::arg("dt"), bp::arg("current") ) );
        
        }
        { //::UnitAnimState::DebugShowAnimState
        
            typedef void ( ::UnitAnimState::*DebugShowAnimState_function_type )( int ) ;
            
            UnitAnimState_exposer.def( 
                "DebugShowAnimState"
                , DebugShowAnimState_function_type( &::UnitAnimState::DebugShowAnimState )
                , ( bp::arg("iStartLine") ) );
        
        }
        { //::UnitAnimState::DebugShowAnimStateFull
        
            typedef void ( ::UnitAnimState::*DebugShowAnimStateFull_function_type )( int ) ;
            
            UnitAnimState_exposer.def( 
                "DebugShowAnimStateFull"
                , DebugShowAnimStateFull_function_type( &::UnitAnimState::DebugShowAnimStateFull )
                , ( bp::arg("iStartLine") ) );
        
        }
        { //::UnitAnimState::EndSpecificActivity
        
            typedef void ( UnitAnimState_wrapper::*EndSpecificActivity_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "EndSpecificActivity"
                , EndSpecificActivity_function_type( &UnitAnimState_wrapper::EndSpecificActivity ) );
        
        }
        { //::UnitAnimState::GetActivityMap
        
            typedef ::boost::python::object ( ::UnitAnimState::*GetActivityMap_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "GetActivityMap"
                , GetActivityMap_function_type( &::UnitAnimState::GetActivityMap ) );
        
        }
        { //::UnitAnimState::GetCurrentMainSequenceActivity
        
            typedef ::Activity ( UnitAnimState_wrapper::*GetCurrentMainSequenceActivity_function_type )(  ) const;
            
            UnitAnimState_exposer.def( 
                "GetCurrentMainSequenceActivity"
                , GetCurrentMainSequenceActivity_function_type( &UnitAnimState_wrapper::GetCurrentMainSequenceActivity ) );
        
        }
        { //::UnitAnimState::GetCurrentMaxGroundSpeed
        
            typedef float ( ::UnitAnimState::*GetCurrentMaxGroundSpeed_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "GetCurrentMaxGroundSpeed"
                , GetCurrentMaxGroundSpeed_function_type( &::UnitAnimState::GetCurrentMaxGroundSpeed ) );
        
        }
        { //::UnitAnimState::GetEyeYaw
        
            typedef float ( UnitAnimState_wrapper::*GetEyeYaw_function_type )(  ) const;
            
            UnitAnimState_exposer.def( 
                "GetEyeYaw"
                , GetEyeYaw_function_type( &UnitAnimState_wrapper::GetEyeYaw ) );
        
        }
        { //::UnitAnimState::GetMiscCycle
        
            typedef float ( ::UnitAnimState::*GetMiscCycle_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "GetMiscCycle"
                , GetMiscCycle_function_type( &::UnitAnimState::GetMiscCycle ) );
        
        }
        { //::UnitAnimState::GetMiscSequence
        
            typedef int ( ::UnitAnimState::*GetMiscSequence_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "GetMiscSequence"
                , GetMiscSequence_function_type( &::UnitAnimState::GetMiscSequence ) );
        
        }
        { //::UnitAnimState::GetOuterAbsVelocity
        
            typedef void ( UnitAnimState_wrapper::*GetOuterAbsVelocity_function_type )( ::Vector & ) const;
            
            UnitAnimState_exposer.def( 
                "GetOuterAbsVelocity"
                , GetOuterAbsVelocity_function_type( &UnitAnimState_wrapper::GetOuterAbsVelocity )
                , ( bp::arg("vel") ) );
        
        }
        { //::UnitAnimState::GetOuterXYSpeed
        
            typedef float ( UnitAnimState_wrapper::*GetOuterXYSpeed_function_type )(  ) const;
            
            UnitAnimState_exposer.def( 
                "GetOuterXYSpeed"
                , GetOuterXYSpeed_function_type( &UnitAnimState_wrapper::GetOuterXYSpeed ) );
        
        }
        { //::UnitAnimState::GetRenderAngles
        
            typedef ::QAngle const & ( ::UnitAnimState::*GetRenderAngles_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "GetRenderAngles"
                , GetRenderAngles_function_type( &::UnitAnimState::GetRenderAngles )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitAnimState::HandleClimbing
        
            typedef bool ( ::UnitAnimState::*HandleClimbing_function_type )( ::Activity & ) ;
            
            UnitAnimState_exposer.def( 
                "HandleClimbing"
                , HandleClimbing_function_type( &::UnitAnimState::HandleClimbing )
                , ( bp::arg("idealActivity") ) );
        
        }
        { //::UnitAnimState::HandleCrouching
        
            typedef bool ( ::UnitAnimState::*HandleCrouching_function_type )( ::Activity & ) ;
            
            UnitAnimState_exposer.def( 
                "HandleCrouching"
                , HandleCrouching_function_type( &::UnitAnimState::HandleCrouching )
                , ( bp::arg("idealActivity") ) );
        
        }
        { //::UnitAnimState::HandleJumping
        
            typedef bool ( ::UnitAnimState::*HandleJumping_function_type )( ::Activity & ) ;
            
            UnitAnimState_exposer.def( 
                "HandleJumping"
                , HandleJumping_function_type( &::UnitAnimState::HandleJumping )
                , ( bp::arg("idealActivity") ) );
        
        }
        { //::UnitAnimState::HasActivity
        
            typedef bool ( ::UnitAnimState::*HasActivity_function_type )( ::Activity ) ;
            
            UnitAnimState_exposer.def( 
                "HasActivity"
                , HasActivity_function_type( &::UnitAnimState::HasActivity )
                , ( bp::arg("actDesired") ) );
        
        }
        { //::UnitAnimState::OnEndSpecificActivity
        
            typedef ::Activity ( ::UnitAnimState::*OnEndSpecificActivity_function_type )( ::Activity ) ;
            typedef ::Activity ( UnitAnimState_wrapper::*default_OnEndSpecificActivity_function_type )( ::Activity ) ;
            
            UnitAnimState_exposer.def( 
                "OnEndSpecificActivity"
                , OnEndSpecificActivity_function_type(&::UnitAnimState::OnEndSpecificActivity)
                , default_OnEndSpecificActivity_function_type(&UnitAnimState_wrapper::default_OnEndSpecificActivity)
                , ( bp::arg("specificactivity") ) );
        
        }
        { //::UnitAnimState::OnNewModel
        
            typedef void ( ::UnitAnimState::*OnNewModel_function_type )(  ) ;
            typedef void ( UnitAnimState_wrapper::*default_OnNewModel_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "OnNewModel"
                , OnNewModel_function_type(&::UnitAnimState::OnNewModel)
                , default_OnNewModel_function_type(&UnitAnimState_wrapper::default_OnNewModel) );
        
        }
        { //::UnitAnimState::ResetGroundSpeed
        
            typedef void ( UnitAnimState_wrapper::*ResetGroundSpeed_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ResetGroundSpeed"
                , ResetGroundSpeed_function_type( &UnitAnimState_wrapper::ResetGroundSpeed ) );
        
        }
        { //::UnitAnimState::RestartMainSequence
        
            typedef void ( ::UnitAnimState::*RestartMainSequence_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "RestartMainSequence"
                , RestartMainSequence_function_type( &::UnitAnimState::RestartMainSequence ) );
        
        }
        { //::UnitAnimState::SetActivityMap
        
            typedef void ( ::UnitAnimState::*SetActivityMap_function_type )( ::boost::python::object ) ;
            
            UnitAnimState_exposer.def( 
                "SetActivityMap"
                , SetActivityMap_function_type( &::UnitAnimState::SetActivityMap )
                , ( bp::arg("activitymap") ) );
        
        }
        { //::UnitAnimState::SetMiscPlaybackRate
        
            typedef void ( ::UnitAnimState::*SetMiscPlaybackRate_function_type )( float ) ;
            
            UnitAnimState_exposer.def( 
                "SetMiscPlaybackRate"
                , SetMiscPlaybackRate_function_type( &::UnitAnimState::SetMiscPlaybackRate )
                , ( bp::arg("flRate") ) );
        
        }
        { //::UnitAnimState::SetOuterBodyYaw
        
            typedef float ( ::UnitAnimState::*SetOuterBodyYaw_function_type )( float ) ;
            
            UnitAnimState_exposer.def( 
                "SetOuterBodyYaw"
                , SetOuterBodyYaw_function_type( &::UnitAnimState::SetOuterBodyYaw )
                , ( bp::arg("flValue") ) );
        
        }
        { //::UnitAnimState::ShouldBlendAimSequenceToIdle
        
            typedef bool ( ::UnitAnimState::*ShouldBlendAimSequenceToIdle_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ShouldBlendAimSequenceToIdle"
                , ShouldBlendAimSequenceToIdle_function_type( &::UnitAnimState::ShouldBlendAimSequenceToIdle ) );
        
        }
        { //::UnitAnimState::ShouldChangeSequences
        
            typedef bool ( ::UnitAnimState::*ShouldChangeSequences_function_type )(  ) const;
            
            UnitAnimState_exposer.def( 
                "ShouldChangeSequences"
                , ShouldChangeSequences_function_type( &::UnitAnimState::ShouldChangeSequences ) );
        
        }
        { //::UnitAnimState::ShouldResetGroundSpeed
        
            typedef bool ( ::UnitAnimState::*ShouldResetGroundSpeed_function_type )( ::Activity,::Activity ) ;
            
            UnitAnimState_exposer.def( 
                "ShouldResetGroundSpeed"
                , ShouldResetGroundSpeed_function_type( &::UnitAnimState::ShouldResetGroundSpeed )
                , ( bp::arg("oldActivity"), bp::arg("idealActivity") ) );
        
        }
        { //::UnitAnimState::ShouldUpdateAnimState
        
            typedef bool ( ::UnitAnimState::*ShouldUpdateAnimState_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ShouldUpdateAnimState"
                , ShouldUpdateAnimState_function_type( &::UnitAnimState::ShouldUpdateAnimState ) );
        
        }
        { //::UnitAnimState::TimeSinceLastAnimationStateClear
        
            typedef float ( UnitAnimState_wrapper::*TimeSinceLastAnimationStateClear_function_type )(  ) const;
            
            UnitAnimState_exposer.def( 
                "TimeSinceLastAnimationStateClear"
                , TimeSinceLastAnimationStateClear_function_type( &UnitAnimState_wrapper::TimeSinceLastAnimationStateClear ) );
        
        }
        { //::UnitAnimState::TranslateActivity
        
            typedef ::Activity ( ::UnitAnimState::*TranslateActivity_function_type )( ::Activity ) ;
            
            UnitAnimState_exposer.def( 
                "TranslateActivity"
                , TranslateActivity_function_type( &::UnitAnimState::TranslateActivity )
                , ( bp::arg("actDesired") ) );
        
        }
        { //::UnitAnimState::Update
        
            typedef void ( ::UnitAnimState::*Update_function_type )( float,float ) ;
            
            UnitAnimState_exposer.def( 
                "Update"
                , Update_function_type( &::UnitAnimState::Update )
                , ( bp::arg("eyeYaw"), bp::arg("eyePitch") ) );
        
        }
        { //::UnitAnimState::UpdateLayerSequenceGeneric
        
            typedef void ( UnitAnimState_wrapper::*UpdateLayerSequenceGeneric_function_type )( int,bool &,float &,int &,bool,float,float,bool,float,bool ) ;
            
            UnitAnimState_exposer.def( 
                "UpdateLayerSequenceGeneric"
                , UpdateLayerSequenceGeneric_function_type( &UnitAnimState_wrapper::UpdateLayerSequenceGeneric )
                , ( bp::arg("iLayer"), bp::arg("bEnabled"), bp::arg("flCurCycle"), bp::arg("iSequence"), bp::arg("bWaitAtEnd"), bp::arg("fBlendIn")=1.500000059604644775390625e-1f, bp::arg("fBlendOut")=1.500000059604644775390625e-1f, bp::arg("bMoveBlend")=(bool)(false), bp::arg("fPlaybackRate")=1.0e+0f, bp::arg("bUpdateCycle")=(bool)(true) ) );
        
        }
        UnitAnimState_exposer.def_readwrite( "combatstateifenemy", &UnitAnimState::m_bCombatStateIfEnemy );
        UnitAnimState_exposer.def_readwrite( "firstjumpframe", &UnitAnimState::m_bFirstJumpFrame );
        UnitAnimState_exposer.def_readwrite( "flipmovey", &UnitAnimState::m_bFlipMoveY );
        UnitAnimState_exposer.def_readwrite( "jumping", &UnitAnimState::m_bJumping );
        UnitAnimState_exposer.def_readwrite( "miscnooverride", &UnitAnimState::m_bMiscNoOverride );
        UnitAnimState_exposer.def_readwrite( "misconlywhenstill", &UnitAnimState::m_bMiscOnlyWhenStill );
        UnitAnimState_exposer.def_readwrite( "newjump", &UnitAnimState::m_bNewJump );
        UnitAnimState_exposer.def_readwrite( "playfallactinair", &UnitAnimState::m_bPlayFallActInAir );
        UnitAnimState_exposer.def_readwrite( "playermisc", &UnitAnimState::m_bPlayingMisc );
        UnitAnimState_exposer.def_readwrite( "usecombatstate", &UnitAnimState::m_bUseCombatState );
        UnitAnimState_exposer.def_readwrite( "combatstatetime", &UnitAnimState::m_fCombatStateTime );
        UnitAnimState_exposer.def_readwrite( "miscplaybackrate", &UnitAnimState::m_fMiscPlaybackRate );
        UnitAnimState_exposer.def_readwrite( "facefronttime", &UnitAnimState::m_flFaceFrontTime );
        UnitAnimState_exposer.def_readwrite( "feetyawrate", &UnitAnimState::m_flFeetYawRate );
        UnitAnimState_exposer.def_readwrite( "jumpstarttime", &UnitAnimState::m_flJumpStartTime );
        UnitAnimState_exposer.def_readwrite( "miscblendin", &UnitAnimState::m_flMiscBlendIn );
        UnitAnimState_exposer.def_readwrite( "miscblendout", &UnitAnimState::m_flMiscBlendOut );
        UnitAnimState_exposer.def_readwrite( "misccycle", &UnitAnimState::m_flMiscCycle );
        UnitAnimState_exposer.def_readwrite( "bodypitch", &UnitAnimState::m_iBodyPitch );
        UnitAnimState_exposer.def_readwrite( "bodyyaw", &UnitAnimState::m_iBodyYaw );
        UnitAnimState_exposer.def_readwrite( "leanpitch", &UnitAnimState::m_iLeanPitch );
        UnitAnimState_exposer.def_readwrite( "leanyaw", &UnitAnimState::m_iLeanYaw );
        UnitAnimState_exposer.def_readwrite( "miscsequence", &UnitAnimState::m_iMiscSequence );
        UnitAnimState_exposer.def_readwrite( "movex", &UnitAnimState::m_iMoveX );
        UnitAnimState_exposer.def_readwrite( "movey", &UnitAnimState::m_iMoveY );
        UnitAnimState_exposer.def_readwrite( "moveyaw", &UnitAnimState::m_iMoveYaw );
        UnitAnimState_exposer.def_readwrite( "specificmainactivity", &UnitAnimState::m_nSpecificMainActivity );
        { //::UnitBaseAnimState::SelectWeightedSequence
        
            typedef int ( ::UnitBaseAnimState::*SelectWeightedSequence_function_type )( ::Activity ) ;
            typedef int ( UnitAnimState_wrapper::*default_SelectWeightedSequence_function_type )( ::Activity ) ;
            
            UnitAnimState_exposer.def( 
                "SelectWeightedSequence"
                , SelectWeightedSequence_function_type(&::UnitBaseAnimState::SelectWeightedSequence)
                , default_SelectWeightedSequence_function_type(&UnitAnimState_wrapper::default_SelectWeightedSequence)
                , ( bp::arg("activity") ) );
        
        }
        { //property "aimlayersequence"[fget=::UnitAnimState::GetAimLayerSequence, fset=::UnitAnimState::SetAimLayerSequence]
        
            typedef char const * ( ::UnitAnimState::*fget )(  ) ;
            typedef void ( ::UnitAnimState::*fset )( char const * ) ;
            
            UnitAnimState_exposer.add_property( 
                "aimlayersequence"
                , fget( &::UnitAnimState::GetAimLayerSequence )
                , fset( &::UnitAnimState::SetAimLayerSequence ) );
        
        }
        { //property "specmainactplaybackrate"[fget=::UnitAnimState::GetCustomSpecificActPlaybackRate, fset=::UnitAnimState::SetCustomSpecificActPlaybackRate]
        
            typedef float ( ::UnitAnimState::*fget )(  ) ;
            typedef void ( ::UnitAnimState::*fset )( float ) ;
            
            UnitAnimState_exposer.add_property( 
                "specmainactplaybackrate"
                , fget( &::UnitAnimState::GetCustomSpecificActPlaybackRate )
                , fset( &::UnitAnimState::SetCustomSpecificActPlaybackRate ) );
        
        }
    }

    { //::UnitBaseLocomotion
        typedef bp::class_< UnitBaseLocomotion_wrapper, bp::bases< UnitComponent > > UnitBaseLocomotion_exposer_t;
        UnitBaseLocomotion_exposer_t UnitBaseLocomotion_exposer = UnitBaseLocomotion_exposer_t( "UnitBaseLocomotion", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitBaseLocomotion_scope( UnitBaseLocomotion_exposer );
        bp::implicitly_convertible< bp::object, UnitBaseLocomotion >();
        { //::UnitBaseLocomotion::Accelerate
        
            typedef void ( ::UnitBaseLocomotion::*Accelerate_function_type )( ::Vector &,float,float ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "Accelerate"
                , Accelerate_function_type( &::UnitBaseLocomotion::Accelerate )
                , ( bp::arg("wishdir"), bp::arg("wishspeed"), bp::arg("accel") ) );
        
        }
        { //::UnitBaseLocomotion::AirAccelerate
        
            typedef void ( ::UnitBaseLocomotion::*AirAccelerate_function_type )( ::Vector &,float,float ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "AirAccelerate"
                , AirAccelerate_function_type( &::UnitBaseLocomotion::AirAccelerate )
                , ( bp::arg("wishdir"), bp::arg("wishspeed"), bp::arg("accel") ) );
        
        }
        { //::UnitBaseLocomotion::AirMove
        
            typedef void ( ::UnitBaseLocomotion::*AirMove_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "AirMove"
                , AirMove_function_type( &::UnitBaseLocomotion::AirMove ) );
        
        }
        { //::UnitBaseLocomotion::CanAccelerate
        
            typedef bool ( ::UnitBaseLocomotion::*CanAccelerate_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "CanAccelerate"
                , CanAccelerate_function_type( &::UnitBaseLocomotion::CanAccelerate ) );
        
        }
        { //::UnitBaseLocomotion::CategorizePosition
        
            typedef void ( ::UnitBaseLocomotion::*CategorizePosition_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "CategorizePosition"
                , CategorizePosition_function_type( &::UnitBaseLocomotion::CategorizePosition ) );
        
        }
        { //::UnitBaseLocomotion::CheckStep
        
            typedef bool ( ::UnitBaseLocomotion::*CheckStep_function_type )( ::UnitCheckStepArgs_t const &,::UnitCheckStepResult_t * ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "CheckStep"
                , CheckStep_function_type( &::UnitBaseLocomotion::CheckStep )
                , ( bp::arg("args"), bp::arg("pResult") ) );
        
        }
        { //::UnitBaseLocomotion::ClipVelocity
        
            typedef int ( ::UnitBaseLocomotion::*ClipVelocity_function_type )( ::Vector &,::Vector &,::Vector &,float ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "ClipVelocity"
                , ClipVelocity_function_type( &::UnitBaseLocomotion::ClipVelocity )
                , ( bp::arg("in"), bp::arg("normal"), bp::arg("out"), bp::arg("overbounce") ) );
        
        }
        { //::UnitBaseLocomotion::FinishGravity
        
            typedef void ( ::UnitBaseLocomotion::*FinishGravity_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "FinishGravity"
                , FinishGravity_function_type( &::UnitBaseLocomotion::FinishGravity ) );
        
        }
        { //::UnitBaseLocomotion::FinishMove
        
            typedef void ( ::UnitBaseLocomotion::*FinishMove_function_type )( ::UnitBaseMoveCommand & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "FinishMove"
                , FinishMove_function_type( &::UnitBaseLocomotion::FinishMove )
                , ( bp::arg("mv") ) );
        
        }
        { //::UnitBaseLocomotion::Friction
        
            typedef void ( ::UnitBaseLocomotion::*Friction_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "Friction"
                , Friction_function_type( &::UnitBaseLocomotion::Friction ) );
        
        }
        { //::UnitBaseLocomotion::FullWalkMove
        
            typedef void ( ::UnitBaseLocomotion::*FullWalkMove_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "FullWalkMove"
                , FullWalkMove_function_type( &::UnitBaseLocomotion::FullWalkMove ) );
        
        }
        { //::UnitBaseLocomotion::GetStopDistance
        
            typedef float ( ::UnitBaseLocomotion::*GetStopDistance_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "GetStopDistance"
                , GetStopDistance_function_type( &::UnitBaseLocomotion::GetStopDistance ) );
        
        }
        { //::UnitBaseLocomotion::GroundMove
        
            typedef void ( ::UnitBaseLocomotion::*GroundMove_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "GroundMove"
                , GroundMove_function_type( &::UnitBaseLocomotion::GroundMove ) );
        
        }
        { //::UnitBaseLocomotion::HandleJump
        
            typedef void ( ::UnitBaseLocomotion::*HandleJump_function_type )(  ) ;
            typedef void ( UnitBaseLocomotion_wrapper::*default_HandleJump_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "HandleJump"
                , HandleJump_function_type(&::UnitBaseLocomotion::HandleJump)
                , default_HandleJump_function_type(&UnitBaseLocomotion_wrapper::default_HandleJump) );
        
        }
        { //::UnitBaseLocomotion::Move
        
            typedef void ( ::UnitBaseLocomotion::*Move_function_type )( float,::UnitBaseMoveCommand & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "Move"
                , Move_function_type( &::UnitBaseLocomotion::Move )
                , ( bp::arg("interval"), bp::arg("mv") ) );
        
        }
        { //::UnitBaseLocomotion::MoveFacing
        
            typedef void ( ::UnitBaseLocomotion::*MoveFacing_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "MoveFacing"
                , MoveFacing_function_type( &::UnitBaseLocomotion::MoveFacing ) );
        
        }
        { //::UnitBaseLocomotion::PerformMovement
        
            typedef void ( ::UnitBaseLocomotion::*PerformMovement_function_type )( ::UnitBaseMoveCommand & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "PerformMovement"
                , PerformMovement_function_type( &::UnitBaseLocomotion::PerformMovement )
                , ( bp::arg("mv") ) );
        
        }
        { //::UnitBaseLocomotion::SetupMove
        
            typedef void ( ::UnitBaseLocomotion::*SetupMove_function_type )( ::UnitBaseMoveCommand & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "SetupMove"
                , SetupMove_function_type( &::UnitBaseLocomotion::SetupMove )
                , ( bp::arg("mv") ) );
        
        }
        { //::UnitBaseLocomotion::SetupMovementBounds
        
            typedef void ( ::UnitBaseLocomotion::*SetupMovementBounds_function_type )( ::UnitBaseMoveCommand & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "SetupMovementBounds"
                , SetupMovementBounds_function_type( &::UnitBaseLocomotion::SetupMovementBounds )
                , ( bp::arg("mv") ) );
        
        }
        { //::UnitBaseLocomotion::ShouldWalk
        
            typedef bool ( ::UnitBaseLocomotion::*ShouldWalk_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "ShouldWalk"
                , ShouldWalk_function_type( &::UnitBaseLocomotion::ShouldWalk ) );
        
        }
        { //::UnitBaseLocomotion::StartGravity
        
            typedef void ( ::UnitBaseLocomotion::*StartGravity_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "StartGravity"
                , StartGravity_function_type( &::UnitBaseLocomotion::StartGravity ) );
        
        }
        { //::UnitBaseLocomotion::StepMove
        
            typedef void ( ::UnitBaseLocomotion::*StepMove_function_type )( ::Vector &,::trace_t & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "StepMove"
                , StepMove_function_type( &::UnitBaseLocomotion::StepMove )
                , ( bp::arg("vecDestination"), bp::arg("trace") ) );
        
        }
        { //::UnitBaseLocomotion::TraceUnitBBox
        
            typedef void ( ::UnitBaseLocomotion::*TraceUnitBBox_function_type )( ::Vector const &,::Vector const &,unsigned int,int,::trace_t & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "TraceUnitBBox"
                , TraceUnitBBox_function_type( &::UnitBaseLocomotion::TraceUnitBBox )
                , ( bp::arg("start"), bp::arg("end"), bp::arg("fMask"), bp::arg("collisionGroup"), bp::arg("pm") ) );
        
        }
        { //::UnitBaseLocomotion::TryUnitMove
        
            typedef int ( ::UnitBaseLocomotion::*TryUnitMove_function_type )( ::Vector *,::trace_t * ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "TryUnitMove"
                , TryUnitMove_function_type( &::UnitBaseLocomotion::TryUnitMove )
                , ( bp::arg("pFirstDest")=bp::object(), bp::arg("pFirstTrace")=bp::object() ) );
        
        }
        { //::UnitBaseLocomotion::UnitTryMove
        
            typedef int ( ::UnitBaseLocomotion::*UnitTryMove_function_type )( ::trace_t * ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "UnitTryMove"
                , UnitTryMove_function_type( &::UnitBaseLocomotion::UnitTryMove )
                , ( bp::arg("steptrace") ) );
        
        }
        { //::UnitBaseLocomotion::WalkMove
        
            typedef void ( ::UnitBaseLocomotion::*WalkMove_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "WalkMove"
                , WalkMove_function_type( &::UnitBaseLocomotion::WalkMove ) );
        
        }
        UnitBaseLocomotion_exposer.def_readwrite( "acceleration", &UnitBaseLocomotion::acceleration );
        UnitBaseLocomotion_exposer.def_readwrite( "airacceleration", &UnitBaseLocomotion::airacceleration );
        UnitBaseLocomotion_exposer.def_readwrite( "blocker_hitpos", &UnitBaseLocomotion::blocker_hitpos );
        UnitBaseLocomotion_exposer.def_readwrite( "stepsize", &UnitBaseLocomotion::stepsize );
        UnitBaseLocomotion_exposer.def_readwrite( "stopspeed", &UnitBaseLocomotion::stopspeed );
        UnitBaseLocomotion_exposer.def_readwrite( "surfacefriction", &UnitBaseLocomotion::surfacefriction );
        UnitBaseLocomotion_exposer.def_readwrite( "unitsolidmask", &UnitBaseLocomotion::unitsolidmask );
        UnitBaseLocomotion_exposer.def_readwrite( "worldfriction", &UnitBaseLocomotion::worldfriction );
    }

    { //::UnitBaseAirLocomotion
        typedef bp::class_< UnitBaseAirLocomotion_wrapper, bp::bases< UnitBaseLocomotion > > UnitBaseAirLocomotion_exposer_t;
        UnitBaseAirLocomotion_exposer_t UnitBaseAirLocomotion_exposer = UnitBaseAirLocomotion_exposer_t( "UnitBaseAirLocomotion", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitBaseAirLocomotion_scope( UnitBaseAirLocomotion_exposer );
        bp::implicitly_convertible< bp::object, UnitBaseAirLocomotion >();
        { //::UnitBaseAirLocomotion::AirAccelerate
        
            typedef void ( ::UnitBaseAirLocomotion::*AirAccelerate_function_type )( ::Vector &,float,float ) ;
            
            UnitBaseAirLocomotion_exposer.def( 
                "AirAccelerate"
                , AirAccelerate_function_type( &::UnitBaseAirLocomotion::AirAccelerate )
                , ( bp::arg("wishdir"), bp::arg("wishspeed"), bp::arg("accel") ) );
        
        }
        { //::UnitBaseAirLocomotion::Friction
        
            typedef void ( ::UnitBaseAirLocomotion::*Friction_function_type )(  ) ;
            
            UnitBaseAirLocomotion_exposer.def( 
                "Friction"
                , Friction_function_type( &::UnitBaseAirLocomotion::Friction ) );
        
        }
        { //::UnitBaseAirLocomotion::FullAirMove
        
            typedef void ( ::UnitBaseAirLocomotion::*FullAirMove_function_type )(  ) ;
            
            UnitBaseAirLocomotion_exposer.def( 
                "FullAirMove"
                , FullAirMove_function_type( &::UnitBaseAirLocomotion::FullAirMove ) );
        
        }
        { //::UnitBaseAirLocomotion::Move
        
            typedef void ( ::UnitBaseAirLocomotion::*Move_function_type )( float,::UnitBaseMoveCommand & ) ;
            
            UnitBaseAirLocomotion_exposer.def( 
                "Move"
                , Move_function_type( &::UnitBaseAirLocomotion::Move )
                , ( bp::arg("interval"), bp::arg("mv") ) );
        
        }
        UnitBaseAirLocomotion_exposer.def_readwrite( "desiredheight", &UnitBaseAirLocomotion::m_fDesiredHeight );
        UnitBaseAirLocomotion_exposer.def_readwrite( "flynoiserate", &UnitBaseAirLocomotion::m_fFlyNoiseRate );
        UnitBaseAirLocomotion_exposer.def_readwrite( "flynoisez", &UnitBaseAirLocomotion::m_fFlyNoiseZ );
        { //::UnitBaseLocomotion::HandleJump
        
            typedef void ( ::UnitBaseLocomotion::*HandleJump_function_type )(  ) ;
            typedef void ( UnitBaseAirLocomotion_wrapper::*default_HandleJump_function_type )(  ) ;
            
            UnitBaseAirLocomotion_exposer.def( 
                "HandleJump"
                , HandleJump_function_type(&::UnitBaseLocomotion::HandleJump)
                , default_HandleJump_function_type(&UnitBaseAirLocomotion_wrapper::default_HandleJump) );
        
        }
    }

    { //::UnitBaseMoveCommand
        typedef bp::class_< UnitBaseMoveCommand > UnitBaseMoveCommand_exposer_t;
        UnitBaseMoveCommand_exposer_t UnitBaseMoveCommand_exposer = UnitBaseMoveCommand_exposer_t( "UnitBaseMoveCommand", bp::init< >() );
        bp::scope UnitBaseMoveCommand_scope( UnitBaseMoveCommand_exposer );
        { //::UnitBaseMoveCommand::Clear
        
            typedef void ( ::UnitBaseMoveCommand::*Clear_function_type )(  ) ;
            
            UnitBaseMoveCommand_exposer.def( 
                "Clear"
                , Clear_function_type( &::UnitBaseMoveCommand::Clear ) );
        
        }
        UnitBaseMoveCommand_exposer.def_readwrite( "blocker_dir", &UnitBaseMoveCommand::blocker_dir );
        UnitBaseMoveCommand_exposer.def_readwrite( "blocker_hitpos", &UnitBaseMoveCommand::blocker_hitpos );
        UnitBaseMoveCommand_exposer.def_readwrite( "forwardmove", &UnitBaseMoveCommand::forwardmove );
        UnitBaseMoveCommand_exposer.def_readwrite( "idealviewangles", &UnitBaseMoveCommand::idealviewangles );
        UnitBaseMoveCommand_exposer.def_readwrite( "interval", &UnitBaseMoveCommand::interval );
        UnitBaseMoveCommand_exposer.def_readwrite( "jump", &UnitBaseMoveCommand::jump );
        UnitBaseMoveCommand_exposer.def_readwrite( "maxspeed", &UnitBaseMoveCommand::maxspeed );
        UnitBaseMoveCommand_exposer.def_readwrite( "origin", &UnitBaseMoveCommand::origin );
        UnitBaseMoveCommand_exposer.def_readwrite( "outstepheight", &UnitBaseMoveCommand::outstepheight );
        UnitBaseMoveCommand_exposer.def_readwrite( "outwishvel", &UnitBaseMoveCommand::outwishvel );
        UnitBaseMoveCommand_exposer.def_readwrite( "sidemove", &UnitBaseMoveCommand::sidemove );
        UnitBaseMoveCommand_exposer.def_readwrite( "stopdistance", &UnitBaseMoveCommand::stopdistance );
        UnitBaseMoveCommand_exposer.def_readwrite( "totaldistance", &UnitBaseMoveCommand::totaldistance );
        UnitBaseMoveCommand_exposer.def_readwrite( "upmove", &UnitBaseMoveCommand::upmove );
        UnitBaseMoveCommand_exposer.def_readwrite( "velocity", &UnitBaseMoveCommand::velocity );
        UnitBaseMoveCommand_exposer.def_readwrite( "viewangles", &UnitBaseMoveCommand::viewangles );
        UnitBaseMoveCommand_exposer.def_readwrite( "yawspeed", &UnitBaseMoveCommand::yawspeed );
        { //property "blocker"[fget=::UnitBaseMoveCommand::GetBlocker]
        
            typedef ::C_BaseEntity * ( ::UnitBaseMoveCommand::*fget )(  ) ;
            
            UnitBaseMoveCommand_exposer.add_property( 
                "blocker"
                , bp::make_function( 
                      fget( &::UnitBaseMoveCommand::GetBlocker )
                    , bp::return_value_policy< bp::return_by_value >() )  );
        
        }
    }

    { //::UnitComputePathDirection
    
        typedef float ( *UnitComputePathDirection_function_type )( ::Vector const &,::Vector const &,::Vector & );
        
        bp::def( 
            "UnitComputePathDirection"
            , UnitComputePathDirection_function_type( &::UnitComputePathDirection )
            , ( bp::arg("start"), bp::arg("end"), bp::arg("pDirection") ) );
    
    }

    { //::Unit_ClampYaw
    
        typedef float ( *Unit_ClampYaw_function_type )( float,float,float,float );
        
        bp::def( 
            "Unit_ClampYaw"
            , Unit_ClampYaw_function_type( &::Unit_ClampYaw )
            , ( bp::arg("yawSpeedPerSec"), bp::arg("current"), bp::arg("target"), bp::arg("time") ) );
    
    }
}

#else

#include "boost/python.hpp"

#include "cbase.h"

#include "player.h"

#include "unit_expresser.h"

#include "unit_navigator.h"

#include "unit_airnavigator.h"

#include "unit_intention.h"

#include "unit_sense.h"

#include "unit_base.h"

#include "unit_base_shared.h"

#include "unit_component.h"

#include "unit_locomotion.h"

#include "unit_airlocomotion.h"

#include "unit_animstate.h"

#include "src_python.h"

#include "tier0/memdbgon.h"

namespace bp = boost::python;

struct BaseAnimEventHandler_wrapper : BaseAnimEventHandler, bp::wrapper< BaseAnimEventHandler > {

    BaseAnimEventHandler_wrapper(BaseAnimEventHandler const & arg )
    : BaseAnimEventHandler( arg )
      , bp::wrapper< BaseAnimEventHandler >(){
        // copy constructor
        
    }

    BaseAnimEventHandler_wrapper()
    : BaseAnimEventHandler()
      , bp::wrapper< BaseAnimEventHandler >(){
        // null constructor
        
    }

    virtual void HandleEvent( ::CUnitBase * pUnit, ::animevent_t * event ) {
        boost::python::override func_HandleEvent = this->get_override( "HandleEvent" );
        if( func_HandleEvent.ptr() != Py_None )
            try {
                func_HandleEvent( pUnit ? pUnit->GetPyHandle() : bp::object(), event );
            } catch(...) {
                PyErr_Print();
                this->BaseAnimEventHandler::HandleEvent( boost::python::ptr(pUnit), boost::python::ptr(event) );
            }
        else
            this->BaseAnimEventHandler::HandleEvent( boost::python::ptr(pUnit), boost::python::ptr(event) );
    }

    void default_HandleEvent( ::CUnitBase * pUnit, ::animevent_t * event ) {
        BaseAnimEventHandler::HandleEvent( boost::python::ptr(pUnit), boost::python::ptr(event) );
    }

};

struct CAI_Expresser_wrapper : CAI_Expresser, bp::wrapper< CAI_Expresser > {

    CAI_Expresser_wrapper(::CBaseFlex * pOuter=0 )
    : CAI_Expresser( boost::python::ptr(pOuter) )
      , bp::wrapper< CAI_Expresser >(){
        // constructor
    
    }

    void DumpHistories(  ){
        CAI_Expresser::DumpHistories(  );
    }

    virtual bool IsSpeaking(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsSpeaking: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsSpeaking(  ) of Class: CAI_Expresser\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsSpeaking = this->get_override( "IsSpeaking" );
        if( func_IsSpeaking.ptr() != Py_None )
            try {
                return func_IsSpeaking(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CAI_Expresser::IsSpeaking(  );
            }
        else
            return this->CAI_Expresser::IsSpeaking(  );
    }
    
    bool default_IsSpeaking(  ) {
        return CAI_Expresser::IsSpeaking( );
    }

    virtual void OnSpeechFinished(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSpeechFinished: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSpeechFinished(  ) of Class: CAI_Expresser\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSpeechFinished = this->get_override( "OnSpeechFinished" );
        if( func_OnSpeechFinished.ptr() != Py_None )
            try {
                func_OnSpeechFinished(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CAI_Expresser::OnSpeechFinished(  );
            }
        else
            this->CAI_Expresser::OnSpeechFinished(  );
    }
    
    void default_OnSpeechFinished(  ) {
        CAI_Expresser::OnSpeechFinished( );
    }

    bool SpeakAutoGeneratedScene( char const * soundname, float delay ){
        return CAI_Expresser::SpeakAutoGeneratedScene( soundname, delay );
    }

    virtual bool SpeakDispatchResponse( ::AIConcept_t & concept, ::AI_Response * response, ::ResponseRules::CriteriaSet * criteria, ::IRecipientFilter * filter=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SpeakDispatchResponse: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SpeakDispatchResponse( boost::ref(concept), boost::python::ptr(response), boost::python::ptr(criteria), boost::python::ptr(filter) ) of Class: CAI_Expresser\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SpeakDispatchResponse = this->get_override( "SpeakDispatchResponse" );
        if( func_SpeakDispatchResponse.ptr() != Py_None )
            try {
                return func_SpeakDispatchResponse( boost::ref(concept), boost::python::ptr(response), boost::python::ptr(criteria), boost::python::ptr(filter) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CAI_Expresser::SpeakDispatchResponse( boost::ref(concept), boost::python::ptr(response), boost::python::ptr(criteria), boost::python::ptr(filter) );
            }
        else
            return this->CAI_Expresser::SpeakDispatchResponse( boost::ref(concept), boost::python::ptr(response), boost::python::ptr(criteria), boost::python::ptr(filter) );
    }
    
    bool default_SpeakDispatchResponse( ::AIConcept_t & concept, ::AI_Response * response, ::ResponseRules::CriteriaSet * criteria, ::IRecipientFilter * filter=0 ) {
        return CAI_Expresser::SpeakDispatchResponse( boost::ref(concept), boost::python::ptr(response), boost::python::ptr(criteria), boost::python::ptr(filter) );
    }

    bool SpeakRawScene( char const * pszScene, float delay, ::AI_Response * response, ::IRecipientFilter * filter=0 ){
        return CAI_Expresser::SpeakRawScene( pszScene, delay, boost::python::ptr(response), boost::python::ptr(filter) );
    }

    virtual int SpeakRawSentence( char const * pszSentence, float delay, float volume=1.0e+0f, ::soundlevel_t soundlevel=::SNDLVL_80dB, ::CBaseEntity * pListener=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SpeakRawSentence: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SpeakRawSentence( pszSentence, delay, volume, soundlevel, boost::python::ptr(pListener) ) of Class: CAI_Expresser\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SpeakRawSentence = this->get_override( "SpeakRawSentence" );
        if( func_SpeakRawSentence.ptr() != Py_None )
            try {
                return func_SpeakRawSentence( pszSentence, delay, volume, soundlevel, boost::python::ptr(pListener) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CAI_Expresser::SpeakRawSentence( pszSentence, delay, volume, soundlevel, boost::python::ptr(pListener) );
            }
        else
            return this->CAI_Expresser::SpeakRawSentence( pszSentence, delay, volume, soundlevel, boost::python::ptr(pListener) );
    }
    
    int default_SpeakRawSentence( char const * pszSentence, float delay, float volume=1.0e+0f, ::soundlevel_t soundlevel=::SNDLVL_80dB, ::CBaseEntity * pListener=0 ) {
        return CAI_Expresser::SpeakRawSentence( pszSentence, delay, volume, soundlevel, boost::python::ptr(pListener) );
    }

};

struct TossGrenadeAnimEventHandler_wrapper : TossGrenadeAnimEventHandler, bp::wrapper< TossGrenadeAnimEventHandler > {

    TossGrenadeAnimEventHandler_wrapper(TossGrenadeAnimEventHandler const & arg )
    : TossGrenadeAnimEventHandler( arg )
      , bp::wrapper< TossGrenadeAnimEventHandler >(){
        // copy constructor
        
    }

    TossGrenadeAnimEventHandler_wrapper(char const * pEntityName, float fSpeed )
    : TossGrenadeAnimEventHandler( pEntityName, fSpeed )
      , bp::wrapper< TossGrenadeAnimEventHandler >(){
        // constructor
    
    }

    virtual void HandleEvent( ::CUnitBase * pUnit, ::animevent_t * event ) {
        boost::python::override func_HandleEvent = this->get_override( "HandleEvent" );
        if( func_HandleEvent.ptr() != Py_None )
            try {
                func_HandleEvent( pUnit ? pUnit->GetPyHandle() : bp::object(), event );
            } catch(...) {
                PyErr_Print();
                this->TossGrenadeAnimEventHandler::HandleEvent( boost::python::ptr(pUnit), boost::python::ptr(event) );
            }
        else
            this->TossGrenadeAnimEventHandler::HandleEvent( boost::python::ptr(pUnit), boost::python::ptr(event) );
    }

    void default_HandleEvent( ::CUnitBase * pUnit, ::animevent_t * event ) {
        TossGrenadeAnimEventHandler::HandleEvent( boost::python::ptr(pUnit), boost::python::ptr(event) );
    }

};

struct UnitBaseAnimState_wrapper : UnitBaseAnimState, bp::wrapper< UnitBaseAnimState > {

    UnitBaseAnimState_wrapper(UnitBaseAnimState const & arg )
    : UnitBaseAnimState( arg )
      , bp::wrapper< UnitBaseAnimState >(){
        // copy constructor
        
    }

    UnitBaseAnimState_wrapper(::boost::python::object outer )
    : UnitBaseAnimState( outer )
      , bp::wrapper< UnitBaseAnimState >(){
        // constructor
    
    }

    virtual int SelectWeightedSequence( ::Activity activity ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SelectWeightedSequence: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SelectWeightedSequence( activity ) of Class: UnitBaseAnimState\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SelectWeightedSequence = this->get_override( "SelectWeightedSequence" );
        if( func_SelectWeightedSequence.ptr() != Py_None )
            try {
                return func_SelectWeightedSequence( activity );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseAnimState::SelectWeightedSequence( activity );
            }
        else
            return this->UnitBaseAnimState::SelectWeightedSequence( activity );
    }
    
    int default_SelectWeightedSequence( ::Activity activity ) {
        return UnitBaseAnimState::SelectWeightedSequence( activity );
    }

    virtual void Update( float eyeYaw, float eyePitch ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Update: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Update( eyeYaw, eyePitch ) of Class: UnitBaseAnimState\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Update = this->get_override( "Update" );
        if( func_Update.ptr() != Py_None )
            try {
                func_Update( eyeYaw, eyePitch );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseAnimState::Update( eyeYaw, eyePitch );
            }
        else
            this->UnitBaseAnimState::Update( eyeYaw, eyePitch );
    }
    
    void default_Update( float eyeYaw, float eyePitch ) {
        UnitBaseAnimState::Update( eyeYaw, eyePitch );
    }

};

struct UnitAnimState_wrapper : UnitAnimState, bp::wrapper< UnitAnimState > {

    UnitAnimState_wrapper(::boost::python::object outer, ::UnitAnimConfig & animconfig )
    : UnitAnimState( outer, boost::ref(animconfig) )
      , bp::wrapper< UnitAnimState >(){
        // constructor
    
    }

    void ComputePoseParam_BodyPitch( ::CStudioHdr * pStudioHdr ){
        UnitAnimState::ComputePoseParam_BodyPitch( boost::python::ptr(pStudioHdr) );
    }

    void ComputePoseParam_BodyYaw(  ){
        UnitAnimState::ComputePoseParam_BodyYaw(  );
    }

    void ComputePoseParam_Lean(  ){
        UnitAnimState::ComputePoseParam_Lean(  );
    }

    void ComputePoseParam_MoveYaw( ::CStudioHdr * pStudioHdr ){
        UnitAnimState::ComputePoseParam_MoveYaw( boost::python::ptr(pStudioHdr) );
    }

    int ConvergeAngles( float goal, float maxrate, float maxgap, float dt, float & current ){
        return UnitAnimState::ConvergeAngles( goal, maxrate, maxgap, dt, current );
    }

    void EndSpecificActivity(  ){
        UnitAnimState::EndSpecificActivity(  );
    }

    ::Activity GetCurrentMainSequenceActivity(  ) const {
        return UnitAnimState::GetCurrentMainSequenceActivity(  );
    }

    float GetEyeYaw(  ) const {
        return UnitAnimState::GetEyeYaw(  );
    }

    void GetOuterAbsVelocity( ::Vector & vel ) const {
        UnitAnimState::GetOuterAbsVelocity( boost::ref(vel) );
    }

    float GetOuterXYSpeed(  ) const {
        return UnitAnimState::GetOuterXYSpeed(  );
    }

    virtual ::Activity OnEndSpecificActivity( ::Activity specificactivity ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnEndSpecificActivity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnEndSpecificActivity( specificactivity ) of Class: UnitAnimState\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnEndSpecificActivity = this->get_override( "OnEndSpecificActivity" );
        if( func_OnEndSpecificActivity.ptr() != Py_None )
            try {
                return func_OnEndSpecificActivity( specificactivity );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitAnimState::OnEndSpecificActivity( specificactivity );
            }
        else
            return this->UnitAnimState::OnEndSpecificActivity( specificactivity );
    }
    
    ::Activity default_OnEndSpecificActivity( ::Activity specificactivity ) {
        return UnitAnimState::OnEndSpecificActivity( specificactivity );
    }

    virtual void OnNewModel(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnNewModel: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnNewModel(  ) of Class: UnitAnimState\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnNewModel = this->get_override( "OnNewModel" );
        if( func_OnNewModel.ptr() != Py_None )
            try {
                func_OnNewModel(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitAnimState::OnNewModel(  );
            }
        else
            this->UnitAnimState::OnNewModel(  );
    }
    
    void default_OnNewModel(  ) {
        UnitAnimState::OnNewModel( );
    }

    void ResetGroundSpeed(  ){
        UnitAnimState::ResetGroundSpeed(  );
    }

    float TimeSinceLastAnimationStateClear(  ) const {
        return UnitAnimState::TimeSinceLastAnimationStateClear(  );
    }

    void UpdateLayerSequenceGeneric( int iLayer, bool & bEnabled, float & flCurCycle, int & iSequence, bool bWaitAtEnd, float fBlendIn=1.500000059604644775390625e-1f, float fBlendOut=1.500000059604644775390625e-1f, bool bMoveBlend=false, float fPlaybackRate=1.0e+0f, bool bUpdateCycle=true ){
        UnitAnimState::UpdateLayerSequenceGeneric( iLayer, bEnabled, flCurCycle, iSequence, bWaitAtEnd, fBlendIn, fBlendOut, bMoveBlend, fPlaybackRate, bUpdateCycle );
    }

    virtual int SelectWeightedSequence( ::Activity activity ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SelectWeightedSequence: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SelectWeightedSequence( activity ) of Class: UnitBaseAnimState\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SelectWeightedSequence = this->get_override( "SelectWeightedSequence" );
        if( func_SelectWeightedSequence.ptr() != Py_None )
            try {
                return func_SelectWeightedSequence( activity );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseAnimState::SelectWeightedSequence( activity );
            }
        else
            return this->UnitBaseAnimState::SelectWeightedSequence( activity );
    }
    
    int default_SelectWeightedSequence( ::Activity activity ) {
        return UnitBaseAnimState::SelectWeightedSequence( activity );
    }

};

struct UnitBaseLocomotion_wrapper : UnitBaseLocomotion, bp::wrapper< UnitBaseLocomotion > {

    UnitBaseLocomotion_wrapper(UnitBaseLocomotion const & arg )
    : UnitBaseLocomotion( arg )
      , bp::wrapper< UnitBaseLocomotion >(){
        // copy constructor
        
    }

    UnitBaseLocomotion_wrapper(::boost::python::object outer )
    : UnitBaseLocomotion( outer )
      , bp::wrapper< UnitBaseLocomotion >(){
        // constructor
    
    }

    virtual void HandleJump(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "HandleJump: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling HandleJump(  ) of Class: UnitBaseLocomotion\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_HandleJump = this->get_override( "HandleJump" );
        if( func_HandleJump.ptr() != Py_None )
            try {
                func_HandleJump(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseLocomotion::HandleJump(  );
            }
        else
            this->UnitBaseLocomotion::HandleJump(  );
    }
    
    void default_HandleJump(  ) {
        UnitBaseLocomotion::HandleJump( );
    }

};

struct UnitBaseAirLocomotion_wrapper : UnitBaseAirLocomotion, bp::wrapper< UnitBaseAirLocomotion > {

    UnitBaseAirLocomotion_wrapper(UnitBaseAirLocomotion const & arg )
    : UnitBaseAirLocomotion( arg )
      , bp::wrapper< UnitBaseAirLocomotion >(){
        // copy constructor
        
    }

    UnitBaseAirLocomotion_wrapper(::boost::python::object outer )
    : UnitBaseAirLocomotion( outer )
      , bp::wrapper< UnitBaseAirLocomotion >(){
        // constructor
    
    }

    virtual void HandleJump(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "HandleJump: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling HandleJump(  ) of Class: UnitBaseLocomotion\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_HandleJump = this->get_override( "HandleJump" );
        if( func_HandleJump.ptr() != Py_None )
            try {
                func_HandleJump(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseLocomotion::HandleJump(  );
            }
        else
            this->UnitBaseLocomotion::HandleJump(  );
    }
    
    void default_HandleJump(  ) {
        UnitBaseLocomotion::HandleJump( );
    }

};

struct UnitBaseNavigator_wrapper : UnitBaseNavigator, bp::wrapper< UnitBaseNavigator > {

    UnitBaseNavigator_wrapper(::boost::python::object outer )
    : UnitBaseNavigator( outer )
      , bp::wrapper< UnitBaseNavigator >(){
        // constructor
    
    }

    virtual void CalcMove( ::UnitBaseMoveCommand & MoveCommand, ::QAngle angles, float speed ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CalcMove: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CalcMove( boost::ref(MoveCommand), angles, speed ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CalcMove = this->get_override( "CalcMove" );
        if( func_CalcMove.ptr() != Py_None )
            try {
                func_CalcMove( boost::ref(MoveCommand), angles, speed );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::CalcMove( boost::ref(MoveCommand), angles, speed );
            }
        else
            this->UnitBaseNavigator::CalcMove( boost::ref(MoveCommand), angles, speed );
    }
    
    void default_CalcMove( ::UnitBaseMoveCommand & MoveCommand, ::QAngle angles, float speed ) {
        UnitBaseNavigator::CalcMove( boost::ref(MoveCommand), angles, speed );
    }

    virtual void DrawDebugInfo(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DrawDebugInfo: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DrawDebugInfo(  ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DrawDebugInfo = this->get_override( "DrawDebugInfo" );
        if( func_DrawDebugInfo.ptr() != Py_None )
            try {
                func_DrawDebugInfo(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::DrawDebugInfo(  );
            }
        else
            this->UnitBaseNavigator::DrawDebugInfo(  );
    }
    
    void default_DrawDebugInfo(  ) {
        UnitBaseNavigator::DrawDebugInfo( );
    }

    virtual void DrawDebugRouteOverlay(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DrawDebugRouteOverlay: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DrawDebugRouteOverlay(  ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DrawDebugRouteOverlay = this->get_override( "DrawDebugRouteOverlay" );
        if( func_DrawDebugRouteOverlay.ptr() != Py_None )
            try {
                func_DrawDebugRouteOverlay(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::DrawDebugRouteOverlay(  );
            }
        else
            this->UnitBaseNavigator::DrawDebugRouteOverlay(  );
    }
    
    void default_DrawDebugRouteOverlay(  ) {
        UnitBaseNavigator::DrawDebugRouteOverlay( );
    }

    virtual float GetGoalDistance(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGoalDistance: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGoalDistance(  ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGoalDistance = this->get_override( "GetGoalDistance" );
        if( func_GetGoalDistance.ptr() != Py_None )
            try {
                return func_GetGoalDistance(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::GetGoalDistance(  );
            }
        else
            return this->UnitBaseNavigator::GetGoalDistance(  );
    }
    
    float default_GetGoalDistance(  ) {
        return UnitBaseNavigator::GetGoalDistance( );
    }

    virtual void RegenerateConsiderList( ::Vector & vPathDir, ::CheckGoalStatus_t GoalStatus ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "RegenerateConsiderList: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling RegenerateConsiderList( boost::ref(vPathDir), GoalStatus ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_RegenerateConsiderList = this->get_override( "RegenerateConsiderList" );
        if( func_RegenerateConsiderList.ptr() != Py_None )
            try {
                func_RegenerateConsiderList( boost::ref(vPathDir), GoalStatus );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::RegenerateConsiderList( boost::ref(vPathDir), GoalStatus );
            }
        else
            this->UnitBaseNavigator::RegenerateConsiderList( boost::ref(vPathDir), GoalStatus );
    }
    
    void default_RegenerateConsiderList( ::Vector & vPathDir, ::CheckGoalStatus_t GoalStatus ) {
        UnitBaseNavigator::RegenerateConsiderList( boost::ref(vPathDir), GoalStatus );
    }

    virtual void Reset(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Reset: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Reset(  ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Reset = this->get_override( "Reset" );
        if( func_Reset.ptr() != Py_None )
            try {
                func_Reset(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::Reset(  );
            }
        else
            this->UnitBaseNavigator::Reset(  );
    }
    
    void default_Reset(  ) {
        UnitBaseNavigator::Reset( );
    }

    virtual bool SetGoal( ::Vector & destination, float goaltolerance=6.4e+1f, int goalflags=0, bool avoidenemies=true ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetGoal: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetGoal( boost::ref(destination), goaltolerance, goalflags, avoidenemies ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetGoal = this->get_override( "SetGoal" );
        if( func_SetGoal.ptr() != Py_None )
            try {
                return func_SetGoal( boost::ref(destination), goaltolerance, goalflags, avoidenemies );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::SetGoal( boost::ref(destination), goaltolerance, goalflags, avoidenemies );
            }
        else
            return this->UnitBaseNavigator::SetGoal( boost::ref(destination), goaltolerance, goalflags, avoidenemies );
    }
    
    bool default_SetGoal( ::Vector & destination, float goaltolerance=6.4e+1f, int goalflags=0, bool avoidenemies=true ) {
        return UnitBaseNavigator::SetGoal( boost::ref(destination), goaltolerance, goalflags, avoidenemies );
    }

    virtual bool SetGoalInRange( ::Vector & destination, float maxrange, float minrange=0.0f, float goaltolerance=0.0f, int goalflags=0, bool avoidenemies=true ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetGoalInRange: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetGoalInRange( boost::ref(destination), maxrange, minrange, goaltolerance, goalflags, avoidenemies ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetGoalInRange = this->get_override( "SetGoalInRange" );
        if( func_SetGoalInRange.ptr() != Py_None )
            try {
                return func_SetGoalInRange( boost::ref(destination), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::SetGoalInRange( boost::ref(destination), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
            }
        else
            return this->UnitBaseNavigator::SetGoalInRange( boost::ref(destination), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
    }
    
    bool default_SetGoalInRange( ::Vector & destination, float maxrange, float minrange=0.0f, float goaltolerance=0.0f, int goalflags=0, bool avoidenemies=true ) {
        return UnitBaseNavigator::SetGoalInRange( boost::ref(destination), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
    }

    virtual bool SetGoalTarget( ::CBaseEntity * pTarget, float goaltolerance=6.4e+1f, int goalflags=0, bool avoidenemies=true ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetGoalTarget: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetGoalTarget( boost::python::ptr(pTarget), goaltolerance, goalflags, avoidenemies ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetGoalTarget = this->get_override( "SetGoalTarget" );
        if( func_SetGoalTarget.ptr() != Py_None )
            try {
                return func_SetGoalTarget( boost::python::ptr(pTarget), goaltolerance, goalflags, avoidenemies );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::SetGoalTarget( boost::python::ptr(pTarget), goaltolerance, goalflags, avoidenemies );
            }
        else
            return this->UnitBaseNavigator::SetGoalTarget( boost::python::ptr(pTarget), goaltolerance, goalflags, avoidenemies );
    }
    
    bool default_SetGoalTarget( ::CBaseEntity * pTarget, float goaltolerance=6.4e+1f, int goalflags=0, bool avoidenemies=true ) {
        return UnitBaseNavigator::SetGoalTarget( boost::python::ptr(pTarget), goaltolerance, goalflags, avoidenemies );
    }

    virtual bool SetGoalTargetInRange( ::CBaseEntity * pTarget, float maxrange, float minrange=0.0f, float goaltolerance=0.0f, int goalflags=0, bool avoidenemies=true ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetGoalTargetInRange: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetGoalTargetInRange( boost::python::ptr(pTarget), maxrange, minrange, goaltolerance, goalflags, avoidenemies ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetGoalTargetInRange = this->get_override( "SetGoalTargetInRange" );
        if( func_SetGoalTargetInRange.ptr() != Py_None )
            try {
                return func_SetGoalTargetInRange( boost::python::ptr(pTarget), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::SetGoalTargetInRange( boost::python::ptr(pTarget), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
            }
        else
            return this->UnitBaseNavigator::SetGoalTargetInRange( boost::python::ptr(pTarget), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
    }
    
    bool default_SetGoalTargetInRange( ::CBaseEntity * pTarget, float maxrange, float minrange=0.0f, float goaltolerance=0.0f, int goalflags=0, bool avoidenemies=true ) {
        return UnitBaseNavigator::SetGoalTargetInRange( boost::python::ptr(pTarget), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
    }

    virtual void StopMoving(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "StopMoving: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling StopMoving(  ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_StopMoving = this->get_override( "StopMoving" );
        if( func_StopMoving.ptr() != Py_None )
            try {
                func_StopMoving(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::StopMoving(  );
            }
        else
            this->UnitBaseNavigator::StopMoving(  );
    }
    
    void default_StopMoving(  ) {
        UnitBaseNavigator::StopMoving( );
    }

    virtual bool TestRoute( ::Vector const & vStartPos, ::Vector const & vEndPos ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "TestRoute: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling TestRoute( boost::ref(vStartPos), boost::ref(vEndPos) ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_TestRoute = this->get_override( "TestRoute" );
        if( func_TestRoute.ptr() != Py_None )
            try {
                return func_TestRoute( boost::ref(vStartPos), boost::ref(vEndPos) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::TestRoute( boost::ref(vStartPos), boost::ref(vEndPos) );
            }
        else
            return this->UnitBaseNavigator::TestRoute( boost::ref(vStartPos), boost::ref(vEndPos) );
    }
    
    bool default_TestRoute( ::Vector const & vStartPos, ::Vector const & vEndPos ) {
        return UnitBaseNavigator::TestRoute( boost::ref(vStartPos), boost::ref(vEndPos) );
    }

    virtual void Update( ::UnitBaseMoveCommand & mv ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Update: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Update( boost::ref(mv) ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Update = this->get_override( "Update" );
        if( func_Update.ptr() != Py_None )
            try {
                func_Update( boost::ref(mv) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::Update( boost::ref(mv) );
            }
        else
            this->UnitBaseNavigator::Update( boost::ref(mv) );
    }
    
    void default_Update( ::UnitBaseMoveCommand & mv ) {
        UnitBaseNavigator::Update( boost::ref(mv) );
    }

    virtual void UpdateGoalInRange( float maxrange, float minrange=0.0f, ::UnitBasePath * path=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "UpdateGoalInRange: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling UpdateGoalInRange( maxrange, minrange, boost::python::ptr(path) ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_UpdateGoalInRange = this->get_override( "UpdateGoalInRange" );
        if( func_UpdateGoalInRange.ptr() != Py_None )
            try {
                func_UpdateGoalInRange( maxrange, minrange, boost::python::ptr(path) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::UpdateGoalInRange( maxrange, minrange, boost::python::ptr(path) );
            }
        else
            this->UnitBaseNavigator::UpdateGoalInRange( maxrange, minrange, boost::python::ptr(path) );
    }
    
    void default_UpdateGoalInRange( float maxrange, float minrange=0.0f, ::UnitBasePath * path=0 ) {
        UnitBaseNavigator::UpdateGoalInRange( maxrange, minrange, boost::python::ptr(path) );
    }

    virtual void UpdateGoalTarget( ::CBaseEntity * target, ::UnitBasePath * path=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "UpdateGoalTarget: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling UpdateGoalTarget( boost::python::ptr(target), boost::python::ptr(path) ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_UpdateGoalTarget = this->get_override( "UpdateGoalTarget" );
        if( func_UpdateGoalTarget.ptr() != Py_None )
            try {
                func_UpdateGoalTarget( boost::python::ptr(target), boost::python::ptr(path) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::UpdateGoalTarget( boost::python::ptr(target), boost::python::ptr(path) );
            }
        else
            this->UnitBaseNavigator::UpdateGoalTarget( boost::python::ptr(target), boost::python::ptr(path) );
    }
    
    void default_UpdateGoalTarget( ::CBaseEntity * target, ::UnitBasePath * path=0 ) {
        UnitBaseNavigator::UpdateGoalTarget( boost::python::ptr(target), boost::python::ptr(path) );
    }

    virtual void UpdateIdealAngles( ::UnitBaseMoveCommand & MoveCommand, ::Vector * pathdir=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "UpdateIdealAngles: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling UpdateIdealAngles( boost::ref(MoveCommand), boost::python::ptr(pathdir) ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_UpdateIdealAngles = this->get_override( "UpdateIdealAngles" );
        if( func_UpdateIdealAngles.ptr() != Py_None )
            try {
                func_UpdateIdealAngles( boost::ref(MoveCommand), boost::python::ptr(pathdir) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::UpdateIdealAngles( boost::ref(MoveCommand), boost::python::ptr(pathdir) );
            }
        else
            this->UnitBaseNavigator::UpdateIdealAngles( boost::ref(MoveCommand), boost::python::ptr(pathdir) );
    }
    
    void default_UpdateIdealAngles( ::UnitBaseMoveCommand & MoveCommand, ::Vector * pathdir=0 ) {
        UnitBaseNavigator::UpdateIdealAngles( boost::ref(MoveCommand), boost::python::ptr(pathdir) );
    }

};

struct UnitBaseAirNavigator_wrapper : UnitBaseAirNavigator, bp::wrapper< UnitBaseAirNavigator > {

    UnitBaseAirNavigator_wrapper(::boost::python::object outer )
    : UnitBaseAirNavigator( outer )
      , bp::wrapper< UnitBaseAirNavigator >(){
        // constructor
    
    }

    virtual bool TestRoute( ::Vector const & vStartPos, ::Vector const & vEndPos ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "TestRoute: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling TestRoute( boost::ref(vStartPos), boost::ref(vEndPos) ) of Class: UnitBaseAirNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_TestRoute = this->get_override( "TestRoute" );
        if( func_TestRoute.ptr() != Py_None )
            try {
                return func_TestRoute( boost::ref(vStartPos), boost::ref(vEndPos) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseAirNavigator::TestRoute( boost::ref(vStartPos), boost::ref(vEndPos) );
            }
        else
            return this->UnitBaseAirNavigator::TestRoute( boost::ref(vStartPos), boost::ref(vEndPos) );
    }
    
    bool default_TestRoute( ::Vector const & vStartPos, ::Vector const & vEndPos ) {
        return UnitBaseAirNavigator::TestRoute( boost::ref(vStartPos), boost::ref(vEndPos) );
    }

    virtual void CalcMove( ::UnitBaseMoveCommand & MoveCommand, ::QAngle angles, float speed ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CalcMove: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CalcMove( boost::ref(MoveCommand), angles, speed ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CalcMove = this->get_override( "CalcMove" );
        if( func_CalcMove.ptr() != Py_None )
            try {
                func_CalcMove( boost::ref(MoveCommand), angles, speed );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::CalcMove( boost::ref(MoveCommand), angles, speed );
            }
        else
            this->UnitBaseNavigator::CalcMove( boost::ref(MoveCommand), angles, speed );
    }
    
    void default_CalcMove( ::UnitBaseMoveCommand & MoveCommand, ::QAngle angles, float speed ) {
        UnitBaseNavigator::CalcMove( boost::ref(MoveCommand), angles, speed );
    }

    virtual void DrawDebugInfo(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DrawDebugInfo: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DrawDebugInfo(  ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DrawDebugInfo = this->get_override( "DrawDebugInfo" );
        if( func_DrawDebugInfo.ptr() != Py_None )
            try {
                func_DrawDebugInfo(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::DrawDebugInfo(  );
            }
        else
            this->UnitBaseNavigator::DrawDebugInfo(  );
    }
    
    void default_DrawDebugInfo(  ) {
        UnitBaseNavigator::DrawDebugInfo( );
    }

    virtual void DrawDebugRouteOverlay(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DrawDebugRouteOverlay: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DrawDebugRouteOverlay(  ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DrawDebugRouteOverlay = this->get_override( "DrawDebugRouteOverlay" );
        if( func_DrawDebugRouteOverlay.ptr() != Py_None )
            try {
                func_DrawDebugRouteOverlay(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::DrawDebugRouteOverlay(  );
            }
        else
            this->UnitBaseNavigator::DrawDebugRouteOverlay(  );
    }
    
    void default_DrawDebugRouteOverlay(  ) {
        UnitBaseNavigator::DrawDebugRouteOverlay( );
    }

    virtual float GetGoalDistance(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetGoalDistance: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetGoalDistance(  ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetGoalDistance = this->get_override( "GetGoalDistance" );
        if( func_GetGoalDistance.ptr() != Py_None )
            try {
                return func_GetGoalDistance(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::GetGoalDistance(  );
            }
        else
            return this->UnitBaseNavigator::GetGoalDistance(  );
    }
    
    float default_GetGoalDistance(  ) {
        return UnitBaseNavigator::GetGoalDistance( );
    }

    virtual void RegenerateConsiderList( ::Vector & vPathDir, ::CheckGoalStatus_t GoalStatus ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "RegenerateConsiderList: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling RegenerateConsiderList( boost::ref(vPathDir), GoalStatus ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_RegenerateConsiderList = this->get_override( "RegenerateConsiderList" );
        if( func_RegenerateConsiderList.ptr() != Py_None )
            try {
                func_RegenerateConsiderList( boost::ref(vPathDir), GoalStatus );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::RegenerateConsiderList( boost::ref(vPathDir), GoalStatus );
            }
        else
            this->UnitBaseNavigator::RegenerateConsiderList( boost::ref(vPathDir), GoalStatus );
    }
    
    void default_RegenerateConsiderList( ::Vector & vPathDir, ::CheckGoalStatus_t GoalStatus ) {
        UnitBaseNavigator::RegenerateConsiderList( boost::ref(vPathDir), GoalStatus );
    }

    virtual void Reset(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Reset: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Reset(  ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Reset = this->get_override( "Reset" );
        if( func_Reset.ptr() != Py_None )
            try {
                func_Reset(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::Reset(  );
            }
        else
            this->UnitBaseNavigator::Reset(  );
    }
    
    void default_Reset(  ) {
        UnitBaseNavigator::Reset( );
    }

    virtual bool SetGoal( ::Vector & destination, float goaltolerance=6.4e+1f, int goalflags=0, bool avoidenemies=true ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetGoal: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetGoal( boost::ref(destination), goaltolerance, goalflags, avoidenemies ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetGoal = this->get_override( "SetGoal" );
        if( func_SetGoal.ptr() != Py_None )
            try {
                return func_SetGoal( boost::ref(destination), goaltolerance, goalflags, avoidenemies );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::SetGoal( boost::ref(destination), goaltolerance, goalflags, avoidenemies );
            }
        else
            return this->UnitBaseNavigator::SetGoal( boost::ref(destination), goaltolerance, goalflags, avoidenemies );
    }
    
    bool default_SetGoal( ::Vector & destination, float goaltolerance=6.4e+1f, int goalflags=0, bool avoidenemies=true ) {
        return UnitBaseNavigator::SetGoal( boost::ref(destination), goaltolerance, goalflags, avoidenemies );
    }

    virtual bool SetGoalInRange( ::Vector & destination, float maxrange, float minrange=0.0f, float goaltolerance=0.0f, int goalflags=0, bool avoidenemies=true ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetGoalInRange: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetGoalInRange( boost::ref(destination), maxrange, minrange, goaltolerance, goalflags, avoidenemies ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetGoalInRange = this->get_override( "SetGoalInRange" );
        if( func_SetGoalInRange.ptr() != Py_None )
            try {
                return func_SetGoalInRange( boost::ref(destination), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::SetGoalInRange( boost::ref(destination), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
            }
        else
            return this->UnitBaseNavigator::SetGoalInRange( boost::ref(destination), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
    }
    
    bool default_SetGoalInRange( ::Vector & destination, float maxrange, float minrange=0.0f, float goaltolerance=0.0f, int goalflags=0, bool avoidenemies=true ) {
        return UnitBaseNavigator::SetGoalInRange( boost::ref(destination), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
    }

    virtual bool SetGoalTarget( ::CBaseEntity * pTarget, float goaltolerance=6.4e+1f, int goalflags=0, bool avoidenemies=true ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetGoalTarget: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetGoalTarget( boost::python::ptr(pTarget), goaltolerance, goalflags, avoidenemies ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetGoalTarget = this->get_override( "SetGoalTarget" );
        if( func_SetGoalTarget.ptr() != Py_None )
            try {
                return func_SetGoalTarget( boost::python::ptr(pTarget), goaltolerance, goalflags, avoidenemies );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::SetGoalTarget( boost::python::ptr(pTarget), goaltolerance, goalflags, avoidenemies );
            }
        else
            return this->UnitBaseNavigator::SetGoalTarget( boost::python::ptr(pTarget), goaltolerance, goalflags, avoidenemies );
    }
    
    bool default_SetGoalTarget( ::CBaseEntity * pTarget, float goaltolerance=6.4e+1f, int goalflags=0, bool avoidenemies=true ) {
        return UnitBaseNavigator::SetGoalTarget( boost::python::ptr(pTarget), goaltolerance, goalflags, avoidenemies );
    }

    virtual bool SetGoalTargetInRange( ::CBaseEntity * pTarget, float maxrange, float minrange=0.0f, float goaltolerance=0.0f, int goalflags=0, bool avoidenemies=true ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SetGoalTargetInRange: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SetGoalTargetInRange( boost::python::ptr(pTarget), maxrange, minrange, goaltolerance, goalflags, avoidenemies ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SetGoalTargetInRange = this->get_override( "SetGoalTargetInRange" );
        if( func_SetGoalTargetInRange.ptr() != Py_None )
            try {
                return func_SetGoalTargetInRange( boost::python::ptr(pTarget), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->UnitBaseNavigator::SetGoalTargetInRange( boost::python::ptr(pTarget), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
            }
        else
            return this->UnitBaseNavigator::SetGoalTargetInRange( boost::python::ptr(pTarget), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
    }
    
    bool default_SetGoalTargetInRange( ::CBaseEntity * pTarget, float maxrange, float minrange=0.0f, float goaltolerance=0.0f, int goalflags=0, bool avoidenemies=true ) {
        return UnitBaseNavigator::SetGoalTargetInRange( boost::python::ptr(pTarget), maxrange, minrange, goaltolerance, goalflags, avoidenemies );
    }

    virtual void StopMoving(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "StopMoving: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling StopMoving(  ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_StopMoving = this->get_override( "StopMoving" );
        if( func_StopMoving.ptr() != Py_None )
            try {
                func_StopMoving(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::StopMoving(  );
            }
        else
            this->UnitBaseNavigator::StopMoving(  );
    }
    
    void default_StopMoving(  ) {
        UnitBaseNavigator::StopMoving( );
    }

    virtual void UpdateGoalInRange( float maxrange, float minrange=0.0f, ::UnitBasePath * path=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "UpdateGoalInRange: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling UpdateGoalInRange( maxrange, minrange, boost::python::ptr(path) ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_UpdateGoalInRange = this->get_override( "UpdateGoalInRange" );
        if( func_UpdateGoalInRange.ptr() != Py_None )
            try {
                func_UpdateGoalInRange( maxrange, minrange, boost::python::ptr(path) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::UpdateGoalInRange( maxrange, minrange, boost::python::ptr(path) );
            }
        else
            this->UnitBaseNavigator::UpdateGoalInRange( maxrange, minrange, boost::python::ptr(path) );
    }
    
    void default_UpdateGoalInRange( float maxrange, float minrange=0.0f, ::UnitBasePath * path=0 ) {
        UnitBaseNavigator::UpdateGoalInRange( maxrange, minrange, boost::python::ptr(path) );
    }

    virtual void UpdateGoalTarget( ::CBaseEntity * target, ::UnitBasePath * path=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "UpdateGoalTarget: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling UpdateGoalTarget( boost::python::ptr(target), boost::python::ptr(path) ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_UpdateGoalTarget = this->get_override( "UpdateGoalTarget" );
        if( func_UpdateGoalTarget.ptr() != Py_None )
            try {
                func_UpdateGoalTarget( boost::python::ptr(target), boost::python::ptr(path) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::UpdateGoalTarget( boost::python::ptr(target), boost::python::ptr(path) );
            }
        else
            this->UnitBaseNavigator::UpdateGoalTarget( boost::python::ptr(target), boost::python::ptr(path) );
    }
    
    void default_UpdateGoalTarget( ::CBaseEntity * target, ::UnitBasePath * path=0 ) {
        UnitBaseNavigator::UpdateGoalTarget( boost::python::ptr(target), boost::python::ptr(path) );
    }

    virtual void UpdateIdealAngles( ::UnitBaseMoveCommand & MoveCommand, ::Vector * pathdir=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "UpdateIdealAngles: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling UpdateIdealAngles( boost::ref(MoveCommand), boost::python::ptr(pathdir) ) of Class: UnitBaseNavigator\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_UpdateIdealAngles = this->get_override( "UpdateIdealAngles" );
        if( func_UpdateIdealAngles.ptr() != Py_None )
            try {
                func_UpdateIdealAngles( boost::ref(MoveCommand), boost::python::ptr(pathdir) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->UnitBaseNavigator::UpdateIdealAngles( boost::ref(MoveCommand), boost::python::ptr(pathdir) );
            }
        else
            this->UnitBaseNavigator::UpdateIdealAngles( boost::ref(MoveCommand), boost::python::ptr(pathdir) );
    }
    
    void default_UpdateIdealAngles( ::UnitBaseMoveCommand & MoveCommand, ::Vector * pathdir=0 ) {
        UnitBaseNavigator::UpdateIdealAngles( boost::ref(MoveCommand), boost::python::ptr(pathdir) );
    }

};

struct UnitExpresser_wrapper : UnitExpresser, bp::wrapper< UnitExpresser > {

    UnitExpresser_wrapper(::boost::python::object outer )
    : UnitExpresser( outer )
      , bp::wrapper< UnitExpresser >(){
        // constructor
    
    }

    void DumpHistories(  ){
        CAI_Expresser::DumpHistories(  );
    }

    virtual bool IsSpeaking(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "IsSpeaking: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling IsSpeaking(  ) of Class: CAI_Expresser\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_IsSpeaking = this->get_override( "IsSpeaking" );
        if( func_IsSpeaking.ptr() != Py_None )
            try {
                return func_IsSpeaking(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CAI_Expresser::IsSpeaking(  );
            }
        else
            return this->CAI_Expresser::IsSpeaking(  );
    }
    
    bool default_IsSpeaking(  ) {
        return CAI_Expresser::IsSpeaking( );
    }

    virtual void OnSpeechFinished(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSpeechFinished: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSpeechFinished(  ) of Class: CAI_Expresser\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSpeechFinished = this->get_override( "OnSpeechFinished" );
        if( func_OnSpeechFinished.ptr() != Py_None )
            try {
                func_OnSpeechFinished(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CAI_Expresser::OnSpeechFinished(  );
            }
        else
            this->CAI_Expresser::OnSpeechFinished(  );
    }
    
    void default_OnSpeechFinished(  ) {
        CAI_Expresser::OnSpeechFinished( );
    }

    bool SpeakAutoGeneratedScene( char const * soundname, float delay ){
        return CAI_Expresser::SpeakAutoGeneratedScene( soundname, delay );
    }

    virtual bool SpeakDispatchResponse( ::AIConcept_t & concept, ::AI_Response * response, ::ResponseRules::CriteriaSet * criteria, ::IRecipientFilter * filter=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SpeakDispatchResponse: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SpeakDispatchResponse( boost::ref(concept), boost::python::ptr(response), boost::python::ptr(criteria), boost::python::ptr(filter) ) of Class: CAI_Expresser\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SpeakDispatchResponse = this->get_override( "SpeakDispatchResponse" );
        if( func_SpeakDispatchResponse.ptr() != Py_None )
            try {
                return func_SpeakDispatchResponse( boost::ref(concept), boost::python::ptr(response), boost::python::ptr(criteria), boost::python::ptr(filter) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CAI_Expresser::SpeakDispatchResponse( boost::ref(concept), boost::python::ptr(response), boost::python::ptr(criteria), boost::python::ptr(filter) );
            }
        else
            return this->CAI_Expresser::SpeakDispatchResponse( boost::ref(concept), boost::python::ptr(response), boost::python::ptr(criteria), boost::python::ptr(filter) );
    }
    
    bool default_SpeakDispatchResponse( ::AIConcept_t & concept, ::AI_Response * response, ::ResponseRules::CriteriaSet * criteria, ::IRecipientFilter * filter=0 ) {
        return CAI_Expresser::SpeakDispatchResponse( boost::ref(concept), boost::python::ptr(response), boost::python::ptr(criteria), boost::python::ptr(filter) );
    }

    bool SpeakRawScene( char const * pszScene, float delay, ::AI_Response * response, ::IRecipientFilter * filter=0 ){
        return CAI_Expresser::SpeakRawScene( pszScene, delay, boost::python::ptr(response), boost::python::ptr(filter) );
    }

    virtual int SpeakRawSentence( char const * pszSentence, float delay, float volume=1.0e+0f, ::soundlevel_t soundlevel=::SNDLVL_80dB, ::CBaseEntity * pListener=0 ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "SpeakRawSentence: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling SpeakRawSentence( pszSentence, delay, volume, soundlevel, boost::python::ptr(pListener) ) of Class: CAI_Expresser\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_SpeakRawSentence = this->get_override( "SpeakRawSentence" );
        if( func_SpeakRawSentence.ptr() != Py_None )
            try {
                return func_SpeakRawSentence( pszSentence, delay, volume, soundlevel, boost::python::ptr(pListener) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CAI_Expresser::SpeakRawSentence( pszSentence, delay, volume, soundlevel, boost::python::ptr(pListener) );
            }
        else
            return this->CAI_Expresser::SpeakRawSentence( pszSentence, delay, volume, soundlevel, boost::python::ptr(pListener) );
    }
    
    int default_SpeakRawSentence( char const * pszSentence, float delay, float volume=1.0e+0f, ::soundlevel_t soundlevel=::SNDLVL_80dB, ::CBaseEntity * pListener=0 ) {
        return CAI_Expresser::SpeakRawSentence( pszSentence, delay, volume, soundlevel, boost::python::ptr(pListener) );
    }

};

BOOST_PYTHON_MODULE(unit_helper){
    bp::docstring_options doc_options( true, true, false );

    bp::enum_< LegAnimType_t>("LegAnimType_t")
        .value("LEGANIM_9WAY", LEGANIM_9WAY)
        .value("LEGANIM_8WAY", LEGANIM_8WAY)
        .value("LEGANIM_GOLDSRC", LEGANIM_GOLDSRC)
        .export_values()
        ;

    bp::enum_< UnitGoalFlags>("UnitGoalFlags")
        .value("GF_NOCLEAR", GF_NOCLEAR)
        .value("GF_REQTARGETALIVE", GF_REQTARGETALIVE)
        .value("GF_USETARGETDIST", GF_USETARGETDIST)
        .value("GF_NOLOSREQUIRED", GF_NOLOSREQUIRED)
        .value("GF_REQUIREVISION", GF_REQUIREVISION)
        .value("GF_OWNERISTARGET", GF_OWNERISTARGET)
        .value("GF_DIRECTPATH", GF_DIRECTPATH)
        .export_values()
        ;

    { //::AnimEventMap
        typedef bp::class_< AnimEventMap, boost::noncopyable > AnimEventMap_exposer_t;
        AnimEventMap_exposer_t AnimEventMap_exposer = AnimEventMap_exposer_t( "AnimEventMap", bp::init< >() );
        bp::scope AnimEventMap_scope( AnimEventMap_exposer );
        AnimEventMap_exposer.def( bp::init< AnimEventMap & >(( bp::arg("animeventmap") )) );
        bp::implicitly_convertible< AnimEventMap &, AnimEventMap >();
        AnimEventMap_exposer.def( bp::init< AnimEventMap &, bp::dict >(( bp::arg("animeventmap"), bp::arg("d") )) );
        AnimEventMap_exposer.def( bp::init< bp::dict >(( bp::arg("d") )) );
        bp::implicitly_convertible< bp::dict, AnimEventMap >();
        { //::AnimEventMap::AddAnimEventHandlers
        
            typedef void ( ::AnimEventMap::*AddAnimEventHandlers_function_type )( ::boost::python::dict ) ;
            
            AnimEventMap_exposer.def( 
                "AddAnimEventHandlers"
                , AddAnimEventHandlers_function_type( &::AnimEventMap::AddAnimEventHandlers )
                , ( bp::arg("d") ) );
        
        }
        { //::AnimEventMap::SetAnimEventHandler
        
            typedef void ( ::AnimEventMap::*SetAnimEventHandler_function_type )( int,::boost::python::object ) ;
            
            AnimEventMap_exposer.def( 
                "SetAnimEventHandler"
                , SetAnimEventHandler_function_type( &::AnimEventMap::SetAnimEventHandler )
                , ( bp::arg("event"), bp::arg("handler") ) );
        
        }
    }

    bp::class_< BaseAnimEventHandler_wrapper >( "BaseAnimEventHandler" )    
        .def( 
            "HandleEvent"
            , (void ( ::BaseAnimEventHandler::* )( ::CUnitBase *,::animevent_t * ) )(&::BaseAnimEventHandler::HandleEvent)
            , (void ( BaseAnimEventHandler_wrapper::* )( ::CUnitBase *,::animevent_t * ) )(&BaseAnimEventHandler_wrapper::default_HandleEvent)
            , ( boost::python::arg("pUnit"), boost::python::arg("event") ) );

    bp::class_< ResponseRules::CriteriaSet >( "CriteriaSet", bp::init< >() )    
        .def( bp::init< ResponseRules::CriteriaSet const & >(( bp::arg("src") )) )    
        .def( bp::init< char const *, char const * >(( bp::arg("criteria"), bp::arg("value") )) )    
        .def( 
            "AppendCriteria"
            , (void ( ::ResponseRules::CriteriaSet::* )( ::CUtlSymbol,char const *,float ) )( &::ResponseRules::CriteriaSet::AppendCriteria )
            , ( bp::arg("criteria"), bp::arg("value")="", bp::arg("weight")=1.0e+0f ) )    
        .def( 
            "AppendCriteria"
            , (void ( ::ResponseRules::CriteriaSet::* )( char const *,char const *,float ) )( &::ResponseRules::CriteriaSet::AppendCriteria )
            , ( bp::arg("criteria"), bp::arg("value")="", bp::arg("weight")=1.0e+0f ) )    
        .def( 
            "AppendCriteria"
            , (void ( ::ResponseRules::CriteriaSet::* )( char const *,float,float ) )( &::ResponseRules::CriteriaSet::AppendCriteria )
            , ( bp::arg("criteria"), bp::arg("value"), bp::arg("weight")=1.0e+0f ) )    
        .def( 
            "ComputeCriteriaSymbol"
            , (::CUtlSymbol (*)( char const * ))( &::ResponseRules::CriteriaSet::ComputeCriteriaSymbol )
            , ( bp::arg("criteria") ) )    
        .def( 
            "Describe"
            , (void ( ::ResponseRules::CriteriaSet::* )(  ) const)( &::ResponseRules::CriteriaSet::Describe ) )    
        .def( 
            "EnsureCapacity"
            , (void ( ::ResponseRules::CriteriaSet::* )( int ) )( &::ResponseRules::CriteriaSet::EnsureCapacity )
            , ( bp::arg("num") ) )    
        .def( 
            "FindCriterionIndex"
            , (int ( ::ResponseRules::CriteriaSet::* )( ::CUtlSymbol ) const)( &::ResponseRules::CriteriaSet::FindCriterionIndex )
            , ( bp::arg("criteria") ) )    
        .def( 
            "FindCriterionIndex"
            , (int ( ::ResponseRules::CriteriaSet::* )( char const * ) const)( &::ResponseRules::CriteriaSet::FindCriterionIndex )
            , ( bp::arg("name") ) )    
        .def( 
            "GetCount"
            , (int ( ::ResponseRules::CriteriaSet::* )(  ) const)( &::ResponseRules::CriteriaSet::GetCount ) )    
        .def( 
            "GetName"
            , (char const * ( ::ResponseRules::CriteriaSet::* )( int ) const)( &::ResponseRules::CriteriaSet::GetName )
            , ( bp::arg("index") ) )    
        .def( 
            "GetNameSymbol"
            , (::CUtlSymbol ( ::ResponseRules::CriteriaSet::* )( int ) const)( &::ResponseRules::CriteriaSet::GetNameSymbol )
            , ( bp::arg("nIndex") ) )    
        .def( 
            "GetValue"
            , (char const * ( ::ResponseRules::CriteriaSet::* )( int ) const)( &::ResponseRules::CriteriaSet::GetValue )
            , ( bp::arg("index") ) )    
        .def( 
            "GetWeight"
            , (float ( ::ResponseRules::CriteriaSet::* )( int ) const)( &::ResponseRules::CriteriaSet::GetWeight )
            , ( bp::arg("index") ) )    
        .def( 
            "Head"
            , (int ( ::ResponseRules::CriteriaSet::* )(  ) const)( &::ResponseRules::CriteriaSet::Head ) )    
        .def( 
            "InterceptWorldSetContexts"
            , (int (*)( ::ResponseRules::CriteriaSet *,::ResponseRules::CriteriaSet * ))( &::ResponseRules::CriteriaSet::InterceptWorldSetContexts )
            , ( bp::arg("pFrom"), bp::arg("pSetOnWorld") ) )    
        .def( 
            "IsValidIndex"
            , (bool ( ::ResponseRules::CriteriaSet::* )( int ) const)( &::ResponseRules::CriteriaSet::IsValidIndex )
            , ( bp::arg("index") ) )    
        .def( 
            "Merge"
            , (void ( ::ResponseRules::CriteriaSet::* )( ::ResponseRules::CriteriaSet const * ) )( &::ResponseRules::CriteriaSet::Merge )
            , ( bp::arg("otherCriteria") ) )    
        .def( 
            "Merge"
            , (void ( ::ResponseRules::CriteriaSet::* )( char const * ) )( &::ResponseRules::CriteriaSet::Merge )
            , ( bp::arg("modifiers") ) )    
        .def( 
            "Next"
            , (int ( ::ResponseRules::CriteriaSet::* )( int ) const)( &::ResponseRules::CriteriaSet::Next )
            , ( bp::arg("i") ) )    
        .def( 
            "OverrideOnAppend"
            , (void ( ::ResponseRules::CriteriaSet::* )( bool ) )( &::ResponseRules::CriteriaSet::OverrideOnAppend )
            , ( bp::arg("bOverride") ) )    
        .def( 
            "RemoveCriteria"
            , (void ( ::ResponseRules::CriteriaSet::* )( char const * ) )( &::ResponseRules::CriteriaSet::RemoveCriteria )
            , ( bp::arg("criteria") ) )    
        .def( 
            "Reset"
            , (void ( ::ResponseRules::CriteriaSet::* )(  ) )( &::ResponseRules::CriteriaSet::Reset ) )    
        .def( 
            "SymbolToStr"
            , (char const * (*)( ::CUtlSymbol const & ))( &::ResponseRules::CriteriaSet::SymbolToStr )
            , ( bp::arg("symbol") ) )    
        .def( 
            "WriteToEntity"
            , (void ( ::ResponseRules::CriteriaSet::* )( ::CBaseEntity * ) )( &::ResponseRules::CriteriaSet::WriteToEntity )
            , ( bp::arg("pEntity") ) )    
        .def_readonly( "kAPPLYTOWORLDPREFIX", ResponseRules::CriteriaSet::kAPPLYTOWORLDPREFIX )    
        .staticmethod( "ComputeCriteriaSymbol" )    
        .staticmethod( "InterceptWorldSetContexts" )    
        .staticmethod( "SymbolToStr" );

    { //::CAI_Expresser
        typedef bp::class_< CAI_Expresser_wrapper, boost::noncopyable > CAI_Expresser_exposer_t;
        CAI_Expresser_exposer_t CAI_Expresser_exposer = CAI_Expresser_exposer_t( "CAI_Expresser", bp::init< bp::optional< CBaseFlex * > >(( bp::arg("pOuter")=bp::object() )) );
        bp::scope CAI_Expresser_scope( CAI_Expresser_exposer );
        bp::implicitly_convertible< CBaseFlex *, CAI_Expresser >();
        { //::CAI_Expresser::BlockSpeechUntil
        
            typedef void ( ::CAI_Expresser::*BlockSpeechUntil_function_type )( float ) ;
            
            CAI_Expresser_exposer.def( 
                "BlockSpeechUntil"
                , BlockSpeechUntil_function_type( &::CAI_Expresser::BlockSpeechUntil )
                , ( bp::arg("time") ) );
        
        }
        { //::CAI_Expresser::CanSpeak
        
            typedef bool ( ::CAI_Expresser::*CanSpeak_function_type )(  ) ;
            
            CAI_Expresser_exposer.def( 
                "CanSpeak"
                , CanSpeak_function_type( &::CAI_Expresser::CanSpeak ) );
        
        }
        { //::CAI_Expresser::CanSpeakAfterMyself
        
            typedef bool ( ::CAI_Expresser::*CanSpeakAfterMyself_function_type )(  ) ;
            
            CAI_Expresser_exposer.def( 
                "CanSpeakAfterMyself"
                , CanSpeakAfterMyself_function_type( &::CAI_Expresser::CanSpeakAfterMyself ) );
        
        }
        { //::CAI_Expresser::CanSpeakConcept
        
            typedef bool ( ::CAI_Expresser::*CanSpeakConcept_function_type )( ::AIConcept_t ) ;
            
            CAI_Expresser_exposer.def( 
                "CanSpeakConcept"
                , CanSpeakConcept_function_type( &::CAI_Expresser::CanSpeakConcept )
                , ( bp::arg("concept") ) );
        
        }
        { //::CAI_Expresser::ClearSpokeConcept
        
            typedef void ( ::CAI_Expresser::*ClearSpokeConcept_function_type )( ::AIConcept_t ) ;
            
            CAI_Expresser_exposer.def( 
                "ClearSpokeConcept"
                , ClearSpokeConcept_function_type( &::CAI_Expresser::ClearSpokeConcept )
                , ( bp::arg("concept") ) );
        
        }
        { //::CAI_Expresser::Connect
        
            typedef bool ( ::CAI_Expresser::*Connect_function_type )( ::CAI_ExpresserSink * ) ;
            
            CAI_Expresser_exposer.def( 
                "Connect"
                , Connect_function_type( &::CAI_Expresser::Connect )
                , ( bp::arg("pSink") ) );
        
        }
        { //::CAI_Expresser::Disconnect
        
            typedef bool ( ::CAI_Expresser::*Disconnect_function_type )( ::CAI_ExpresserSink * ) ;
            
            CAI_Expresser_exposer.def( 
                "Disconnect"
                , Disconnect_function_type( &::CAI_Expresser::Disconnect )
                , ( bp::arg("pSink") ) );
        
        }
        { //::CAI_Expresser::DumpHistories
        
            typedef void ( CAI_Expresser_wrapper::*DumpHistories_function_type )(  ) ;
            
            CAI_Expresser_exposer.def( 
                "DumpHistories"
                , DumpHistories_function_type( &CAI_Expresser_wrapper::DumpHistories ) );
        
        }
        { //::CAI_Expresser::FindResponse
        
            typedef bool ( ::CAI_Expresser::*FindResponse_function_type )( ::AI_Response &,::AIConcept_t &,::ResponseRules::CriteriaSet * ) ;
            
            CAI_Expresser_exposer.def( 
                "FindResponse"
                , FindResponse_function_type( &::CAI_Expresser::FindResponse )
                , ( bp::arg("outResponse"), bp::arg("concept"), bp::arg("modifiers")=bp::object() ) );
        
        }
        { //::CAI_Expresser::FireEntIOFromResponse
        
            typedef bool ( *FireEntIOFromResponse_function_type )( char *,::CBaseEntity * );
            
            CAI_Expresser_exposer.def( 
                "FireEntIOFromResponse"
                , FireEntIOFromResponse_function_type( &::CAI_Expresser::FireEntIOFromResponse )
                , ( bp::arg("response"), bp::arg("pInitiator") ) );
        
        }
        { //::CAI_Expresser::ForceNotSpeaking
        
            typedef void ( ::CAI_Expresser::*ForceNotSpeaking_function_type )(  ) ;
            
            CAI_Expresser_exposer.def( 
                "ForceNotSpeaking"
                , ForceNotSpeaking_function_type( &::CAI_Expresser::ForceNotSpeaking ) );
        
        }
        { //::CAI_Expresser::GatherCriteria
        
            typedef void ( ::CAI_Expresser::*GatherCriteria_function_type )( ::ResponseRules::CriteriaSet *,::AIConcept_t const &,char const * ) ;
            
            CAI_Expresser_exposer.def( 
                "GatherCriteria"
                , GatherCriteria_function_type( &::CAI_Expresser::GatherCriteria )
                , ( bp::arg("outputCritera"), bp::arg("concept"), bp::arg("modifiers") ) );
        
        }
        { //::CAI_Expresser::GetResponseDuration
        
            typedef float ( ::CAI_Expresser::*GetResponseDuration_function_type )( ::AI_Response * ) ;
            
            CAI_Expresser_exposer.def( 
                "GetResponseDuration"
                , GetResponseDuration_function_type( &::CAI_Expresser::GetResponseDuration )
                , ( bp::arg("response") ) );
        
        }
        { //::CAI_Expresser::GetSemaphoreAvailableTime
        
            typedef float ( ::CAI_Expresser::*GetSemaphoreAvailableTime_function_type )( ::CBaseEntity * ) ;
            
            CAI_Expresser_exposer.def( 
                "GetSemaphoreAvailableTime"
                , GetSemaphoreAvailableTime_function_type( &::CAI_Expresser::GetSemaphoreAvailableTime )
                , ( bp::arg("pTalker") ) );
        
        }
        { //::CAI_Expresser::GetTimeSpeechComplete
        
            typedef float ( ::CAI_Expresser::*GetTimeSpeechComplete_function_type )(  ) const;
            
            CAI_Expresser_exposer.def( 
                "GetTimeSpeechComplete"
                , GetTimeSpeechComplete_function_type( &::CAI_Expresser::GetTimeSpeechComplete ) );
        
        }
        { //::CAI_Expresser::GetTimeSpokeConcept
        
            typedef float ( ::CAI_Expresser::*GetTimeSpokeConcept_function_type )( ::AIConcept_t ) ;
            
            CAI_Expresser_exposer.def( 
                "GetTimeSpokeConcept"
                , GetTimeSpokeConcept_function_type( &::CAI_Expresser::GetTimeSpokeConcept )
                , ( bp::arg("concept") ) );
        
        }
        { //::CAI_Expresser::GetVoicePitch
        
            typedef int ( ::CAI_Expresser::*GetVoicePitch_function_type )(  ) const;
            
            CAI_Expresser_exposer.def( 
                "GetVoicePitch"
                , GetVoicePitch_function_type( &::CAI_Expresser::GetVoicePitch ) );
        
        }
        { //::CAI_Expresser::IsSpeaking
        
            typedef bool ( ::CAI_Expresser::*IsSpeaking_function_type )(  ) ;
            typedef bool ( CAI_Expresser_wrapper::*default_IsSpeaking_function_type )(  ) ;
            
            CAI_Expresser_exposer.def( 
                "IsSpeaking"
                , IsSpeaking_function_type(&::CAI_Expresser::IsSpeaking)
                , default_IsSpeaking_function_type(&CAI_Expresser_wrapper::default_IsSpeaking) );
        
        }
        { //::CAI_Expresser::IsSpeechGloballySuppressed
        
            typedef bool ( *IsSpeechGloballySuppressed_function_type )(  );
            
            CAI_Expresser_exposer.def( 
                "IsSpeechGloballySuppressed"
                , IsSpeechGloballySuppressed_function_type( &::CAI_Expresser::IsSpeechGloballySuppressed ) );
        
        }
        { //::CAI_Expresser::NoteSpeaking
        
            typedef void ( ::CAI_Expresser::*NoteSpeaking_function_type )( float,float ) ;
            
            CAI_Expresser_exposer.def( 
                "NoteSpeaking"
                , NoteSpeaking_function_type( &::CAI_Expresser::NoteSpeaking )
                , ( bp::arg("duration"), bp::arg("delay")=0 ) );
        
        }
        { //::CAI_Expresser::OnSpeechFinished
        
            typedef void ( ::CAI_Expresser::*OnSpeechFinished_function_type )(  ) ;
            typedef void ( CAI_Expresser_wrapper::*default_OnSpeechFinished_function_type )(  ) ;
            
            CAI_Expresser_exposer.def( 
                "OnSpeechFinished"
                , OnSpeechFinished_function_type(&::CAI_Expresser::OnSpeechFinished)
                , default_OnSpeechFinished_function_type(&CAI_Expresser_wrapper::default_OnSpeechFinished) );
        
        }
        { //::CAI_Expresser::SemaphoreIsAvailable
        
            typedef bool ( ::CAI_Expresser::*SemaphoreIsAvailable_function_type )( ::CBaseEntity * ) ;
            
            CAI_Expresser_exposer.def( 
                "SemaphoreIsAvailable"
                , SemaphoreIsAvailable_function_type( &::CAI_Expresser::SemaphoreIsAvailable )
                , ( bp::arg("pTalker") ) );
        
        }
        { //::CAI_Expresser::SetOuter
        
            typedef void ( ::CAI_Expresser::*SetOuter_function_type )( ::CBaseFlex * ) ;
            
            CAI_Expresser_exposer.def( 
                "SetOuter"
                , SetOuter_function_type( &::CAI_Expresser::SetOuter )
                , ( bp::arg("pOuter") ) );
        
        }
        { //::CAI_Expresser::SetSpokeConcept
        
            typedef void ( ::CAI_Expresser::*SetSpokeConcept_function_type )( ::AIConcept_t,::AI_Response *,bool ) ;
            
            CAI_Expresser_exposer.def( 
                "SetSpokeConcept"
                , SetSpokeConcept_function_type( &::CAI_Expresser::SetSpokeConcept )
                , ( bp::arg("concept"), bp::arg("response"), bp::arg("bCallback")=(bool)(true) ) );
        
        }
        { //::CAI_Expresser::SetVoicePitch
        
            typedef void ( ::CAI_Expresser::*SetVoicePitch_function_type )( int ) ;
            
            CAI_Expresser_exposer.def( 
                "SetVoicePitch"
                , SetVoicePitch_function_type( &::CAI_Expresser::SetVoicePitch )
                , ( bp::arg("voicePitch") ) );
        
        }
        { //::CAI_Expresser::Speak
        
            typedef bool ( ::CAI_Expresser::*Speak_function_type )( ::AIConcept_t &,char const *,char *,::size_t,::IRecipientFilter * ) ;
            
            CAI_Expresser_exposer.def( 
                "Speak"
                , Speak_function_type( &::CAI_Expresser::Speak )
                , ( bp::arg("concept"), bp::arg("modifiers")=bp::object(), bp::arg("pszOutResponseChosen")=bp::object(), bp::arg("bufsize")=(::size_t)(0), bp::arg("filter")=bp::object() ) );
        
        }
        { //::CAI_Expresser::Speak
        
            typedef bool ( ::CAI_Expresser::*Speak_function_type )( ::AIConcept_t &,::ResponseRules::CriteriaSet *,char *,::size_t,::IRecipientFilter * ) ;
            
            CAI_Expresser_exposer.def( 
                "Speak"
                , Speak_function_type( &::CAI_Expresser::Speak )
                , ( bp::arg("concept"), bp::arg("criteria"), bp::arg("pszOutResponseChosen")=bp::object(), bp::arg("bufsize")=(::size_t)(0), bp::arg("filter")=bp::object() ) );
        
        }
        { //::CAI_Expresser::SpeakAutoGeneratedScene
        
            typedef bool ( CAI_Expresser_wrapper::*SpeakAutoGeneratedScene_function_type )( char const *,float ) ;
            
            CAI_Expresser_exposer.def( 
                "SpeakAutoGeneratedScene"
                , SpeakAutoGeneratedScene_function_type( &CAI_Expresser_wrapper::SpeakAutoGeneratedScene )
                , ( bp::arg("soundname"), bp::arg("delay") ) );
        
        }
        { //::CAI_Expresser::SpeakDispatchResponse
        
            typedef bool ( ::CAI_Expresser::*SpeakDispatchResponse_function_type )( ::AIConcept_t &,::AI_Response *,::ResponseRules::CriteriaSet *,::IRecipientFilter * ) ;
            typedef bool ( CAI_Expresser_wrapper::*default_SpeakDispatchResponse_function_type )( ::AIConcept_t &,::AI_Response *,::ResponseRules::CriteriaSet *,::IRecipientFilter * ) ;
            
            CAI_Expresser_exposer.def( 
                "SpeakDispatchResponse"
                , SpeakDispatchResponse_function_type(&::CAI_Expresser::SpeakDispatchResponse)
                , default_SpeakDispatchResponse_function_type(&CAI_Expresser_wrapper::default_SpeakDispatchResponse)
                , ( bp::arg("concept"), bp::arg("response"), bp::arg("criteria"), bp::arg("filter")=bp::object() ) );
        
        }
        { //::CAI_Expresser::SpeakRawScene
        
            typedef bool ( CAI_Expresser_wrapper::*SpeakRawScene_function_type )( char const *,float,::AI_Response *,::IRecipientFilter * ) ;
            
            CAI_Expresser_exposer.def( 
                "SpeakRawScene"
                , SpeakRawScene_function_type( &CAI_Expresser_wrapper::SpeakRawScene )
                , ( bp::arg("pszScene"), bp::arg("delay"), bp::arg("response"), bp::arg("filter")=bp::object() ) );
        
        }
        { //::CAI_Expresser::SpeakRawSentence
        
            typedef int ( ::CAI_Expresser::*SpeakRawSentence_function_type )( char const *,float,float,::soundlevel_t,::CBaseEntity * ) ;
            typedef int ( CAI_Expresser_wrapper::*default_SpeakRawSentence_function_type )( char const *,float,float,::soundlevel_t,::CBaseEntity * ) ;
            
            CAI_Expresser_exposer.def( 
                "SpeakRawSentence"
                , SpeakRawSentence_function_type(&::CAI_Expresser::SpeakRawSentence)
                , default_SpeakRawSentence_function_type(&CAI_Expresser_wrapper::default_SpeakRawSentence)
                , ( bp::arg("pszSentence"), bp::arg("delay"), bp::arg("volume")=1.0e+0f, bp::arg("soundlevel")=::SNDLVL_80dB, bp::arg("pListener")=bp::object() ) );
        
        }
        { //::CAI_Expresser::SpokeConcept
        
            typedef bool ( ::CAI_Expresser::*SpokeConcept_function_type )( ::AIConcept_t ) ;
            
            CAI_Expresser_exposer.def( 
                "SpokeConcept"
                , SpokeConcept_function_type( &::CAI_Expresser::SpokeConcept )
                , ( bp::arg("concept") ) );
        
        }
        { //::CAI_Expresser::TestAllResponses
        
            typedef void ( ::CAI_Expresser::*TestAllResponses_function_type )(  ) ;
            
            CAI_Expresser_exposer.def( 
                "TestAllResponses"
                , TestAllResponses_function_type( &::CAI_Expresser::TestAllResponses ) );
        
        }
        CAI_Expresser_exposer.staticmethod( "FireEntIOFromResponse" );
        CAI_Expresser_exposer.staticmethod( "IsSpeechGloballySuppressed" );
    }

    { //::EmitSoundAnimEventHandler
        typedef bp::class_< EmitSoundAnimEventHandler, bp::bases< BaseAnimEventHandler > > EmitSoundAnimEventHandler_exposer_t;
        EmitSoundAnimEventHandler_exposer_t EmitSoundAnimEventHandler_exposer = EmitSoundAnimEventHandler_exposer_t( "EmitSoundAnimEventHandler", bp::init< char const * >(( bp::arg("soundscript") )) );
        bp::scope EmitSoundAnimEventHandler_scope( EmitSoundAnimEventHandler_exposer );
        bp::implicitly_convertible< char const *, EmitSoundAnimEventHandler >();
        { //::EmitSoundAnimEventHandler::HandleEvent
        
            typedef void ( ::EmitSoundAnimEventHandler::*HandleEvent_function_type )( ::CUnitBase *,::animevent_t * ) ;
            
            EmitSoundAnimEventHandler_exposer.def( 
                "HandleEvent"
                , HandleEvent_function_type( &::EmitSoundAnimEventHandler::HandleEvent )
                , ( bp::arg("pUnit"), bp::arg("event") ) );
        
        }
    }

    bp::class_< TossGrenadeAnimEventHandler_wrapper, bp::bases< BaseAnimEventHandler > >( "TossGrenadeAnimEventHandler", bp::init< char const *, float >(( bp::arg("pEntityName"), bp::arg("fSpeed") )) )    
        .def( 
            "GetTossVector"
            , (bool ( ::TossGrenadeAnimEventHandler::* )( ::CUnitBase *,::Vector const &,::Vector const &,int,::Vector * ) )( &::TossGrenadeAnimEventHandler::GetTossVector )
            , ( bp::arg("pUnit"), bp::arg("vecStartPos"), bp::arg("vecTarget"), bp::arg("iCollisionGroup"), bp::arg("vecOut") ) )    
        .def( 
            "TossGrenade"
            , (::CBaseEntity * ( ::TossGrenadeAnimEventHandler::* )( ::CUnitBase *,::Vector &,::Vector &,int ) )( &::TossGrenadeAnimEventHandler::TossGrenade )
            , ( bp::arg("pUnit"), bp::arg("vecStartPos"), bp::arg("vecTarget"), bp::arg("iCollisionGroup") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "HandleEvent"
            , (void ( ::TossGrenadeAnimEventHandler::* )( ::CUnitBase *,::animevent_t * ) )(&::TossGrenadeAnimEventHandler::HandleEvent)
            , (void ( TossGrenadeAnimEventHandler_wrapper::* )( ::CUnitBase *,::animevent_t * ) )(&TossGrenadeAnimEventHandler_wrapper::default_HandleEvent)
            , ( boost::python::arg("pUnit"), boost::python::arg("event") ) );

    { //::TranslateActivityMap
        typedef bp::class_< TranslateActivityMap, boost::noncopyable > TranslateActivityMap_exposer_t;
        TranslateActivityMap_exposer_t TranslateActivityMap_exposer = TranslateActivityMap_exposer_t( "TranslateActivityMap", bp::init< >() );
        bp::scope TranslateActivityMap_scope( TranslateActivityMap_exposer );
        TranslateActivityMap_exposer.def( bp::init< TranslateActivityMap & >(( bp::arg("activitymap") )) );
        bp::implicitly_convertible< TranslateActivityMap &, TranslateActivityMap >();
        TranslateActivityMap_exposer.def( bp::init< bp::dict >(( bp::arg("d") )) );
        bp::implicitly_convertible< bp::dict, TranslateActivityMap >();
        TranslateActivityMap_exposer.def( bp::init< TranslateActivityMap &, bp::dict >(( bp::arg("activitymap"), bp::arg("d") )) );
        { //::TranslateActivityMap::AddTranslation
        
            typedef void ( ::TranslateActivityMap::*AddTranslation_function_type )( ::Activity,::Activity ) ;
            
            TranslateActivityMap_exposer.def( 
                "AddTranslation"
                , AddTranslation_function_type( &::TranslateActivityMap::AddTranslation )
                , ( bp::arg("act"), bp::arg("act_translated") ) );
        
        }
        { //::TranslateActivityMap::AddTranslations
        
            typedef void ( ::TranslateActivityMap::*AddTranslations_function_type )( ::boost::python::dict ) ;
            
            TranslateActivityMap_exposer.def( 
                "AddTranslations"
                , AddTranslations_function_type( &::TranslateActivityMap::AddTranslations )
                , ( bp::arg("d") ) );
        
        }
        { //::TranslateActivityMap::DebugPrint
        
            typedef void ( ::TranslateActivityMap::*DebugPrint_function_type )(  ) ;
            
            TranslateActivityMap_exposer.def( 
                "DebugPrint"
                , DebugPrint_function_type( &::TranslateActivityMap::DebugPrint ) );
        
        }
    }

    { //::UnitAnimConfig
        typedef bp::class_< UnitAnimConfig > UnitAnimConfig_exposer_t;
        UnitAnimConfig_exposer_t UnitAnimConfig_exposer = UnitAnimConfig_exposer_t( "UnitAnimConfig", bp::init< >() );
        bp::scope UnitAnimConfig_scope( UnitAnimConfig_exposer );
        UnitAnimConfig_exposer.def( bp::init< float, bp::optional< bool, LegAnimType_t, bool, bool > >(( bp::arg("maxbodyyawdegrees"), bp::arg("bodyyawnormalized")=(bool)(false), bp::arg("leganimtype")=::LEGANIM_8WAY, bp::arg("useaimsequences")=(bool)(false), bp::arg("invertposeparameters")=(bool)(false) )) );
        bp::implicitly_convertible< float, UnitAnimConfig >();
        UnitAnimConfig_exposer.def_readwrite( "leganimtype", &UnitAnimConfig::m_LegAnimType );
        UnitAnimConfig_exposer.def_readwrite( "bodyyawnormalized", &UnitAnimConfig::m_bBodyYawNormalized );
        UnitAnimConfig_exposer.def_readwrite( "invertposeparameters", &UnitAnimConfig::m_bInvertPoseParameters );
        UnitAnimConfig_exposer.def_readwrite( "useaimsequences", &UnitAnimConfig::m_bUseAimSequences );
        UnitAnimConfig_exposer.def_readwrite( "maxbodyyawdegrees", &UnitAnimConfig::m_flMaxBodyYawDegrees );
    }

    { //::UnitComponent
        typedef bp::class_< UnitComponent > UnitComponent_exposer_t;
        UnitComponent_exposer_t UnitComponent_exposer = UnitComponent_exposer_t( "UnitComponent", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitComponent_scope( UnitComponent_exposer );
        bp::implicitly_convertible< bp::object, UnitComponent >();
        { //::UnitComponent::GetAbsAngles
        
            typedef ::QAngle const & ( ::UnitComponent::*GetAbsAngles_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetAbsAngles"
                , GetAbsAngles_function_type( &::UnitComponent::GetAbsAngles )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetAbsOrigin
        
            typedef ::Vector const & ( ::UnitComponent::*GetAbsOrigin_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetAbsOrigin"
                , GetAbsOrigin_function_type( &::UnitComponent::GetAbsOrigin )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetAbsVelocity
        
            typedef ::Vector const & ( ::UnitComponent::*GetAbsVelocity_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetAbsVelocity"
                , GetAbsVelocity_function_type( &::UnitComponent::GetAbsVelocity )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetCollisionGroup
        
            typedef int ( ::UnitComponent::*GetCollisionGroup_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetCollisionGroup"
                , GetCollisionGroup_function_type( &::UnitComponent::GetCollisionGroup ) );
        
        }
        { //::UnitComponent::GetCycle
        
            typedef float ( ::UnitComponent::*GetCycle_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetCycle"
                , GetCycle_function_type( &::UnitComponent::GetCycle ) );
        
        }
        { //::UnitComponent::GetFlags
        
            typedef int ( ::UnitComponent::*GetFlags_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetFlags"
                , GetFlags_function_type( &::UnitComponent::GetFlags ) );
        
        }
        { //::UnitComponent::GetGravity
        
            typedef float ( ::UnitComponent::*GetGravity_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetGravity"
                , GetGravity_function_type( &::UnitComponent::GetGravity ) );
        
        }
        { //::UnitComponent::GetGroundEntity
        
            typedef ::CBaseEntity * ( ::UnitComponent::*GetGroundEntity_function_type )(  ) ;
            
            UnitComponent_exposer.def( 
                "GetGroundEntity"
                , GetGroundEntity_function_type( &::UnitComponent::GetGroundEntity )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::UnitComponent::GetLocalAngles
        
            typedef ::QAngle const & ( ::UnitComponent::*GetLocalAngles_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetLocalAngles"
                , GetLocalAngles_function_type( &::UnitComponent::GetLocalAngles )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetLocalOrigin
        
            typedef ::Vector const & ( ::UnitComponent::*GetLocalOrigin_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetLocalOrigin"
                , GetLocalOrigin_function_type( &::UnitComponent::GetLocalOrigin )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetLocalVelocity
        
            typedef ::Vector const & ( ::UnitComponent::*GetLocalVelocity_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetLocalVelocity"
                , GetLocalVelocity_function_type( &::UnitComponent::GetLocalVelocity )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::GetSequence
        
            typedef int ( ::UnitComponent::*GetSequence_function_type )(  ) ;
            
            UnitComponent_exposer.def( 
                "GetSequence"
                , GetSequence_function_type( &::UnitComponent::GetSequence ) );
        
        }
        { //::UnitComponent::GetSolid
        
            typedef ::SolidType_t ( ::UnitComponent::*GetSolid_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "GetSolid"
                , GetSolid_function_type( &::UnitComponent::GetSolid ) );
        
        }
        { //::UnitComponent::IsActivityFinished
        
            typedef bool ( ::UnitComponent::*IsActivityFinished_function_type )(  ) ;
            
            UnitComponent_exposer.def( 
                "IsActivityFinished"
                , IsActivityFinished_function_type( &::UnitComponent::IsActivityFinished ) );
        
        }
        { //::UnitComponent::IsSequenceFinished
        
            typedef bool ( ::UnitComponent::*IsSequenceFinished_function_type )(  ) ;
            
            UnitComponent_exposer.def( 
                "IsSequenceFinished"
                , IsSequenceFinished_function_type( &::UnitComponent::IsSequenceFinished ) );
        
        }
        { //::UnitComponent::ResetSequence
        
            typedef void ( ::UnitComponent::*ResetSequence_function_type )( int ) ;
            
            UnitComponent_exposer.def( 
                "ResetSequence"
                , ResetSequence_function_type( &::UnitComponent::ResetSequence )
                , ( bp::arg("nSequence") ) );
        
        }
        { //::UnitComponent::SetAbsVelocity
        
            typedef void ( ::UnitComponent::*SetAbsVelocity_function_type )( ::Vector const & ) ;
            
            UnitComponent_exposer.def( 
                "SetAbsVelocity"
                , SetAbsVelocity_function_type( &::UnitComponent::SetAbsVelocity )
                , ( bp::arg("vecVelocity") ) );
        
        }
        { //::UnitComponent::SetCycle
        
            typedef void ( ::UnitComponent::*SetCycle_function_type )( float ) ;
            
            UnitComponent_exposer.def( 
                "SetCycle"
                , SetCycle_function_type( &::UnitComponent::SetCycle )
                , ( bp::arg("flCycle") ) );
        
        }
        { //::UnitComponent::SetGravity
        
            typedef void ( ::UnitComponent::*SetGravity_function_type )( float ) ;
            
            UnitComponent_exposer.def( 
                "SetGravity"
                , SetGravity_function_type( &::UnitComponent::SetGravity )
                , ( bp::arg("flGravity") ) );
        
        }
        { //::UnitComponent::SetGroundEntity
        
            typedef void ( ::UnitComponent::*SetGroundEntity_function_type )( ::CBaseEntity * ) ;
            
            UnitComponent_exposer.def( 
                "SetGroundEntity"
                , SetGroundEntity_function_type( &::UnitComponent::SetGroundEntity )
                , ( bp::arg("ground") ) );
        
        }
        { //::UnitComponent::SetLocalAngles
        
            typedef void ( ::UnitComponent::*SetLocalAngles_function_type )( ::QAngle const & ) ;
            
            UnitComponent_exposer.def( 
                "SetLocalAngles"
                , SetLocalAngles_function_type( &::UnitComponent::SetLocalAngles )
                , ( bp::arg("angles") ) );
        
        }
        { //::UnitComponent::SetLocalOrigin
        
            typedef void ( ::UnitComponent::*SetLocalOrigin_function_type )( ::Vector const & ) ;
            
            UnitComponent_exposer.def( 
                "SetLocalOrigin"
                , SetLocalOrigin_function_type( &::UnitComponent::SetLocalOrigin )
                , ( bp::arg("origin") ) );
        
        }
        { //::UnitComponent::SetLocalVelocity
        
            typedef void ( ::UnitComponent::*SetLocalVelocity_function_type )( ::Vector const & ) ;
            
            UnitComponent_exposer.def( 
                "SetLocalVelocity"
                , SetLocalVelocity_function_type( &::UnitComponent::SetLocalVelocity )
                , ( bp::arg("vecVelocity") ) );
        
        }
        { //::UnitComponent::SetSequence
        
            typedef void ( ::UnitComponent::*SetSequence_function_type )( int ) ;
            
            UnitComponent_exposer.def( 
                "SetSequence"
                , SetSequence_function_type( &::UnitComponent::SetSequence )
                , ( bp::arg("nSequence") ) );
        
        }
        { //::UnitComponent::SetSolid
        
            typedef void ( ::UnitComponent::*SetSolid_function_type )( ::SolidType_t ) ;
            
            UnitComponent_exposer.def( 
                "SetSolid"
                , SetSolid_function_type( &::UnitComponent::SetSolid )
                , ( bp::arg("val") ) );
        
        }
        { //::UnitComponent::StudioFrameAdvance
        
            typedef void ( ::UnitComponent::*StudioFrameAdvance_function_type )(  ) ;
            
            UnitComponent_exposer.def( 
                "StudioFrameAdvance"
                , StudioFrameAdvance_function_type( &::UnitComponent::StudioFrameAdvance ) );
        
        }
        { //::UnitComponent::WorldAlignMaxs
        
            typedef ::Vector const & ( ::UnitComponent::*WorldAlignMaxs_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "WorldAlignMaxs"
                , WorldAlignMaxs_function_type( &::UnitComponent::WorldAlignMaxs )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::WorldAlignMins
        
            typedef ::Vector const & ( ::UnitComponent::*WorldAlignMins_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "WorldAlignMins"
                , WorldAlignMins_function_type( &::UnitComponent::WorldAlignMins )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::WorldAlignSize
        
            typedef ::Vector const & ( ::UnitComponent::*WorldAlignSize_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "WorldAlignSize"
                , WorldAlignSize_function_type( &::UnitComponent::WorldAlignSize )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitComponent::WorldSpaceCenter
        
            typedef ::Vector ( ::UnitComponent::*WorldSpaceCenter_function_type )(  ) const;
            
            UnitComponent_exposer.def( 
                "WorldSpaceCenter"
                , WorldSpaceCenter_function_type( &::UnitComponent::WorldSpaceCenter ) );
        
        }
        { //property "outer"[fget=::UnitComponent::GetPyOuter]
        
            typedef ::boost::python::object ( ::UnitComponent::*fget )(  ) ;
            
            UnitComponent_exposer.add_property( 
                "outer"
                , fget( &::UnitComponent::GetPyOuter ) );
        
        }
    }

    { //::UnitBaseAnimState
        typedef bp::class_< UnitBaseAnimState_wrapper, bp::bases< UnitComponent > > UnitBaseAnimState_exposer_t;
        UnitBaseAnimState_exposer_t UnitBaseAnimState_exposer = UnitBaseAnimState_exposer_t( "UnitBaseAnimState", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitBaseAnimState_scope( UnitBaseAnimState_exposer );
        bp::implicitly_convertible< bp::object, UnitBaseAnimState >();
        { //::UnitBaseAnimState::GetAnimTimeInterval
        
            typedef float ( ::UnitBaseAnimState::*GetAnimTimeInterval_function_type )(  ) const;
            
            UnitBaseAnimState_exposer.def( 
                "GetAnimTimeInterval"
                , GetAnimTimeInterval_function_type( &::UnitBaseAnimState::GetAnimTimeInterval ) );
        
        }
        { //::UnitBaseAnimState::HasActivity
        
            typedef bool ( ::UnitBaseAnimState::*HasActivity_function_type )( ::Activity ) ;
            
            UnitBaseAnimState_exposer.def( 
                "HasActivity"
                , HasActivity_function_type( &::UnitBaseAnimState::HasActivity )
                , ( bp::arg("actDesired") ) );
        
        }
        { //::UnitBaseAnimState::SelectWeightedSequence
        
            typedef int ( ::UnitBaseAnimState::*SelectWeightedSequence_function_type )( ::Activity ) ;
            typedef int ( UnitBaseAnimState_wrapper::*default_SelectWeightedSequence_function_type )( ::Activity ) ;
            
            UnitBaseAnimState_exposer.def( 
                "SelectWeightedSequence"
                , SelectWeightedSequence_function_type(&::UnitBaseAnimState::SelectWeightedSequence)
                , default_SelectWeightedSequence_function_type(&UnitBaseAnimState_wrapper::default_SelectWeightedSequence)
                , ( bp::arg("activity") ) );
        
        }
        { //::UnitBaseAnimState::Update
        
            typedef void ( ::UnitBaseAnimState::*Update_function_type )( float,float ) ;
            typedef void ( UnitBaseAnimState_wrapper::*default_Update_function_type )( float,float ) ;
            
            UnitBaseAnimState_exposer.def( 
                "Update"
                , Update_function_type(&::UnitBaseAnimState::Update)
                , default_Update_function_type(&UnitBaseAnimState_wrapper::default_Update)
                , ( bp::arg("eyeYaw"), bp::arg("eyePitch") ) );
        
        }
    }

    { //::UnitAnimState
        typedef bp::class_< UnitAnimState_wrapper, bp::bases< UnitBaseAnimState >, boost::noncopyable > UnitAnimState_exposer_t;
        UnitAnimState_exposer_t UnitAnimState_exposer = UnitAnimState_exposer_t( "UnitAnimState", bp::init< bp::object, UnitAnimConfig & >(( bp::arg("outer"), bp::arg("animconfig") )) );
        bp::scope UnitAnimState_scope( UnitAnimState_exposer );
        bp::scope().attr("TURN_NONE") = (int)UnitAnimState::TURN_NONE;
        bp::scope().attr("TURN_LEFT") = (int)UnitAnimState::TURN_LEFT;
        bp::scope().attr("TURN_RIGHT") = (int)UnitAnimState::TURN_RIGHT;
        { //::UnitAnimState::CalcAimLayerSequence
        
            typedef int ( ::UnitAnimState::*CalcAimLayerSequence_function_type )( float *,float *,bool ) ;
            
            UnitAnimState_exposer.def( 
                "CalcAimLayerSequence"
                , CalcAimLayerSequence_function_type( &::UnitAnimState::CalcAimLayerSequence )
                , ( bp::arg("flCycle"), bp::arg("flAimSequenceWeight"), bp::arg("bForceIdle") ) );
        
        }
        { //::UnitAnimState::CalcMainActivity
        
            typedef ::Activity ( ::UnitAnimState::*CalcMainActivity_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "CalcMainActivity"
                , CalcMainActivity_function_type( &::UnitAnimState::CalcMainActivity ) );
        
        }
        { //::UnitAnimState::CalcMovementPlaybackRate
        
            typedef float ( ::UnitAnimState::*CalcMovementPlaybackRate_function_type )( bool * ) ;
            
            UnitAnimState_exposer.def( 
                "CalcMovementPlaybackRate"
                , CalcMovementPlaybackRate_function_type( &::UnitAnimState::CalcMovementPlaybackRate )
                , ( bp::arg("bIsMoving") ) );
        
        }
        { //::UnitAnimState::CanThePlayerMove
        
            typedef bool ( ::UnitAnimState::*CanThePlayerMove_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "CanThePlayerMove"
                , CanThePlayerMove_function_type( &::UnitAnimState::CanThePlayerMove ) );
        
        }
        { //::UnitAnimState::ClearAnimationLayers
        
            typedef void ( ::UnitAnimState::*ClearAnimationLayers_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ClearAnimationLayers"
                , ClearAnimationLayers_function_type( &::UnitAnimState::ClearAnimationLayers ) );
        
        }
        { //::UnitAnimState::ClearAnimationState
        
            typedef void ( ::UnitAnimState::*ClearAnimationState_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ClearAnimationState"
                , ClearAnimationState_function_type( &::UnitAnimState::ClearAnimationState ) );
        
        }
        { //::UnitAnimState::ComputeMiscSequence
        
            typedef void ( ::UnitAnimState::*ComputeMiscSequence_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ComputeMiscSequence"
                , ComputeMiscSequence_function_type( &::UnitAnimState::ComputeMiscSequence ) );
        
        }
        { //::UnitAnimState::ComputePoseParam_BodyPitch
        
            typedef void ( UnitAnimState_wrapper::*ComputePoseParam_BodyPitch_function_type )( ::CStudioHdr * ) ;
            
            UnitAnimState_exposer.def( 
                "ComputePoseParam_BodyPitch"
                , ComputePoseParam_BodyPitch_function_type( &UnitAnimState_wrapper::ComputePoseParam_BodyPitch )
                , ( bp::arg("pStudioHdr") ) );
        
        }
        { //::UnitAnimState::ComputePoseParam_BodyYaw
        
            typedef void ( UnitAnimState_wrapper::*ComputePoseParam_BodyYaw_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ComputePoseParam_BodyYaw"
                , ComputePoseParam_BodyYaw_function_type( &UnitAnimState_wrapper::ComputePoseParam_BodyYaw ) );
        
        }
        { //::UnitAnimState::ComputePoseParam_Lean
        
            typedef void ( UnitAnimState_wrapper::*ComputePoseParam_Lean_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ComputePoseParam_Lean"
                , ComputePoseParam_Lean_function_type( &UnitAnimState_wrapper::ComputePoseParam_Lean ) );
        
        }
        { //::UnitAnimState::ComputePoseParam_MoveYaw
        
            typedef void ( UnitAnimState_wrapper::*ComputePoseParam_MoveYaw_function_type )( ::CStudioHdr * ) ;
            
            UnitAnimState_exposer.def( 
                "ComputePoseParam_MoveYaw"
                , ComputePoseParam_MoveYaw_function_type( &UnitAnimState_wrapper::ComputePoseParam_MoveYaw )
                , ( bp::arg("pStudioHdr") ) );
        
        }
        { //::UnitAnimState::ComputeSequences
        
            typedef void ( ::UnitAnimState::*ComputeSequences_function_type )( ::CStudioHdr * ) ;
            
            UnitAnimState_exposer.def( 
                "ComputeSequences"
                , ComputeSequences_function_type( &::UnitAnimState::ComputeSequences )
                , ( bp::arg("pStudioHdr") ) );
        
        }
        { //::UnitAnimState::ConvergeAngles
        
            typedef int ( UnitAnimState_wrapper::*ConvergeAngles_function_type )( float,float,float,float,float & ) ;
            
            UnitAnimState_exposer.def( 
                "ConvergeAngles"
                , ConvergeAngles_function_type( &UnitAnimState_wrapper::ConvergeAngles )
                , ( bp::arg("goal"), bp::arg("maxrate"), bp::arg("maxgap"), bp::arg("dt"), bp::arg("current") ) );
        
        }
        { //::UnitAnimState::DebugShowAnimState
        
            typedef void ( ::UnitAnimState::*DebugShowAnimState_function_type )( int ) ;
            
            UnitAnimState_exposer.def( 
                "DebugShowAnimState"
                , DebugShowAnimState_function_type( &::UnitAnimState::DebugShowAnimState )
                , ( bp::arg("iStartLine") ) );
        
        }
        { //::UnitAnimState::DebugShowAnimStateFull
        
            typedef void ( ::UnitAnimState::*DebugShowAnimStateFull_function_type )( int ) ;
            
            UnitAnimState_exposer.def( 
                "DebugShowAnimStateFull"
                , DebugShowAnimStateFull_function_type( &::UnitAnimState::DebugShowAnimStateFull )
                , ( bp::arg("iStartLine") ) );
        
        }
        { //::UnitAnimState::EndSpecificActivity
        
            typedef void ( UnitAnimState_wrapper::*EndSpecificActivity_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "EndSpecificActivity"
                , EndSpecificActivity_function_type( &UnitAnimState_wrapper::EndSpecificActivity ) );
        
        }
        { //::UnitAnimState::GetActivityMap
        
            typedef ::boost::python::object ( ::UnitAnimState::*GetActivityMap_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "GetActivityMap"
                , GetActivityMap_function_type( &::UnitAnimState::GetActivityMap ) );
        
        }
        { //::UnitAnimState::GetCurrentMainSequenceActivity
        
            typedef ::Activity ( UnitAnimState_wrapper::*GetCurrentMainSequenceActivity_function_type )(  ) const;
            
            UnitAnimState_exposer.def( 
                "GetCurrentMainSequenceActivity"
                , GetCurrentMainSequenceActivity_function_type( &UnitAnimState_wrapper::GetCurrentMainSequenceActivity ) );
        
        }
        { //::UnitAnimState::GetCurrentMaxGroundSpeed
        
            typedef float ( ::UnitAnimState::*GetCurrentMaxGroundSpeed_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "GetCurrentMaxGroundSpeed"
                , GetCurrentMaxGroundSpeed_function_type( &::UnitAnimState::GetCurrentMaxGroundSpeed ) );
        
        }
        { //::UnitAnimState::GetEyeYaw
        
            typedef float ( UnitAnimState_wrapper::*GetEyeYaw_function_type )(  ) const;
            
            UnitAnimState_exposer.def( 
                "GetEyeYaw"
                , GetEyeYaw_function_type( &UnitAnimState_wrapper::GetEyeYaw ) );
        
        }
        { //::UnitAnimState::GetMiscCycle
        
            typedef float ( ::UnitAnimState::*GetMiscCycle_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "GetMiscCycle"
                , GetMiscCycle_function_type( &::UnitAnimState::GetMiscCycle ) );
        
        }
        { //::UnitAnimState::GetMiscSequence
        
            typedef int ( ::UnitAnimState::*GetMiscSequence_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "GetMiscSequence"
                , GetMiscSequence_function_type( &::UnitAnimState::GetMiscSequence ) );
        
        }
        { //::UnitAnimState::GetOuterAbsVelocity
        
            typedef void ( UnitAnimState_wrapper::*GetOuterAbsVelocity_function_type )( ::Vector & ) const;
            
            UnitAnimState_exposer.def( 
                "GetOuterAbsVelocity"
                , GetOuterAbsVelocity_function_type( &UnitAnimState_wrapper::GetOuterAbsVelocity )
                , ( bp::arg("vel") ) );
        
        }
        { //::UnitAnimState::GetOuterXYSpeed
        
            typedef float ( UnitAnimState_wrapper::*GetOuterXYSpeed_function_type )(  ) const;
            
            UnitAnimState_exposer.def( 
                "GetOuterXYSpeed"
                , GetOuterXYSpeed_function_type( &UnitAnimState_wrapper::GetOuterXYSpeed ) );
        
        }
        { //::UnitAnimState::GetRenderAngles
        
            typedef ::QAngle const & ( ::UnitAnimState::*GetRenderAngles_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "GetRenderAngles"
                , GetRenderAngles_function_type( &::UnitAnimState::GetRenderAngles )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::UnitAnimState::HandleClimbing
        
            typedef bool ( ::UnitAnimState::*HandleClimbing_function_type )( ::Activity & ) ;
            
            UnitAnimState_exposer.def( 
                "HandleClimbing"
                , HandleClimbing_function_type( &::UnitAnimState::HandleClimbing )
                , ( bp::arg("idealActivity") ) );
        
        }
        { //::UnitAnimState::HandleCrouching
        
            typedef bool ( ::UnitAnimState::*HandleCrouching_function_type )( ::Activity & ) ;
            
            UnitAnimState_exposer.def( 
                "HandleCrouching"
                , HandleCrouching_function_type( &::UnitAnimState::HandleCrouching )
                , ( bp::arg("idealActivity") ) );
        
        }
        { //::UnitAnimState::HandleJumping
        
            typedef bool ( ::UnitAnimState::*HandleJumping_function_type )( ::Activity & ) ;
            
            UnitAnimState_exposer.def( 
                "HandleJumping"
                , HandleJumping_function_type( &::UnitAnimState::HandleJumping )
                , ( bp::arg("idealActivity") ) );
        
        }
        { //::UnitAnimState::HasActivity
        
            typedef bool ( ::UnitAnimState::*HasActivity_function_type )( ::Activity ) ;
            
            UnitAnimState_exposer.def( 
                "HasActivity"
                , HasActivity_function_type( &::UnitAnimState::HasActivity )
                , ( bp::arg("actDesired") ) );
        
        }
        { //::UnitAnimState::OnEndSpecificActivity
        
            typedef ::Activity ( ::UnitAnimState::*OnEndSpecificActivity_function_type )( ::Activity ) ;
            typedef ::Activity ( UnitAnimState_wrapper::*default_OnEndSpecificActivity_function_type )( ::Activity ) ;
            
            UnitAnimState_exposer.def( 
                "OnEndSpecificActivity"
                , OnEndSpecificActivity_function_type(&::UnitAnimState::OnEndSpecificActivity)
                , default_OnEndSpecificActivity_function_type(&UnitAnimState_wrapper::default_OnEndSpecificActivity)
                , ( bp::arg("specificactivity") ) );
        
        }
        { //::UnitAnimState::OnNewModel
        
            typedef void ( ::UnitAnimState::*OnNewModel_function_type )(  ) ;
            typedef void ( UnitAnimState_wrapper::*default_OnNewModel_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "OnNewModel"
                , OnNewModel_function_type(&::UnitAnimState::OnNewModel)
                , default_OnNewModel_function_type(&UnitAnimState_wrapper::default_OnNewModel) );
        
        }
        { //::UnitAnimState::ResetGroundSpeed
        
            typedef void ( UnitAnimState_wrapper::*ResetGroundSpeed_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ResetGroundSpeed"
                , ResetGroundSpeed_function_type( &UnitAnimState_wrapper::ResetGroundSpeed ) );
        
        }
        { //::UnitAnimState::RestartMainSequence
        
            typedef void ( ::UnitAnimState::*RestartMainSequence_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "RestartMainSequence"
                , RestartMainSequence_function_type( &::UnitAnimState::RestartMainSequence ) );
        
        }
        { //::UnitAnimState::SetActivityMap
        
            typedef void ( ::UnitAnimState::*SetActivityMap_function_type )( ::boost::python::object ) ;
            
            UnitAnimState_exposer.def( 
                "SetActivityMap"
                , SetActivityMap_function_type( &::UnitAnimState::SetActivityMap )
                , ( bp::arg("activitymap") ) );
        
        }
        { //::UnitAnimState::SetMiscPlaybackRate
        
            typedef void ( ::UnitAnimState::*SetMiscPlaybackRate_function_type )( float ) ;
            
            UnitAnimState_exposer.def( 
                "SetMiscPlaybackRate"
                , SetMiscPlaybackRate_function_type( &::UnitAnimState::SetMiscPlaybackRate )
                , ( bp::arg("flRate") ) );
        
        }
        { //::UnitAnimState::SetOuterBodyYaw
        
            typedef float ( ::UnitAnimState::*SetOuterBodyYaw_function_type )( float ) ;
            
            UnitAnimState_exposer.def( 
                "SetOuterBodyYaw"
                , SetOuterBodyYaw_function_type( &::UnitAnimState::SetOuterBodyYaw )
                , ( bp::arg("flValue") ) );
        
        }
        { //::UnitAnimState::ShouldBlendAimSequenceToIdle
        
            typedef bool ( ::UnitAnimState::*ShouldBlendAimSequenceToIdle_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ShouldBlendAimSequenceToIdle"
                , ShouldBlendAimSequenceToIdle_function_type( &::UnitAnimState::ShouldBlendAimSequenceToIdle ) );
        
        }
        { //::UnitAnimState::ShouldChangeSequences
        
            typedef bool ( ::UnitAnimState::*ShouldChangeSequences_function_type )(  ) const;
            
            UnitAnimState_exposer.def( 
                "ShouldChangeSequences"
                , ShouldChangeSequences_function_type( &::UnitAnimState::ShouldChangeSequences ) );
        
        }
        { //::UnitAnimState::ShouldResetGroundSpeed
        
            typedef bool ( ::UnitAnimState::*ShouldResetGroundSpeed_function_type )( ::Activity,::Activity ) ;
            
            UnitAnimState_exposer.def( 
                "ShouldResetGroundSpeed"
                , ShouldResetGroundSpeed_function_type( &::UnitAnimState::ShouldResetGroundSpeed )
                , ( bp::arg("oldActivity"), bp::arg("idealActivity") ) );
        
        }
        { //::UnitAnimState::ShouldUpdateAnimState
        
            typedef bool ( ::UnitAnimState::*ShouldUpdateAnimState_function_type )(  ) ;
            
            UnitAnimState_exposer.def( 
                "ShouldUpdateAnimState"
                , ShouldUpdateAnimState_function_type( &::UnitAnimState::ShouldUpdateAnimState ) );
        
        }
        { //::UnitAnimState::TimeSinceLastAnimationStateClear
        
            typedef float ( UnitAnimState_wrapper::*TimeSinceLastAnimationStateClear_function_type )(  ) const;
            
            UnitAnimState_exposer.def( 
                "TimeSinceLastAnimationStateClear"
                , TimeSinceLastAnimationStateClear_function_type( &UnitAnimState_wrapper::TimeSinceLastAnimationStateClear ) );
        
        }
        { //::UnitAnimState::TranslateActivity
        
            typedef ::Activity ( ::UnitAnimState::*TranslateActivity_function_type )( ::Activity ) ;
            
            UnitAnimState_exposer.def( 
                "TranslateActivity"
                , TranslateActivity_function_type( &::UnitAnimState::TranslateActivity )
                , ( bp::arg("actDesired") ) );
        
        }
        { //::UnitAnimState::Update
        
            typedef void ( ::UnitAnimState::*Update_function_type )( float,float ) ;
            
            UnitAnimState_exposer.def( 
                "Update"
                , Update_function_type( &::UnitAnimState::Update )
                , ( bp::arg("eyeYaw"), bp::arg("eyePitch") ) );
        
        }
        { //::UnitAnimState::UpdateLayerSequenceGeneric
        
            typedef void ( UnitAnimState_wrapper::*UpdateLayerSequenceGeneric_function_type )( int,bool &,float &,int &,bool,float,float,bool,float,bool ) ;
            
            UnitAnimState_exposer.def( 
                "UpdateLayerSequenceGeneric"
                , UpdateLayerSequenceGeneric_function_type( &UnitAnimState_wrapper::UpdateLayerSequenceGeneric )
                , ( bp::arg("iLayer"), bp::arg("bEnabled"), bp::arg("flCurCycle"), bp::arg("iSequence"), bp::arg("bWaitAtEnd"), bp::arg("fBlendIn")=1.500000059604644775390625e-1f, bp::arg("fBlendOut")=1.500000059604644775390625e-1f, bp::arg("bMoveBlend")=(bool)(false), bp::arg("fPlaybackRate")=1.0e+0f, bp::arg("bUpdateCycle")=(bool)(true) ) );
        
        }
        UnitAnimState_exposer.def_readwrite( "combatstateifenemy", &UnitAnimState::m_bCombatStateIfEnemy );
        UnitAnimState_exposer.def_readwrite( "firstjumpframe", &UnitAnimState::m_bFirstJumpFrame );
        UnitAnimState_exposer.def_readwrite( "flipmovey", &UnitAnimState::m_bFlipMoveY );
        UnitAnimState_exposer.def_readwrite( "jumping", &UnitAnimState::m_bJumping );
        UnitAnimState_exposer.def_readwrite( "miscnooverride", &UnitAnimState::m_bMiscNoOverride );
        UnitAnimState_exposer.def_readwrite( "misconlywhenstill", &UnitAnimState::m_bMiscOnlyWhenStill );
        UnitAnimState_exposer.def_readwrite( "newjump", &UnitAnimState::m_bNewJump );
        UnitAnimState_exposer.def_readwrite( "playfallactinair", &UnitAnimState::m_bPlayFallActInAir );
        UnitAnimState_exposer.def_readwrite( "playermisc", &UnitAnimState::m_bPlayingMisc );
        UnitAnimState_exposer.def_readwrite( "usecombatstate", &UnitAnimState::m_bUseCombatState );
        UnitAnimState_exposer.def_readwrite( "combatstatetime", &UnitAnimState::m_fCombatStateTime );
        UnitAnimState_exposer.def_readwrite( "miscplaybackrate", &UnitAnimState::m_fMiscPlaybackRate );
        UnitAnimState_exposer.def_readwrite( "facefronttime", &UnitAnimState::m_flFaceFrontTime );
        UnitAnimState_exposer.def_readwrite( "feetyawrate", &UnitAnimState::m_flFeetYawRate );
        UnitAnimState_exposer.def_readwrite( "jumpstarttime", &UnitAnimState::m_flJumpStartTime );
        UnitAnimState_exposer.def_readwrite( "miscblendin", &UnitAnimState::m_flMiscBlendIn );
        UnitAnimState_exposer.def_readwrite( "miscblendout", &UnitAnimState::m_flMiscBlendOut );
        UnitAnimState_exposer.def_readwrite( "misccycle", &UnitAnimState::m_flMiscCycle );
        UnitAnimState_exposer.def_readwrite( "bodypitch", &UnitAnimState::m_iBodyPitch );
        UnitAnimState_exposer.def_readwrite( "bodyyaw", &UnitAnimState::m_iBodyYaw );
        UnitAnimState_exposer.def_readwrite( "leanpitch", &UnitAnimState::m_iLeanPitch );
        UnitAnimState_exposer.def_readwrite( "leanyaw", &UnitAnimState::m_iLeanYaw );
        UnitAnimState_exposer.def_readwrite( "miscsequence", &UnitAnimState::m_iMiscSequence );
        UnitAnimState_exposer.def_readwrite( "movex", &UnitAnimState::m_iMoveX );
        UnitAnimState_exposer.def_readwrite( "movey", &UnitAnimState::m_iMoveY );
        UnitAnimState_exposer.def_readwrite( "moveyaw", &UnitAnimState::m_iMoveYaw );
        UnitAnimState_exposer.def_readwrite( "specificmainactivity", &UnitAnimState::m_nSpecificMainActivity );
        { //::UnitBaseAnimState::SelectWeightedSequence
        
            typedef int ( ::UnitBaseAnimState::*SelectWeightedSequence_function_type )( ::Activity ) ;
            typedef int ( UnitAnimState_wrapper::*default_SelectWeightedSequence_function_type )( ::Activity ) ;
            
            UnitAnimState_exposer.def( 
                "SelectWeightedSequence"
                , SelectWeightedSequence_function_type(&::UnitBaseAnimState::SelectWeightedSequence)
                , default_SelectWeightedSequence_function_type(&UnitAnimState_wrapper::default_SelectWeightedSequence)
                , ( bp::arg("activity") ) );
        
        }
        { //property "aimlayersequence"[fget=::UnitAnimState::GetAimLayerSequence, fset=::UnitAnimState::SetAimLayerSequence]
        
            typedef char const * ( ::UnitAnimState::*fget )(  ) ;
            typedef void ( ::UnitAnimState::*fset )( char const * ) ;
            
            UnitAnimState_exposer.add_property( 
                "aimlayersequence"
                , fget( &::UnitAnimState::GetAimLayerSequence )
                , fset( &::UnitAnimState::SetAimLayerSequence ) );
        
        }
        { //property "specmainactplaybackrate"[fget=::UnitAnimState::GetCustomSpecificActPlaybackRate, fset=::UnitAnimState::SetCustomSpecificActPlaybackRate]
        
            typedef float ( ::UnitAnimState::*fget )(  ) ;
            typedef void ( ::UnitAnimState::*fset )( float ) ;
            
            UnitAnimState_exposer.add_property( 
                "specmainactplaybackrate"
                , fget( &::UnitAnimState::GetCustomSpecificActPlaybackRate )
                , fset( &::UnitAnimState::SetCustomSpecificActPlaybackRate ) );
        
        }
    }

    { //::UnitBaseLocomotion
        typedef bp::class_< UnitBaseLocomotion_wrapper, bp::bases< UnitComponent > > UnitBaseLocomotion_exposer_t;
        UnitBaseLocomotion_exposer_t UnitBaseLocomotion_exposer = UnitBaseLocomotion_exposer_t( "UnitBaseLocomotion", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitBaseLocomotion_scope( UnitBaseLocomotion_exposer );
        bp::implicitly_convertible< bp::object, UnitBaseLocomotion >();
        { //::UnitBaseLocomotion::Accelerate
        
            typedef void ( ::UnitBaseLocomotion::*Accelerate_function_type )( ::Vector &,float,float ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "Accelerate"
                , Accelerate_function_type( &::UnitBaseLocomotion::Accelerate )
                , ( bp::arg("wishdir"), bp::arg("wishspeed"), bp::arg("accel") ) );
        
        }
        { //::UnitBaseLocomotion::AirAccelerate
        
            typedef void ( ::UnitBaseLocomotion::*AirAccelerate_function_type )( ::Vector &,float,float ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "AirAccelerate"
                , AirAccelerate_function_type( &::UnitBaseLocomotion::AirAccelerate )
                , ( bp::arg("wishdir"), bp::arg("wishspeed"), bp::arg("accel") ) );
        
        }
        { //::UnitBaseLocomotion::AirMove
        
            typedef void ( ::UnitBaseLocomotion::*AirMove_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "AirMove"
                , AirMove_function_type( &::UnitBaseLocomotion::AirMove ) );
        
        }
        { //::UnitBaseLocomotion::CanAccelerate
        
            typedef bool ( ::UnitBaseLocomotion::*CanAccelerate_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "CanAccelerate"
                , CanAccelerate_function_type( &::UnitBaseLocomotion::CanAccelerate ) );
        
        }
        { //::UnitBaseLocomotion::CategorizePosition
        
            typedef void ( ::UnitBaseLocomotion::*CategorizePosition_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "CategorizePosition"
                , CategorizePosition_function_type( &::UnitBaseLocomotion::CategorizePosition ) );
        
        }
        { //::UnitBaseLocomotion::CheckStep
        
            typedef bool ( ::UnitBaseLocomotion::*CheckStep_function_type )( ::UnitCheckStepArgs_t const &,::UnitCheckStepResult_t * ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "CheckStep"
                , CheckStep_function_type( &::UnitBaseLocomotion::CheckStep )
                , ( bp::arg("args"), bp::arg("pResult") ) );
        
        }
        { //::UnitBaseLocomotion::ClipVelocity
        
            typedef int ( ::UnitBaseLocomotion::*ClipVelocity_function_type )( ::Vector &,::Vector &,::Vector &,float ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "ClipVelocity"
                , ClipVelocity_function_type( &::UnitBaseLocomotion::ClipVelocity )
                , ( bp::arg("in"), bp::arg("normal"), bp::arg("out"), bp::arg("overbounce") ) );
        
        }
        { //::UnitBaseLocomotion::FinishGravity
        
            typedef void ( ::UnitBaseLocomotion::*FinishGravity_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "FinishGravity"
                , FinishGravity_function_type( &::UnitBaseLocomotion::FinishGravity ) );
        
        }
        { //::UnitBaseLocomotion::FinishMove
        
            typedef void ( ::UnitBaseLocomotion::*FinishMove_function_type )( ::UnitBaseMoveCommand & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "FinishMove"
                , FinishMove_function_type( &::UnitBaseLocomotion::FinishMove )
                , ( bp::arg("mv") ) );
        
        }
        { //::UnitBaseLocomotion::Friction
        
            typedef void ( ::UnitBaseLocomotion::*Friction_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "Friction"
                , Friction_function_type( &::UnitBaseLocomotion::Friction ) );
        
        }
        { //::UnitBaseLocomotion::FullWalkMove
        
            typedef void ( ::UnitBaseLocomotion::*FullWalkMove_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "FullWalkMove"
                , FullWalkMove_function_type( &::UnitBaseLocomotion::FullWalkMove ) );
        
        }
        { //::UnitBaseLocomotion::GetStopDistance
        
            typedef float ( ::UnitBaseLocomotion::*GetStopDistance_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "GetStopDistance"
                , GetStopDistance_function_type( &::UnitBaseLocomotion::GetStopDistance ) );
        
        }
        { //::UnitBaseLocomotion::GroundMove
        
            typedef void ( ::UnitBaseLocomotion::*GroundMove_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "GroundMove"
                , GroundMove_function_type( &::UnitBaseLocomotion::GroundMove ) );
        
        }
        { //::UnitBaseLocomotion::HandleJump
        
            typedef void ( ::UnitBaseLocomotion::*HandleJump_function_type )(  ) ;
            typedef void ( UnitBaseLocomotion_wrapper::*default_HandleJump_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "HandleJump"
                , HandleJump_function_type(&::UnitBaseLocomotion::HandleJump)
                , default_HandleJump_function_type(&UnitBaseLocomotion_wrapper::default_HandleJump) );
        
        }
        { //::UnitBaseLocomotion::Move
        
            typedef void ( ::UnitBaseLocomotion::*Move_function_type )( float,::UnitBaseMoveCommand & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "Move"
                , Move_function_type( &::UnitBaseLocomotion::Move )
                , ( bp::arg("interval"), bp::arg("mv") ) );
        
        }
        { //::UnitBaseLocomotion::MoveFacing
        
            typedef void ( ::UnitBaseLocomotion::*MoveFacing_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "MoveFacing"
                , MoveFacing_function_type( &::UnitBaseLocomotion::MoveFacing ) );
        
        }
        { //::UnitBaseLocomotion::PerformMovement
        
            typedef void ( ::UnitBaseLocomotion::*PerformMovement_function_type )( ::UnitBaseMoveCommand & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "PerformMovement"
                , PerformMovement_function_type( &::UnitBaseLocomotion::PerformMovement )
                , ( bp::arg("mv") ) );
        
        }
        { //::UnitBaseLocomotion::SetupMove
        
            typedef void ( ::UnitBaseLocomotion::*SetupMove_function_type )( ::UnitBaseMoveCommand & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "SetupMove"
                , SetupMove_function_type( &::UnitBaseLocomotion::SetupMove )
                , ( bp::arg("mv") ) );
        
        }
        { //::UnitBaseLocomotion::SetupMovementBounds
        
            typedef void ( ::UnitBaseLocomotion::*SetupMovementBounds_function_type )( ::UnitBaseMoveCommand & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "SetupMovementBounds"
                , SetupMovementBounds_function_type( &::UnitBaseLocomotion::SetupMovementBounds )
                , ( bp::arg("mv") ) );
        
        }
        { //::UnitBaseLocomotion::ShouldWalk
        
            typedef bool ( ::UnitBaseLocomotion::*ShouldWalk_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "ShouldWalk"
                , ShouldWalk_function_type( &::UnitBaseLocomotion::ShouldWalk ) );
        
        }
        { //::UnitBaseLocomotion::StartGravity
        
            typedef void ( ::UnitBaseLocomotion::*StartGravity_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "StartGravity"
                , StartGravity_function_type( &::UnitBaseLocomotion::StartGravity ) );
        
        }
        { //::UnitBaseLocomotion::StepMove
        
            typedef void ( ::UnitBaseLocomotion::*StepMove_function_type )( ::Vector &,::trace_t & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "StepMove"
                , StepMove_function_type( &::UnitBaseLocomotion::StepMove )
                , ( bp::arg("vecDestination"), bp::arg("trace") ) );
        
        }
        { //::UnitBaseLocomotion::TraceUnitBBox
        
            typedef void ( ::UnitBaseLocomotion::*TraceUnitBBox_function_type )( ::Vector const &,::Vector const &,unsigned int,int,::trace_t & ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "TraceUnitBBox"
                , TraceUnitBBox_function_type( &::UnitBaseLocomotion::TraceUnitBBox )
                , ( bp::arg("start"), bp::arg("end"), bp::arg("fMask"), bp::arg("collisionGroup"), bp::arg("pm") ) );
        
        }
        { //::UnitBaseLocomotion::TryUnitMove
        
            typedef int ( ::UnitBaseLocomotion::*TryUnitMove_function_type )( ::Vector *,::trace_t * ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "TryUnitMove"
                , TryUnitMove_function_type( &::UnitBaseLocomotion::TryUnitMove )
                , ( bp::arg("pFirstDest")=bp::object(), bp::arg("pFirstTrace")=bp::object() ) );
        
        }
        { //::UnitBaseLocomotion::UnitTryMove
        
            typedef int ( ::UnitBaseLocomotion::*UnitTryMove_function_type )( ::trace_t * ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "UnitTryMove"
                , UnitTryMove_function_type( &::UnitBaseLocomotion::UnitTryMove )
                , ( bp::arg("steptrace") ) );
        
        }
        { //::UnitBaseLocomotion::WalkMove
        
            typedef void ( ::UnitBaseLocomotion::*WalkMove_function_type )(  ) ;
            
            UnitBaseLocomotion_exposer.def( 
                "WalkMove"
                , WalkMove_function_type( &::UnitBaseLocomotion::WalkMove ) );
        
        }
        UnitBaseLocomotion_exposer.def_readwrite( "acceleration", &UnitBaseLocomotion::acceleration );
        UnitBaseLocomotion_exposer.def_readwrite( "airacceleration", &UnitBaseLocomotion::airacceleration );
        UnitBaseLocomotion_exposer.def_readwrite( "blocker_hitpos", &UnitBaseLocomotion::blocker_hitpos );
        UnitBaseLocomotion_exposer.def_readwrite( "stepsize", &UnitBaseLocomotion::stepsize );
        UnitBaseLocomotion_exposer.def_readwrite( "stopspeed", &UnitBaseLocomotion::stopspeed );
        UnitBaseLocomotion_exposer.def_readwrite( "surfacefriction", &UnitBaseLocomotion::surfacefriction );
        UnitBaseLocomotion_exposer.def_readwrite( "unitsolidmask", &UnitBaseLocomotion::unitsolidmask );
        UnitBaseLocomotion_exposer.def_readwrite( "worldfriction", &UnitBaseLocomotion::worldfriction );
    }

    { //::UnitBaseAirLocomotion
        typedef bp::class_< UnitBaseAirLocomotion_wrapper, bp::bases< UnitBaseLocomotion > > UnitBaseAirLocomotion_exposer_t;
        UnitBaseAirLocomotion_exposer_t UnitBaseAirLocomotion_exposer = UnitBaseAirLocomotion_exposer_t( "UnitBaseAirLocomotion", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitBaseAirLocomotion_scope( UnitBaseAirLocomotion_exposer );
        bp::implicitly_convertible< bp::object, UnitBaseAirLocomotion >();
        { //::UnitBaseAirLocomotion::AirAccelerate
        
            typedef void ( ::UnitBaseAirLocomotion::*AirAccelerate_function_type )( ::Vector &,float,float ) ;
            
            UnitBaseAirLocomotion_exposer.def( 
                "AirAccelerate"
                , AirAccelerate_function_type( &::UnitBaseAirLocomotion::AirAccelerate )
                , ( bp::arg("wishdir"), bp::arg("wishspeed"), bp::arg("accel") ) );
        
        }
        { //::UnitBaseAirLocomotion::Friction
        
            typedef void ( ::UnitBaseAirLocomotion::*Friction_function_type )(  ) ;
            
            UnitBaseAirLocomotion_exposer.def( 
                "Friction"
                , Friction_function_type( &::UnitBaseAirLocomotion::Friction ) );
        
        }
        { //::UnitBaseAirLocomotion::FullAirMove
        
            typedef void ( ::UnitBaseAirLocomotion::*FullAirMove_function_type )(  ) ;
            
            UnitBaseAirLocomotion_exposer.def( 
                "FullAirMove"
                , FullAirMove_function_type( &::UnitBaseAirLocomotion::FullAirMove ) );
        
        }
        { //::UnitBaseAirLocomotion::Move
        
            typedef void ( ::UnitBaseAirLocomotion::*Move_function_type )( float,::UnitBaseMoveCommand & ) ;
            
            UnitBaseAirLocomotion_exposer.def( 
                "Move"
                , Move_function_type( &::UnitBaseAirLocomotion::Move )
                , ( bp::arg("interval"), bp::arg("mv") ) );
        
        }
        UnitBaseAirLocomotion_exposer.def_readwrite( "desiredheight", &UnitBaseAirLocomotion::m_fDesiredHeight );
        UnitBaseAirLocomotion_exposer.def_readwrite( "flynoiserate", &UnitBaseAirLocomotion::m_fFlyNoiseRate );
        UnitBaseAirLocomotion_exposer.def_readwrite( "flynoisez", &UnitBaseAirLocomotion::m_fFlyNoiseZ );
        { //::UnitBaseLocomotion::HandleJump
        
            typedef void ( ::UnitBaseLocomotion::*HandleJump_function_type )(  ) ;
            typedef void ( UnitBaseAirLocomotion_wrapper::*default_HandleJump_function_type )(  ) ;
            
            UnitBaseAirLocomotion_exposer.def( 
                "HandleJump"
                , HandleJump_function_type(&::UnitBaseLocomotion::HandleJump)
                , default_HandleJump_function_type(&UnitBaseAirLocomotion_wrapper::default_HandleJump) );
        
        }
    }

    bp::class_< UnitBasePath >( "UnitBasePath", bp::init< >() )    
        .def( bp::init< UnitBasePath const & >(( bp::arg("src") )) )    
        .def( 
            "Advance"
            , (void ( ::UnitBasePath::* )(  ) )( &::UnitBasePath::Advance ) )    
        .def( 
            "Clear"
            , (void ( ::UnitBasePath::* )(  ) )( &::UnitBasePath::Clear ) )    
        .def( 
            "CurWaypointIsGoal"
            , (bool ( ::UnitBasePath::* )(  ) )( &::UnitBasePath::CurWaypointIsGoal ) )    
        .def( 
            "GetToleranceCurWaypoint"
            , (float ( ::UnitBasePath::* )(  ) )( &::UnitBasePath::GetToleranceCurWaypoint ) )    
        .def_readwrite( "avoidenemies", &UnitBasePath::m_bAvoidEnemies )    
        .def_readwrite( "goaltolerance", &UnitBasePath::m_fGoalTolerance )    
        .def_readwrite( "maxmovedist", &UnitBasePath::m_fMaxMoveDist )    
        .def_readwrite( "maxrange", &UnitBasePath::m_fMaxRange )    
        .def_readwrite( "minrange", &UnitBasePath::m_fMinRange )    
        .def_readwrite( "goalflags", &UnitBasePath::m_iGoalFlags )    
        .def_readwrite( "goaltype", &UnitBasePath::m_iGoalType )    
        .def_readwrite( "goalinrangepos", &UnitBasePath::m_vGoalInRangePos )    
        .def_readwrite( "goalpos", &UnitBasePath::m_vGoalPos )    
        .def_readwrite( "startposition", &UnitBasePath::m_vStartPosition )    
        .def_readwrite( "waypointtolerance", &UnitBasePath::m_waypointTolerance );

    { //::UnitBaseNavigator
        typedef bp::class_< UnitBaseNavigator_wrapper, bp::bases< UnitComponent >, boost::noncopyable > UnitBaseNavigator_exposer_t;
        UnitBaseNavigator_exposer_t UnitBaseNavigator_exposer = UnitBaseNavigator_exposer_t( "UnitBaseNavigator", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitBaseNavigator_scope( UnitBaseNavigator_exposer );
        bp::implicitly_convertible< bp::object, UnitBaseNavigator >();
        { //::UnitBaseNavigator::CalcMove
        
            typedef void ( ::UnitBaseNavigator::*CalcMove_function_type )( ::UnitBaseMoveCommand &,::QAngle,float ) ;
            typedef void ( UnitBaseNavigator_wrapper::*default_CalcMove_function_type )( ::UnitBaseMoveCommand &,::QAngle,float ) ;
            
            UnitBaseNavigator_exposer.def( 
                "CalcMove"
                , CalcMove_function_type(&::UnitBaseNavigator::CalcMove)
                , default_CalcMove_function_type(&UnitBaseNavigator_wrapper::default_CalcMove)
                , ( bp::arg("MoveCommand"), bp::arg("angles"), bp::arg("speed") ) );
        
        }
        { //::UnitBaseNavigator::DrawDebugInfo
        
            typedef void ( ::UnitBaseNavigator::*DrawDebugInfo_function_type )(  ) ;
            typedef void ( UnitBaseNavigator_wrapper::*default_DrawDebugInfo_function_type )(  ) ;
            
            UnitBaseNavigator_exposer.def( 
                "DrawDebugInfo"
                , DrawDebugInfo_function_type(&::UnitBaseNavigator::DrawDebugInfo)
                , default_DrawDebugInfo_function_type(&UnitBaseNavigator_wrapper::default_DrawDebugInfo) );
        
        }
        { //::UnitBaseNavigator::DrawDebugRouteOverlay
        
            typedef void ( ::UnitBaseNavigator::*DrawDebugRouteOverlay_function_type )(  ) ;
            typedef void ( UnitBaseNavigator_wrapper::*default_DrawDebugRouteOverlay_function_type )(  ) ;
            
            UnitBaseNavigator_exposer.def( 
                "DrawDebugRouteOverlay"
                , DrawDebugRouteOverlay_function_type(&::UnitBaseNavigator::DrawDebugRouteOverlay)
                , default_DrawDebugRouteOverlay_function_type(&UnitBaseNavigator_wrapper::default_DrawDebugRouteOverlay) );
        
        }
        { //::UnitBaseNavigator::GetGoalDistance
        
            typedef float ( ::UnitBaseNavigator::*GetGoalDistance_function_type )(  ) ;
            typedef float ( UnitBaseNavigator_wrapper::*default_GetGoalDistance_function_type )(  ) ;
            
            UnitBaseNavigator_exposer.def( 
                "GetGoalDistance"
                , GetGoalDistance_function_type(&::UnitBaseNavigator::GetGoalDistance)
                , default_GetGoalDistance_function_type(&UnitBaseNavigator_wrapper::default_GetGoalDistance) );
        
        }
        { //::UnitBaseNavigator::RegenerateConsiderList
        
            typedef void ( ::UnitBaseNavigator::*RegenerateConsiderList_function_type )( ::Vector &,::CheckGoalStatus_t ) ;
            typedef void ( UnitBaseNavigator_wrapper::*default_RegenerateConsiderList_function_type )( ::Vector &,::CheckGoalStatus_t ) ;
            
            UnitBaseNavigator_exposer.def( 
                "RegenerateConsiderList"
                , RegenerateConsiderList_function_type(&::UnitBaseNavigator::RegenerateConsiderList)
                , default_RegenerateConsiderList_function_type(&UnitBaseNavigator_wrapper::default_RegenerateConsiderList)
                , ( bp::arg("vPathDir"), bp::arg("GoalStatus") ) );
        
        }
        { //::UnitBaseNavigator::Reset
        
            typedef void ( ::UnitBaseNavigator::*Reset_function_type )(  ) ;
            typedef void ( UnitBaseNavigator_wrapper::*default_Reset_function_type )(  ) ;
            
            UnitBaseNavigator_exposer.def( 
                "Reset"
                , Reset_function_type(&::UnitBaseNavigator::Reset)
                , default_Reset_function_type(&UnitBaseNavigator_wrapper::default_Reset) );
        
        }
        { //::UnitBaseNavigator::SetGoal
        
            typedef bool ( ::UnitBaseNavigator::*SetGoal_function_type )( ::Vector &,float,int,bool ) ;
            typedef bool ( UnitBaseNavigator_wrapper::*default_SetGoal_function_type )( ::Vector &,float,int,bool ) ;
            
            UnitBaseNavigator_exposer.def( 
                "SetGoal"
                , SetGoal_function_type(&::UnitBaseNavigator::SetGoal)
                , default_SetGoal_function_type(&UnitBaseNavigator_wrapper::default_SetGoal)
                , ( bp::arg("destination"), bp::arg("goaltolerance")=6.4e+1f, bp::arg("goalflags")=(int)(0), bp::arg("avoidenemies")=(bool)(true) ) );
        
        }
        { //::UnitBaseNavigator::SetGoalInRange
        
            typedef bool ( ::UnitBaseNavigator::*SetGoalInRange_function_type )( ::Vector &,float,float,float,int,bool ) ;
            typedef bool ( UnitBaseNavigator_wrapper::*default_SetGoalInRange_function_type )( ::Vector &,float,float,float,int,bool ) ;
            
            UnitBaseNavigator_exposer.def( 
                "SetGoalInRange"
                , SetGoalInRange_function_type(&::UnitBaseNavigator::SetGoalInRange)
                , default_SetGoalInRange_function_type(&UnitBaseNavigator_wrapper::default_SetGoalInRange)
                , ( bp::arg("destination"), bp::arg("maxrange"), bp::arg("minrange")=0.0f, bp::arg("goaltolerance")=0.0f, bp::arg("goalflags")=(int)(0), bp::arg("avoidenemies")=(bool)(true) ) );
        
        }
        { //::UnitBaseNavigator::SetGoalTarget
        
            typedef bool ( ::UnitBaseNavigator::*SetGoalTarget_function_type )( ::CBaseEntity *,float,int,bool ) ;
            typedef bool ( UnitBaseNavigator_wrapper::*default_SetGoalTarget_function_type )( ::CBaseEntity *,float,int,bool ) ;
            
            UnitBaseNavigator_exposer.def( 
                "SetGoalTarget"
                , SetGoalTarget_function_type(&::UnitBaseNavigator::SetGoalTarget)
                , default_SetGoalTarget_function_type(&UnitBaseNavigator_wrapper::default_SetGoalTarget)
                , ( bp::arg("pTarget"), bp::arg("goaltolerance")=6.4e+1f, bp::arg("goalflags")=(int)(0), bp::arg("avoidenemies")=(bool)(true) ) );
        
        }
        { //::UnitBaseNavigator::SetGoalTargetInRange
        
            typedef bool ( ::UnitBaseNavigator::*SetGoalTargetInRange_function_type )( ::CBaseEntity *,float,float,float,int,bool ) ;
            typedef bool ( UnitBaseNavigator_wrapper::*default_SetGoalTargetInRange_function_type )( ::CBaseEntity *,float,float,float,int,bool ) ;
            
            UnitBaseNavigator_exposer.def( 
                "SetGoalTargetInRange"
                , SetGoalTargetInRange_function_type(&::UnitBaseNavigator::SetGoalTargetInRange)
                , default_SetGoalTargetInRange_function_type(&UnitBaseNavigator_wrapper::default_SetGoalTargetInRange)
                , ( bp::arg("pTarget"), bp::arg("maxrange"), bp::arg("minrange")=0.0f, bp::arg("goaltolerance")=0.0f, bp::arg("goalflags")=(int)(0), bp::arg("avoidenemies")=(bool)(true) ) );
        
        }
        { //::UnitBaseNavigator::SetVectorGoal
        
            typedef bool ( ::UnitBaseNavigator::*SetVectorGoal_function_type )( ::Vector const &,float,float,bool ) ;
            
            UnitBaseNavigator_exposer.def( 
                "SetVectorGoal"
                , SetVectorGoal_function_type( &::UnitBaseNavigator::SetVectorGoal )
                , ( bp::arg("dir"), bp::arg("targetDist"), bp::arg("minDist")=0, bp::arg("fShouldDeflect")=(bool)(false) ) );
        
        }
        { //::UnitBaseNavigator::StopMoving
        
            typedef void ( ::UnitBaseNavigator::*StopMoving_function_type )(  ) ;
            typedef void ( UnitBaseNavigator_wrapper::*default_StopMoving_function_type )(  ) ;
            
            UnitBaseNavigator_exposer.def( 
                "StopMoving"
                , StopMoving_function_type(&::UnitBaseNavigator::StopMoving)
                , default_StopMoving_function_type(&UnitBaseNavigator_wrapper::default_StopMoving) );
        
        }
        { //::UnitBaseNavigator::TestRoute
        
            typedef bool ( ::UnitBaseNavigator::*TestRoute_function_type )( ::Vector const &,::Vector const & ) ;
            typedef bool ( UnitBaseNavigator_wrapper::*default_TestRoute_function_type )( ::Vector const &,::Vector const & ) ;
            
            UnitBaseNavigator_exposer.def( 
                "TestRoute"
                , TestRoute_function_type(&::UnitBaseNavigator::TestRoute)
                , default_TestRoute_function_type(&UnitBaseNavigator_wrapper::default_TestRoute)
                , ( bp::arg("vStartPos"), bp::arg("vEndPos") ) );
        
        }
        { //::UnitBaseNavigator::Update
        
            typedef void ( ::UnitBaseNavigator::*Update_function_type )( ::UnitBaseMoveCommand & ) ;
            typedef void ( UnitBaseNavigator_wrapper::*default_Update_function_type )( ::UnitBaseMoveCommand & ) ;
            
            UnitBaseNavigator_exposer.def( 
                "Update"
                , Update_function_type(&::UnitBaseNavigator::Update)
                , default_Update_function_type(&UnitBaseNavigator_wrapper::default_Update)
                , ( bp::arg("mv") ) );
        
        }
        { //::UnitBaseNavigator::UpdateGoalInRange
        
            typedef void ( ::UnitBaseNavigator::*UpdateGoalInRange_function_type )( float,float,::UnitBasePath * ) ;
            typedef void ( UnitBaseNavigator_wrapper::*default_UpdateGoalInRange_function_type )( float,float,::UnitBasePath * ) ;
            
            UnitBaseNavigator_exposer.def( 
                "UpdateGoalInRange"
                , UpdateGoalInRange_function_type(&::UnitBaseNavigator::UpdateGoalInRange)
                , default_UpdateGoalInRange_function_type(&UnitBaseNavigator_wrapper::default_UpdateGoalInRange)
                , ( bp::arg("maxrange"), bp::arg("minrange")=0.0f, bp::arg("path")=bp::object() ) );
        
        }
        { //::UnitBaseNavigator::UpdateGoalTarget
        
            typedef void ( ::UnitBaseNavigator::*UpdateGoalTarget_function_type )( ::CBaseEntity *,::UnitBasePath * ) ;
            typedef void ( UnitBaseNavigator_wrapper::*default_UpdateGoalTarget_function_type )( ::CBaseEntity *,::UnitBasePath * ) ;
            
            UnitBaseNavigator_exposer.def( 
                "UpdateGoalTarget"
                , UpdateGoalTarget_function_type(&::UnitBaseNavigator::UpdateGoalTarget)
                , default_UpdateGoalTarget_function_type(&UnitBaseNavigator_wrapper::default_UpdateGoalTarget)
                , ( bp::arg("target"), bp::arg("path")=bp::object() ) );
        
        }
        { //::UnitBaseNavigator::UpdateIdealAngles
        
            typedef void ( ::UnitBaseNavigator::*UpdateIdealAngles_function_type )( ::UnitBaseMoveCommand &,::Vector * ) ;
            typedef void ( UnitBaseNavigator_wrapper::*default_UpdateIdealAngles_function_type )( ::UnitBaseMoveCommand &,::Vector * ) ;
            
            UnitBaseNavigator_exposer.def( 
                "UpdateIdealAngles"
                , UpdateIdealAngles_function_type(&::UnitBaseNavigator::UpdateIdealAngles)
                , default_UpdateIdealAngles_function_type(&UnitBaseNavigator_wrapper::default_UpdateIdealAngles)
                , ( bp::arg("MoveCommand"), bp::arg("pathdir")=bp::object() ) );
        
        }
        UnitBaseNavigator_exposer.def_readwrite( "noavoid", &UnitBaseNavigator::m_bNoAvoid );
        UnitBaseNavigator_exposer.def_readwrite( "nopathvelocity", &UnitBaseNavigator::m_bNoPathVelocity );
        UnitBaseNavigator_exposer.def_readwrite( "facingcone", &UnitBaseNavigator::m_fFacingCone );
        UnitBaseNavigator_exposer.def_readwrite( "idealyawtolerance", &UnitBaseNavigator::m_fIdealYawTolerance );
        UnitBaseNavigator_exposer.def_readwrite( "forcegoalvelocity", &UnitBaseNavigator::m_vForceGoalVelocity );
        { //property "path"[fget=::UnitBaseNavigator::PyGetPath, fset=::UnitBaseNavigator::SetPath]
        
            typedef ::boost::python::object ( ::UnitBaseNavigator::*fget )(  ) ;
            typedef void ( ::UnitBaseNavigator::*fset )( ::boost::python::object ) ;
            
            UnitBaseNavigator_exposer.add_property( 
                "path"
                , fget( &::UnitBaseNavigator::PyGetPath )
                , fset( &::UnitBaseNavigator::SetPath ) );
        
        }
        { //property "idealyaw"[fget=::UnitBaseNavigator::GetIdealYaw, fset=::UnitBaseNavigator::SetIdealYaw]
        
            typedef float ( ::UnitBaseNavigator::*fget )(  ) ;
            typedef void ( ::UnitBaseNavigator::*fset )( float ) ;
            
            UnitBaseNavigator_exposer.add_property( 
                "idealyaw"
                , fget( &::UnitBaseNavigator::GetIdealYaw )
                , fset( &::UnitBaseNavigator::SetIdealYaw ) );
        
        }
        { //property "facingtarget"[fget=::UnitBaseNavigator::GetFacingTarget, fset=::UnitBaseNavigator::SetFacingTarget]
        
            typedef ::CBaseEntity * ( ::UnitBaseNavigator::*fget )(  ) ;
            typedef void ( ::UnitBaseNavigator::*fset )( ::CBaseEntity * ) ;
            
            UnitBaseNavigator_exposer.add_property( 
                "facingtarget"
                , bp::make_function( 
                      fget( &::UnitBaseNavigator::GetFacingTarget )
                    , bp::return_value_policy< bp::return_by_value >() ) 
                , fset( &::UnitBaseNavigator::SetFacingTarget ) );
        
        }
        { //property "facingtargetpos"[fget=::UnitBaseNavigator::GetFacingTargetPos, fset=::UnitBaseNavigator::SetFacingTargetPos]
        
            typedef ::Vector const & ( ::UnitBaseNavigator::*fget )(  ) ;
            typedef void ( ::UnitBaseNavigator::*fset )( ::Vector & ) ;
            
            UnitBaseNavigator_exposer.add_property( 
                "facingtargetpos"
                , bp::make_function( 
                      fget( &::UnitBaseNavigator::GetFacingTargetPos )
                    , bp::return_value_policy< bp::copy_const_reference >() ) 
                , fset( &::UnitBaseNavigator::SetFacingTargetPos ) );
        
        }
    }

    { //::UnitBaseAirNavigator
        typedef bp::class_< UnitBaseAirNavigator_wrapper, bp::bases< UnitBaseNavigator >, boost::noncopyable > UnitBaseAirNavigator_exposer_t;
        UnitBaseAirNavigator_exposer_t UnitBaseAirNavigator_exposer = UnitBaseAirNavigator_exposer_t( "UnitBaseAirNavigator", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitBaseAirNavigator_scope( UnitBaseAirNavigator_exposer );
        bp::implicitly_convertible< bp::object, UnitBaseAirNavigator >();
        { //::UnitBaseAirNavigator::TestRoute
        
            typedef bool ( ::UnitBaseAirNavigator::*TestRoute_function_type )( ::Vector const &,::Vector const & ) ;
            typedef bool ( UnitBaseAirNavigator_wrapper::*default_TestRoute_function_type )( ::Vector const &,::Vector const & ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "TestRoute"
                , TestRoute_function_type(&::UnitBaseAirNavigator::TestRoute)
                , default_TestRoute_function_type(&UnitBaseAirNavigator_wrapper::default_TestRoute)
                , ( bp::arg("vStartPos"), bp::arg("vEndPos") ) );
        
        }
        { //::UnitBaseNavigator::CalcMove
        
            typedef void ( ::UnitBaseNavigator::*CalcMove_function_type )( ::UnitBaseMoveCommand &,::QAngle,float ) ;
            typedef void ( UnitBaseAirNavigator_wrapper::*default_CalcMove_function_type )( ::UnitBaseMoveCommand &,::QAngle,float ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "CalcMove"
                , CalcMove_function_type(&::UnitBaseNavigator::CalcMove)
                , default_CalcMove_function_type(&UnitBaseAirNavigator_wrapper::default_CalcMove)
                , ( bp::arg("MoveCommand"), bp::arg("angles"), bp::arg("speed") ) );
        
        }
        { //::UnitBaseNavigator::DrawDebugInfo
        
            typedef void ( ::UnitBaseNavigator::*DrawDebugInfo_function_type )(  ) ;
            typedef void ( UnitBaseAirNavigator_wrapper::*default_DrawDebugInfo_function_type )(  ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "DrawDebugInfo"
                , DrawDebugInfo_function_type(&::UnitBaseNavigator::DrawDebugInfo)
                , default_DrawDebugInfo_function_type(&UnitBaseAirNavigator_wrapper::default_DrawDebugInfo) );
        
        }
        { //::UnitBaseNavigator::DrawDebugRouteOverlay
        
            typedef void ( ::UnitBaseNavigator::*DrawDebugRouteOverlay_function_type )(  ) ;
            typedef void ( UnitBaseAirNavigator_wrapper::*default_DrawDebugRouteOverlay_function_type )(  ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "DrawDebugRouteOverlay"
                , DrawDebugRouteOverlay_function_type(&::UnitBaseNavigator::DrawDebugRouteOverlay)
                , default_DrawDebugRouteOverlay_function_type(&UnitBaseAirNavigator_wrapper::default_DrawDebugRouteOverlay) );
        
        }
        { //::UnitBaseNavigator::GetGoalDistance
        
            typedef float ( ::UnitBaseNavigator::*GetGoalDistance_function_type )(  ) ;
            typedef float ( UnitBaseAirNavigator_wrapper::*default_GetGoalDistance_function_type )(  ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "GetGoalDistance"
                , GetGoalDistance_function_type(&::UnitBaseNavigator::GetGoalDistance)
                , default_GetGoalDistance_function_type(&UnitBaseAirNavigator_wrapper::default_GetGoalDistance) );
        
        }
        { //::UnitBaseNavigator::RegenerateConsiderList
        
            typedef void ( ::UnitBaseNavigator::*RegenerateConsiderList_function_type )( ::Vector &,::CheckGoalStatus_t ) ;
            typedef void ( UnitBaseAirNavigator_wrapper::*default_RegenerateConsiderList_function_type )( ::Vector &,::CheckGoalStatus_t ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "RegenerateConsiderList"
                , RegenerateConsiderList_function_type(&::UnitBaseNavigator::RegenerateConsiderList)
                , default_RegenerateConsiderList_function_type(&UnitBaseAirNavigator_wrapper::default_RegenerateConsiderList)
                , ( bp::arg("vPathDir"), bp::arg("GoalStatus") ) );
        
        }
        { //::UnitBaseNavigator::Reset
        
            typedef void ( ::UnitBaseNavigator::*Reset_function_type )(  ) ;
            typedef void ( UnitBaseAirNavigator_wrapper::*default_Reset_function_type )(  ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "Reset"
                , Reset_function_type(&::UnitBaseNavigator::Reset)
                , default_Reset_function_type(&UnitBaseAirNavigator_wrapper::default_Reset) );
        
        }
        { //::UnitBaseNavigator::SetGoal
        
            typedef bool ( ::UnitBaseNavigator::*SetGoal_function_type )( ::Vector &,float,int,bool ) ;
            typedef bool ( UnitBaseAirNavigator_wrapper::*default_SetGoal_function_type )( ::Vector &,float,int,bool ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "SetGoal"
                , SetGoal_function_type(&::UnitBaseNavigator::SetGoal)
                , default_SetGoal_function_type(&UnitBaseAirNavigator_wrapper::default_SetGoal)
                , ( bp::arg("destination"), bp::arg("goaltolerance")=6.4e+1f, bp::arg("goalflags")=(int)(0), bp::arg("avoidenemies")=(bool)(true) ) );
        
        }
        { //::UnitBaseNavigator::SetGoalInRange
        
            typedef bool ( ::UnitBaseNavigator::*SetGoalInRange_function_type )( ::Vector &,float,float,float,int,bool ) ;
            typedef bool ( UnitBaseAirNavigator_wrapper::*default_SetGoalInRange_function_type )( ::Vector &,float,float,float,int,bool ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "SetGoalInRange"
                , SetGoalInRange_function_type(&::UnitBaseNavigator::SetGoalInRange)
                , default_SetGoalInRange_function_type(&UnitBaseAirNavigator_wrapper::default_SetGoalInRange)
                , ( bp::arg("destination"), bp::arg("maxrange"), bp::arg("minrange")=0.0f, bp::arg("goaltolerance")=0.0f, bp::arg("goalflags")=(int)(0), bp::arg("avoidenemies")=(bool)(true) ) );
        
        }
        { //::UnitBaseNavigator::SetGoalTarget
        
            typedef bool ( ::UnitBaseNavigator::*SetGoalTarget_function_type )( ::CBaseEntity *,float,int,bool ) ;
            typedef bool ( UnitBaseAirNavigator_wrapper::*default_SetGoalTarget_function_type )( ::CBaseEntity *,float,int,bool ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "SetGoalTarget"
                , SetGoalTarget_function_type(&::UnitBaseNavigator::SetGoalTarget)
                , default_SetGoalTarget_function_type(&UnitBaseAirNavigator_wrapper::default_SetGoalTarget)
                , ( bp::arg("pTarget"), bp::arg("goaltolerance")=6.4e+1f, bp::arg("goalflags")=(int)(0), bp::arg("avoidenemies")=(bool)(true) ) );
        
        }
        { //::UnitBaseNavigator::SetGoalTargetInRange
        
            typedef bool ( ::UnitBaseNavigator::*SetGoalTargetInRange_function_type )( ::CBaseEntity *,float,float,float,int,bool ) ;
            typedef bool ( UnitBaseAirNavigator_wrapper::*default_SetGoalTargetInRange_function_type )( ::CBaseEntity *,float,float,float,int,bool ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "SetGoalTargetInRange"
                , SetGoalTargetInRange_function_type(&::UnitBaseNavigator::SetGoalTargetInRange)
                , default_SetGoalTargetInRange_function_type(&UnitBaseAirNavigator_wrapper::default_SetGoalTargetInRange)
                , ( bp::arg("pTarget"), bp::arg("maxrange"), bp::arg("minrange")=0.0f, bp::arg("goaltolerance")=0.0f, bp::arg("goalflags")=(int)(0), bp::arg("avoidenemies")=(bool)(true) ) );
        
        }
        { //::UnitBaseNavigator::StopMoving
        
            typedef void ( ::UnitBaseNavigator::*StopMoving_function_type )(  ) ;
            typedef void ( UnitBaseAirNavigator_wrapper::*default_StopMoving_function_type )(  ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "StopMoving"
                , StopMoving_function_type(&::UnitBaseNavigator::StopMoving)
                , default_StopMoving_function_type(&UnitBaseAirNavigator_wrapper::default_StopMoving) );
        
        }
        { //::UnitBaseNavigator::UpdateGoalInRange
        
            typedef void ( ::UnitBaseNavigator::*UpdateGoalInRange_function_type )( float,float,::UnitBasePath * ) ;
            typedef void ( UnitBaseAirNavigator_wrapper::*default_UpdateGoalInRange_function_type )( float,float,::UnitBasePath * ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "UpdateGoalInRange"
                , UpdateGoalInRange_function_type(&::UnitBaseNavigator::UpdateGoalInRange)
                , default_UpdateGoalInRange_function_type(&UnitBaseAirNavigator_wrapper::default_UpdateGoalInRange)
                , ( bp::arg("maxrange"), bp::arg("minrange")=0.0f, bp::arg("path")=bp::object() ) );
        
        }
        { //::UnitBaseNavigator::UpdateGoalTarget
        
            typedef void ( ::UnitBaseNavigator::*UpdateGoalTarget_function_type )( ::CBaseEntity *,::UnitBasePath * ) ;
            typedef void ( UnitBaseAirNavigator_wrapper::*default_UpdateGoalTarget_function_type )( ::CBaseEntity *,::UnitBasePath * ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "UpdateGoalTarget"
                , UpdateGoalTarget_function_type(&::UnitBaseNavigator::UpdateGoalTarget)
                , default_UpdateGoalTarget_function_type(&UnitBaseAirNavigator_wrapper::default_UpdateGoalTarget)
                , ( bp::arg("target"), bp::arg("path")=bp::object() ) );
        
        }
        { //::UnitBaseNavigator::UpdateIdealAngles
        
            typedef void ( ::UnitBaseNavigator::*UpdateIdealAngles_function_type )( ::UnitBaseMoveCommand &,::Vector * ) ;
            typedef void ( UnitBaseAirNavigator_wrapper::*default_UpdateIdealAngles_function_type )( ::UnitBaseMoveCommand &,::Vector * ) ;
            
            UnitBaseAirNavigator_exposer.def( 
                "UpdateIdealAngles"
                , UpdateIdealAngles_function_type(&::UnitBaseNavigator::UpdateIdealAngles)
                , default_UpdateIdealAngles_function_type(&UnitBaseAirNavigator_wrapper::default_UpdateIdealAngles)
                , ( bp::arg("MoveCommand"), bp::arg("pathdir")=bp::object() ) );
        
        }
        { //property "testroutemask"[fget=::UnitBaseAirNavigator::GetTestRouteMask, fset=::UnitBaseAirNavigator::SetTestRouteMask]
        
            typedef int ( ::UnitBaseAirNavigator::*fget )(  ) ;
            typedef void ( ::UnitBaseAirNavigator::*fset )( int ) ;
            
            UnitBaseAirNavigator_exposer.add_property( 
                "testroutemask"
                , fget( &::UnitBaseAirNavigator::GetTestRouteMask )
                , fset( &::UnitBaseAirNavigator::SetTestRouteMask ) );
        
        }
        { //property "usesimplifiedroutebuilding"[fget=::UnitBaseAirNavigator::GetUseSimplifiedRouteBuilding, fset=::UnitBaseAirNavigator::SetUseSimplifiedRouteBuilding]
        
            typedef int ( ::UnitBaseAirNavigator::*fget )(  ) ;
            typedef void ( ::UnitBaseAirNavigator::*fset )( bool ) ;
            
            UnitBaseAirNavigator_exposer.add_property( 
                "usesimplifiedroutebuilding"
                , fget( &::UnitBaseAirNavigator::GetUseSimplifiedRouteBuilding )
                , fset( &::UnitBaseAirNavigator::SetUseSimplifiedRouteBuilding ) );
        
        }
    }

    { //::UnitBaseMoveCommand
        typedef bp::class_< UnitBaseMoveCommand > UnitBaseMoveCommand_exposer_t;
        UnitBaseMoveCommand_exposer_t UnitBaseMoveCommand_exposer = UnitBaseMoveCommand_exposer_t( "UnitBaseMoveCommand", bp::init< >() );
        bp::scope UnitBaseMoveCommand_scope( UnitBaseMoveCommand_exposer );
        { //::UnitBaseMoveCommand::Clear
        
            typedef void ( ::UnitBaseMoveCommand::*Clear_function_type )(  ) ;
            
            UnitBaseMoveCommand_exposer.def( 
                "Clear"
                , Clear_function_type( &::UnitBaseMoveCommand::Clear ) );
        
        }
        UnitBaseMoveCommand_exposer.def_readwrite( "blocker_dir", &UnitBaseMoveCommand::blocker_dir );
        UnitBaseMoveCommand_exposer.def_readwrite( "blocker_hitpos", &UnitBaseMoveCommand::blocker_hitpos );
        UnitBaseMoveCommand_exposer.def_readwrite( "forwardmove", &UnitBaseMoveCommand::forwardmove );
        UnitBaseMoveCommand_exposer.def_readwrite( "idealviewangles", &UnitBaseMoveCommand::idealviewangles );
        UnitBaseMoveCommand_exposer.def_readwrite( "interval", &UnitBaseMoveCommand::interval );
        UnitBaseMoveCommand_exposer.def_readwrite( "jump", &UnitBaseMoveCommand::jump );
        UnitBaseMoveCommand_exposer.def_readwrite( "maxspeed", &UnitBaseMoveCommand::maxspeed );
        UnitBaseMoveCommand_exposer.def_readwrite( "origin", &UnitBaseMoveCommand::origin );
        UnitBaseMoveCommand_exposer.def_readwrite( "outstepheight", &UnitBaseMoveCommand::outstepheight );
        UnitBaseMoveCommand_exposer.def_readwrite( "outwishvel", &UnitBaseMoveCommand::outwishvel );
        UnitBaseMoveCommand_exposer.def_readwrite( "sidemove", &UnitBaseMoveCommand::sidemove );
        UnitBaseMoveCommand_exposer.def_readwrite( "stopdistance", &UnitBaseMoveCommand::stopdistance );
        UnitBaseMoveCommand_exposer.def_readwrite( "totaldistance", &UnitBaseMoveCommand::totaldistance );
        UnitBaseMoveCommand_exposer.def_readwrite( "upmove", &UnitBaseMoveCommand::upmove );
        UnitBaseMoveCommand_exposer.def_readwrite( "velocity", &UnitBaseMoveCommand::velocity );
        UnitBaseMoveCommand_exposer.def_readwrite( "viewangles", &UnitBaseMoveCommand::viewangles );
        UnitBaseMoveCommand_exposer.def_readwrite( "yawspeed", &UnitBaseMoveCommand::yawspeed );
        { //property "blocker"[fget=::UnitBaseMoveCommand::GetBlocker]
        
            typedef ::CBaseEntity * ( ::UnitBaseMoveCommand::*fget )(  ) ;
            
            UnitBaseMoveCommand_exposer.add_property( 
                "blocker"
                , bp::make_function( 
                      fget( &::UnitBaseMoveCommand::GetBlocker )
                    , bp::return_value_policy< bp::return_by_value >() )  );
        
        }
    }

    { //::UnitBaseSense
        typedef bp::class_< UnitBaseSense, bp::bases< UnitComponent >, boost::noncopyable > UnitBaseSense_exposer_t;
        UnitBaseSense_exposer_t UnitBaseSense_exposer = UnitBaseSense_exposer_t( "UnitBaseSense", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitBaseSense_scope( UnitBaseSense_exposer );
        bp::implicitly_convertible< bp::object, UnitBaseSense >();
        { //::UnitBaseSense::CountEnemiesInRange
        
            typedef int ( ::UnitBaseSense::*CountEnemiesInRange_function_type )( float ) ;
            
            UnitBaseSense_exposer.def( 
                "CountEnemiesInRange"
                , CountEnemiesInRange_function_type( &::UnitBaseSense::CountEnemiesInRange )
                , ( bp::arg("range") ) );
        
        }
        { //::UnitBaseSense::CountOthersInRange
        
            typedef int ( ::UnitBaseSense::*CountOthersInRange_function_type )( float ) ;
            
            UnitBaseSense_exposer.def( 
                "CountOthersInRange"
                , CountOthersInRange_function_type( &::UnitBaseSense::CountOthersInRange )
                , ( bp::arg("range") ) );
        
        }
        { //::UnitBaseSense::CountSeen
        
            typedef int ( ::UnitBaseSense::*CountSeen_function_type )(  ) ;
            
            UnitBaseSense_exposer.def( 
                "CountSeen"
                , CountSeen_function_type( &::UnitBaseSense::CountSeen ) );
        
        }
        { //::UnitBaseSense::CountSeenEnemy
        
            typedef int ( ::UnitBaseSense::*CountSeenEnemy_function_type )(  ) ;
            
            UnitBaseSense_exposer.def( 
                "CountSeenEnemy"
                , CountSeenEnemy_function_type( &::UnitBaseSense::CountSeenEnemy ) );
        
        }
        { //::UnitBaseSense::CountSeenOther
        
            typedef int ( ::UnitBaseSense::*CountSeenOther_function_type )(  ) ;
            
            UnitBaseSense_exposer.def( 
                "CountSeenOther"
                , CountSeenOther_function_type( &::UnitBaseSense::CountSeenOther ) );
        
        }
        { //::UnitBaseSense::ForcePerformSensing
        
            typedef void ( ::UnitBaseSense::*ForcePerformSensing_function_type )(  ) ;
            
            UnitBaseSense_exposer.def( 
                "ForcePerformSensing"
                , ForcePerformSensing_function_type( &::UnitBaseSense::ForcePerformSensing ) );
        
        }
        { //::UnitBaseSense::GetNearestEnemy
        
            typedef ::CBaseEntity * ( ::UnitBaseSense::*GetNearestEnemy_function_type )(  ) ;
            
            UnitBaseSense_exposer.def( 
                "GetNearestEnemy"
                , GetNearestEnemy_function_type( &::UnitBaseSense::GetNearestEnemy )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::UnitBaseSense::GetNearestOther
        
            typedef ::CBaseEntity * ( ::UnitBaseSense::*GetNearestOther_function_type )(  ) ;
            
            UnitBaseSense_exposer.def( 
                "GetNearestOther"
                , GetNearestOther_function_type( &::UnitBaseSense::GetNearestOther )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::UnitBaseSense::Look
        
            typedef void ( ::UnitBaseSense::*Look_function_type )( int ) ;
            
            UnitBaseSense_exposer.def( 
                "Look"
                , Look_function_type( &::UnitBaseSense::Look )
                , ( bp::arg("iDistance") ) );
        
        }
        { //::UnitBaseSense::PerformSensing
        
            typedef void ( ::UnitBaseSense::*PerformSensing_function_type )(  ) ;
            
            UnitBaseSense_exposer.def( 
                "PerformSensing"
                , PerformSensing_function_type( &::UnitBaseSense::PerformSensing ) );
        
        }
        { //::UnitBaseSense::PyGetEnemies
        
            typedef ::boost::python::list ( ::UnitBaseSense::*GetEnemies_function_type )( char const * ) ;
            
            UnitBaseSense_exposer.def( 
                "GetEnemies"
                , GetEnemies_function_type( &::UnitBaseSense::PyGetEnemies )
                , ( bp::arg("unittype")=bp::object() ) );
        
        }
        { //::UnitBaseSense::PyGetEnemy
        
            typedef ::boost::python::object ( ::UnitBaseSense::*GetEnemy_function_type )( int ) ;
            
            UnitBaseSense_exposer.def( 
                "GetEnemy"
                , GetEnemy_function_type( &::UnitBaseSense::PyGetEnemy )
                , ( bp::arg("idx") ) );
        
        }
        { //::UnitBaseSense::PyGetOther
        
            typedef ::boost::python::object ( ::UnitBaseSense::*GetOther_function_type )( int ) ;
            
            UnitBaseSense_exposer.def( 
                "GetOther"
                , GetOther_function_type( &::UnitBaseSense::PyGetOther )
                , ( bp::arg("idx") ) );
        
        }
        { //::UnitBaseSense::PyGetOthers
        
            typedef ::boost::python::list ( ::UnitBaseSense::*GetOthers_function_type )( char const * ) ;
            
            UnitBaseSense_exposer.def( 
                "GetOthers"
                , GetOthers_function_type( &::UnitBaseSense::PyGetOthers )
                , ( bp::arg("unittype")=bp::object() ) );
        
        }
        { //::UnitBaseSense::SetUseLimitedViewCone
        
            typedef void ( ::UnitBaseSense::*SetUseLimitedViewCone_function_type )( bool ) ;
            
            UnitBaseSense_exposer.def( 
                "SetUseLimitedViewCone"
                , SetUseLimitedViewCone_function_type( &::UnitBaseSense::SetUseLimitedViewCone )
                , ( bp::arg("bUseCone") ) );
        
        }
        { //::UnitBaseSense::SetViewCone
        
            typedef void ( ::UnitBaseSense::*SetViewCone_function_type )( float ) ;
            
            UnitBaseSense_exposer.def( 
                "SetViewCone"
                , SetViewCone_function_type( &::UnitBaseSense::SetViewCone )
                , ( bp::arg("fCone") ) );
        
        }
        { //::UnitBaseSense::TestEntity
        
            typedef bool ( ::UnitBaseSense::*TestEntity_function_type )( ::CBaseEntity * ) ;
            
            UnitBaseSense_exposer.def( 
                "TestEntity"
                , TestEntity_function_type( &::UnitBaseSense::TestEntity )
                , ( bp::arg("pEntity") ) );
        
        }
        { //::UnitBaseSense::TestUnit
        
            typedef bool ( ::UnitBaseSense::*TestUnit_function_type )( ::CUnitBase * ) ;
            
            UnitBaseSense_exposer.def( 
                "TestUnit"
                , TestUnit_function_type( &::UnitBaseSense::TestUnit )
                , ( bp::arg("pUnit") ) );
        
        }
        UnitBaseSense_exposer.def_readwrite( "sensedistance", &UnitBaseSense::m_fSenseDistance );
        UnitBaseSense_exposer.def_readwrite( "senserate", &UnitBaseSense::m_fSenseRate );
        { //property "testlos"[fget=::UnitBaseSense::GetTestLOS, fset=::UnitBaseSense::SetTestLOS]
        
            typedef bool ( ::UnitBaseSense::*fget )(  ) ;
            typedef void ( ::UnitBaseSense::*fset )( bool ) ;
            
            UnitBaseSense_exposer.add_property( 
                "testlos"
                , fget( &::UnitBaseSense::GetTestLOS )
                , fset( &::UnitBaseSense::SetTestLOS ) );
        
        }
    }

    { //::UnitExpresser
        typedef bp::class_< UnitExpresser_wrapper, bp::bases< UnitComponent, CAI_Expresser >, boost::noncopyable > UnitExpresser_exposer_t;
        UnitExpresser_exposer_t UnitExpresser_exposer = UnitExpresser_exposer_t( "UnitExpresser", bp::init< bp::object >(( bp::arg("outer") )) );
        bp::scope UnitExpresser_scope( UnitExpresser_exposer );
        bp::implicitly_convertible< bp::object, UnitExpresser >();
        { //::CAI_Expresser::DumpHistories
        
            typedef void ( UnitExpresser_wrapper::*DumpHistories_function_type )(  ) ;
            
            UnitExpresser_exposer.def( 
                "DumpHistories"
                , DumpHistories_function_type( &UnitExpresser_wrapper::DumpHistories ) );
        
        }
        { //::CAI_Expresser::IsSpeaking
        
            typedef bool ( ::CAI_Expresser::*IsSpeaking_function_type )(  ) ;
            typedef bool ( UnitExpresser_wrapper::*default_IsSpeaking_function_type )(  ) ;
            
            UnitExpresser_exposer.def( 
                "IsSpeaking"
                , IsSpeaking_function_type(&::CAI_Expresser::IsSpeaking)
                , default_IsSpeaking_function_type(&UnitExpresser_wrapper::default_IsSpeaking) );
        
        }
        { //::CAI_Expresser::OnSpeechFinished
        
            typedef void ( ::CAI_Expresser::*OnSpeechFinished_function_type )(  ) ;
            typedef void ( UnitExpresser_wrapper::*default_OnSpeechFinished_function_type )(  ) ;
            
            UnitExpresser_exposer.def( 
                "OnSpeechFinished"
                , OnSpeechFinished_function_type(&::CAI_Expresser::OnSpeechFinished)
                , default_OnSpeechFinished_function_type(&UnitExpresser_wrapper::default_OnSpeechFinished) );
        
        }
        { //::CAI_Expresser::SpeakAutoGeneratedScene
        
            typedef bool ( UnitExpresser_wrapper::*SpeakAutoGeneratedScene_function_type )( char const *,float ) ;
            
            UnitExpresser_exposer.def( 
                "SpeakAutoGeneratedScene"
                , SpeakAutoGeneratedScene_function_type( &UnitExpresser_wrapper::SpeakAutoGeneratedScene )
                , ( bp::arg("soundname"), bp::arg("delay") ) );
        
        }
        { //::CAI_Expresser::SpeakDispatchResponse
        
            typedef bool ( ::CAI_Expresser::*SpeakDispatchResponse_function_type )( ::AIConcept_t &,::AI_Response *,::ResponseRules::CriteriaSet *,::IRecipientFilter * ) ;
            typedef bool ( UnitExpresser_wrapper::*default_SpeakDispatchResponse_function_type )( ::AIConcept_t &,::AI_Response *,::ResponseRules::CriteriaSet *,::IRecipientFilter * ) ;
            
            UnitExpresser_exposer.def( 
                "SpeakDispatchResponse"
                , SpeakDispatchResponse_function_type(&::CAI_Expresser::SpeakDispatchResponse)
                , default_SpeakDispatchResponse_function_type(&UnitExpresser_wrapper::default_SpeakDispatchResponse)
                , ( bp::arg("concept"), bp::arg("response"), bp::arg("criteria"), bp::arg("filter")=bp::object() ) );
        
        }
        { //::CAI_Expresser::SpeakRawScene
        
            typedef bool ( UnitExpresser_wrapper::*SpeakRawScene_function_type )( char const *,float,::AI_Response *,::IRecipientFilter * ) ;
            
            UnitExpresser_exposer.def( 
                "SpeakRawScene"
                , SpeakRawScene_function_type( &UnitExpresser_wrapper::SpeakRawScene )
                , ( bp::arg("pszScene"), bp::arg("delay"), bp::arg("response"), bp::arg("filter")=bp::object() ) );
        
        }
        { //::CAI_Expresser::SpeakRawSentence
        
            typedef int ( ::CAI_Expresser::*SpeakRawSentence_function_type )( char const *,float,float,::soundlevel_t,::CBaseEntity * ) ;
            typedef int ( UnitExpresser_wrapper::*default_SpeakRawSentence_function_type )( char const *,float,float,::soundlevel_t,::CBaseEntity * ) ;
            
            UnitExpresser_exposer.def( 
                "SpeakRawSentence"
                , SpeakRawSentence_function_type(&::CAI_Expresser::SpeakRawSentence)
                , default_SpeakRawSentence_function_type(&UnitExpresser_wrapper::default_SpeakRawSentence)
                , ( bp::arg("pszSentence"), bp::arg("delay"), bp::arg("volume")=1.0e+0f, bp::arg("soundlevel")=::SNDLVL_80dB, bp::arg("pListener")=bp::object() ) );
        
        }
    }

    { //::UnitComputePathDirection
    
        typedef float ( *UnitComputePathDirection_function_type )( ::Vector const &,::Vector const &,::Vector & );
        
        bp::def( 
            "UnitComputePathDirection"
            , UnitComputePathDirection_function_type( &::UnitComputePathDirection )
            , ( bp::arg("start"), bp::arg("end"), bp::arg("pDirection") ) );
    
    }

    { //::Unit_ClampYaw
    
        typedef float ( *Unit_ClampYaw_function_type )( float,float,float,float );
        
        bp::def( 
            "Unit_ClampYaw"
            , Unit_ClampYaw_function_type( &::Unit_ClampYaw )
            , ( bp::arg("yawSpeedPerSec"), bp::arg("current"), bp::arg("target"), bp::arg("time") ) );
    
    }

    { //::VecCheckThrowTolerance
    
        typedef ::Vector ( *VecCheckThrowTolerance_function_type )( ::CBaseEntity *,::Vector const &,::Vector,float,float,int );
        
        bp::def( 
            "VecCheckThrowTolerance"
            , VecCheckThrowTolerance_function_type( &::VecCheckThrowTolerance )
            , ( bp::arg("pEdict"), bp::arg("vecSpot1"), bp::arg("vecSpot2"), bp::arg("flSpeed"), bp::arg("flTolerance"), bp::arg("iCollisionGroup") ) );
    
    }
}

#endif // CLIENT_DLL


