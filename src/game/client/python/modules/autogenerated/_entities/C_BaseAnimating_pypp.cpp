// This file has been generated by Py++.

#include "cbase.h"
// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__convenience.pypp.hpp"
#include "__call_policies.pypp.hpp"
#include "videocfg/videocfg.h"
#include "cbase.h"
#include "takedamageinfo.h"
#include "c_baseanimating.h"
#include "c_baseanimatingoverlay.h"
#include "c_baseflex.h"
#include "c_basecombatcharacter.h"
#include "basegrenade_shared.h"
#include "c_baseplayer.h"
#include "c_hl2wars_player.h"
#include "unit_base_shared.h"
#include "wars_func_unit.h"
#include "c_playerresource.h"
#include "sprite.h"
#include "SpriteTrail.h"
#include "c_smoke_trail.h"
#include "c_wars_weapon.h"
#include "c_basetoggle.h"
#include "c_triggers.h"
#include "shared_classnames.h"
#include "npcevent.h"
#include "studio.h"
#include "src_python_entities.h"
#include "isaverestore.h"
#include "saverestore.h"
#include "mapentities_shared.h"
#include "vcollide_parse.h"
#include "hl2wars_player_shared.h"
#include "imouse.h"
#include "props_shared.h"
#include "beam_shared.h"
#include "basecombatweapon_shared.h"
#include "wars_mapboundary.h"
#include "src_python_converters_ents.h"
#include "src_python.h"
#include "tier0/memdbgon.h"
#include "C_BaseAnimating_pypp.hpp"

namespace bp = boost::python;

struct C_BaseAnimating_wrapper : C_BaseAnimating, bp::wrapper< C_BaseAnimating > {

    C_BaseAnimating_wrapper( )
    : C_BaseAnimating( )
      , bp::wrapper< C_BaseAnimating >(){
        // null constructor
    
    }

    virtual ::CollideType_t GetCollideType(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetCollideType: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetCollideType(  ) of Class: C_BaseAnimating\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetCollideType = this->get_override( "GetCollideType" );
        if( func_GetCollideType.ptr() != Py_None )
            try {
                return func_GetCollideType(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_BaseAnimating::GetCollideType(  );
            }
        else
            return this->C_BaseAnimating::GetCollideType(  );
    }
    
    ::CollideType_t default_GetCollideType(  ) {
        return C_BaseAnimating::GetCollideType( );
    }

    static boost::python::tuple GetPoseParameterRange( ::C_BaseAnimating & inst, int iPoseParameter ){
        float minValue2;
        float maxValue2;
        bool result = inst.GetPoseParameterRange(iPoseParameter, minValue2, maxValue2);
        return bp::make_tuple( result, minValue2, maxValue2 );
    }

    virtual void OnDataChanged( ::DataUpdateType_t updateType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnDataChanged: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnDataChanged( updateType ) of Class: C_BaseAnimating\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnDataChanged = this->get_override( "OnDataChanged" );
        if( func_OnDataChanged.ptr() != Py_None )
            try {
                func_OnDataChanged( updateType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseAnimating::OnDataChanged( updateType );
            }
        else
            this->C_BaseAnimating::OnDataChanged( updateType );
    }
    
    void default_OnDataChanged( ::DataUpdateType_t updateType ) {
        C_BaseAnimating::OnDataChanged( updateType );
    }

    virtual void PyOnNewModel(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnNewModel: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PyOnNewModel(  ) of Class: C_BaseAnimating\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnNewModel = this->get_override( "OnNewModel" );
        if( func_OnNewModel.ptr() != Py_None )
            try {
                func_OnNewModel(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseAnimating::PyOnNewModel(  );
            }
        else
            this->C_BaseAnimating::PyOnNewModel(  );
    }
    
    void default_OnNewModel(  ) {
        C_BaseAnimating::PyOnNewModel( );
    }

    virtual bool Simulate(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Simulate: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Simulate(  ) of Class: C_BaseAnimating\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Simulate = this->get_override( "Simulate" );
        if( func_Simulate.ptr() != Py_None )
            try {
                return func_Simulate(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_BaseAnimating::Simulate(  );
            }
        else
            return this->C_BaseAnimating::Simulate(  );
    }
    
    bool default_Simulate(  ) {
        return C_BaseAnimating::Simulate( );
    }

    virtual void Activate(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Activate: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Activate(  ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Activate = this->get_override( "Activate" );
        if( func_Activate.ptr() != Py_None )
            try {
                func_Activate(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::Activate(  );
            }
        else
            this->C_BaseEntity::Activate(  );
    }
    
    void default_Activate(  ) {
        C_BaseEntity::Activate( );
    }

    void AddToEntityList( ::entity_list_ids_t listId ){
        C_BaseEntity::AddToEntityList( listId );
    }

    virtual void ClientThink(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ClientThink: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ClientThink(  ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ClientThink = this->get_override( "ClientThink" );
        if( func_ClientThink.ptr() != Py_None )
            try {
                func_ClientThink(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::ClientThink(  );
            }
        else
            this->C_BaseEntity::ClientThink(  );
    }
    
    void default_ClientThink(  ) {
        C_BaseEntity::ClientThink( );
    }

    virtual void ComputeWorldSpaceSurroundingBox( ::Vector * pVecWorldMins, ::Vector * pVecWorldMaxs ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ComputeWorldSpaceSurroundingBox: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ComputeWorldSpaceSurroundingBox( boost::python::ptr(pVecWorldMins), boost::python::ptr(pVecWorldMaxs) ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ComputeWorldSpaceSurroundingBox = this->get_override( "ComputeWorldSpaceSurroundingBox" );
        if( func_ComputeWorldSpaceSurroundingBox.ptr() != Py_None )
            try {
                func_ComputeWorldSpaceSurroundingBox( boost::python::ptr(pVecWorldMins), boost::python::ptr(pVecWorldMaxs) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::ComputeWorldSpaceSurroundingBox( boost::python::ptr(pVecWorldMins), boost::python::ptr(pVecWorldMaxs) );
            }
        else
            this->C_BaseEntity::ComputeWorldSpaceSurroundingBox( boost::python::ptr(pVecWorldMins), boost::python::ptr(pVecWorldMaxs) );
    }
    
    void default_ComputeWorldSpaceSurroundingBox( ::Vector * pVecWorldMins, ::Vector * pVecWorldMaxs ) {
        C_BaseEntity::ComputeWorldSpaceSurroundingBox( boost::python::ptr(pVecWorldMins), boost::python::ptr(pVecWorldMaxs) );
    }

    virtual bool CreateVPhysics(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "CreateVPhysics: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling CreateVPhysics(  ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_CreateVPhysics = this->get_override( "CreateVPhysics" );
        if( func_CreateVPhysics.ptr() != Py_None )
            try {
                return func_CreateVPhysics(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_BaseEntity::CreateVPhysics(  );
            }
        else
            return this->C_BaseEntity::CreateVPhysics(  );
    }
    
    bool default_CreateVPhysics(  ) {
        return C_BaseEntity::CreateVPhysics( );
    }

    virtual void DoImpactEffect( ::trace_t & tr, int nDamageType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "DoImpactEffect: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling DoImpactEffect( boost::ref(tr), nDamageType ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_DoImpactEffect = this->get_override( "DoImpactEffect" );
        if( func_DoImpactEffect.ptr() != Py_None )
            try {
                func_DoImpactEffect( boost::ref(tr), nDamageType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::DoImpactEffect( boost::ref(tr), nDamageType );
            }
        else
            this->C_BaseEntity::DoImpactEffect( boost::ref(tr), nDamageType );
    }
    
    void default_DoImpactEffect( ::trace_t & tr, int nDamageType ) {
        C_BaseEntity::DoImpactEffect( boost::ref(tr), nDamageType );
    }

    virtual void EndTouch( ::C_BaseEntity * pOther ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "EndTouch: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling EndTouch( boost::python::ptr(pOther) ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_EndTouch = this->get_override( "EndTouch" );
        if( func_EndTouch.ptr() != Py_None )
            try {
                func_EndTouch( boost::python::ptr(pOther) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::EndTouch( boost::python::ptr(pOther) );
            }
        else
            this->C_BaseEntity::EndTouch( boost::python::ptr(pOther) );
    }
    
    void default_EndTouch( ::C_BaseEntity * pOther ) {
        C_BaseEntity::EndTouch( boost::python::ptr(pOther) );
    }

    virtual ::IMouse * GetIMouse(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetIMouse: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetIMouse(  ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetIMouse = this->get_override( "GetIMouse" );
        if( func_GetIMouse.ptr() != Py_None )
            try {
                return func_GetIMouse(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_BaseEntity::GetIMouse(  );
            }
        else
            return this->C_BaseEntity::GetIMouse(  );
    }
    
    ::IMouse * default_GetIMouse(  ) {
        return C_BaseEntity::GetIMouse( );
    }

    virtual char const * GetTracerType(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetTracerType: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetTracerType(  ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetTracerType = this->get_override( "GetTracerType" );
        if( func_GetTracerType.ptr() != Py_None )
            try {
                return func_GetTracerType(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_BaseEntity::GetTracerType(  );
            }
        else
            return this->C_BaseEntity::GetTracerType(  );
    }
    
    char const * default_GetTracerType(  ) {
        return C_BaseEntity::GetTracerType( );
    }

    virtual bool KeyValue( char const * szKeyName, char const * szValue ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "KeyValue: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling KeyValue( szKeyName, szValue ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_KeyValue = this->get_override( "KeyValue" );
        if( func_KeyValue.ptr() != Py_None )
            try {
                return func_KeyValue( szKeyName, szValue );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_BaseEntity::KeyValue( szKeyName, szValue );
            }
        else
            return this->C_BaseEntity::KeyValue( szKeyName, szValue );
    }
    
    bool default_KeyValue( char const * szKeyName, char const * szValue ) {
        return C_BaseEntity::KeyValue( szKeyName, szValue );
    }

    virtual bool KeyValue( char const * szKeyName, float flValue ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "KeyValue: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling KeyValue( szKeyName, flValue ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_KeyValue = this->get_override( "KeyValue" );
        if( func_KeyValue.ptr() != Py_None )
            try {
                return func_KeyValue( szKeyName, flValue );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_BaseEntity::KeyValue( szKeyName, flValue );
            }
        else
            return this->C_BaseEntity::KeyValue( szKeyName, flValue );
    }
    
    bool default_KeyValue( char const * szKeyName, float flValue ) {
        return C_BaseEntity::KeyValue( szKeyName, flValue );
    }

    virtual bool KeyValue( char const * szKeyName, int nValue ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "KeyValue: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling KeyValue( szKeyName, nValue ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_KeyValue = this->get_override( "KeyValue" );
        if( func_KeyValue.ptr() != Py_None )
            try {
                return func_KeyValue( szKeyName, nValue );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_BaseEntity::KeyValue( szKeyName, nValue );
            }
        else
            return this->C_BaseEntity::KeyValue( szKeyName, nValue );
    }
    
    bool default_KeyValue( char const * szKeyName, int nValue ) {
        return C_BaseEntity::KeyValue( szKeyName, nValue );
    }

    virtual bool KeyValue( char const * szKeyName, ::Vector const & vecValue ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "KeyValue: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling KeyValue( szKeyName, boost::ref(vecValue) ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_KeyValue = this->get_override( "KeyValue" );
        if( func_KeyValue.ptr() != Py_None )
            try {
                return func_KeyValue( szKeyName, boost::ref(vecValue) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_BaseEntity::KeyValue( szKeyName, boost::ref(vecValue) );
            }
        else
            return this->C_BaseEntity::KeyValue( szKeyName, boost::ref(vecValue) );
    }
    
    bool default_KeyValue( char const * szKeyName, ::Vector const & vecValue ) {
        return C_BaseEntity::KeyValue( szKeyName, boost::ref(vecValue) );
    }

    virtual void MakeTracer( ::Vector const & vecTracerSrc, ::trace_t const & tr, int iTracerType ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "MakeTracer: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling MakeTracer( boost::ref(vecTracerSrc), boost::ref(tr), iTracerType ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_MakeTracer = this->get_override( "MakeTracer" );
        if( func_MakeTracer.ptr() != Py_None )
            try {
                func_MakeTracer( boost::ref(vecTracerSrc), boost::ref(tr), iTracerType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::MakeTracer( boost::ref(vecTracerSrc), boost::ref(tr), iTracerType );
            }
        else
            this->C_BaseEntity::MakeTracer( boost::ref(vecTracerSrc), boost::ref(tr), iTracerType );
    }
    
    void default_MakeTracer( ::Vector const & vecTracerSrc, ::trace_t const & tr, int iTracerType ) {
        C_BaseEntity::MakeTracer( boost::ref(vecTracerSrc), boost::ref(tr), iTracerType );
    }

    virtual void OnChangeOwnerNumber( int old_owner_number ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnChangeOwnerNumber: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnChangeOwnerNumber( old_owner_number ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnChangeOwnerNumber = this->get_override( "OnChangeOwnerNumber" );
        if( func_OnChangeOwnerNumber.ptr() != Py_None )
            try {
                func_OnChangeOwnerNumber( old_owner_number );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::OnChangeOwnerNumber( old_owner_number );
            }
        else
            this->C_BaseEntity::OnChangeOwnerNumber( old_owner_number );
    }
    
    void default_OnChangeOwnerNumber( int old_owner_number ) {
        C_BaseEntity::OnChangeOwnerNumber( old_owner_number );
    }

    virtual void OnRestore(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnRestore: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnRestore(  ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnRestore = this->get_override( "OnRestore" );
        if( func_OnRestore.ptr() != Py_None )
            try {
                func_OnRestore(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::OnRestore(  );
            }
        else
            this->C_BaseEntity::OnRestore(  );
    }
    
    void default_OnRestore(  ) {
        C_BaseEntity::OnRestore( );
    }

    virtual void Precache(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Precache: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Precache(  ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Precache = this->get_override( "Precache" );
        if( func_Precache.ptr() != Py_None )
            try {
                func_Precache(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::Precache(  );
            }
        else
            this->C_BaseEntity::Precache(  );
    }
    
    void default_Precache(  ) {
        C_BaseEntity::Precache( );
    }

    virtual void PyNotifyShouldTransmit( ::ShouldTransmitState_t state ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "NotifyShouldTransmit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PyNotifyShouldTransmit( state ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_NotifyShouldTransmit = this->get_override( "NotifyShouldTransmit" );
        if( func_NotifyShouldTransmit.ptr() != Py_None )
            try {
                func_NotifyShouldTransmit( state );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::PyNotifyShouldTransmit( state );
            }
        else
            this->C_BaseEntity::PyNotifyShouldTransmit( state );
    }
    
    void default_NotifyShouldTransmit( ::ShouldTransmitState_t state ) {
        C_BaseEntity::PyNotifyShouldTransmit( state );
    }

    virtual void PyReceiveMessage( ::boost::python::list msg ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ReceiveMessage: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PyReceiveMessage( msg ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ReceiveMessage = this->get_override( "ReceiveMessage" );
        if( func_ReceiveMessage.ptr() != Py_None )
            try {
                func_ReceiveMessage( msg );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::PyReceiveMessage( msg );
            }
        else
            this->C_BaseEntity::PyReceiveMessage( msg );
    }
    
    void default_ReceiveMessage( ::boost::python::list msg ) {
        C_BaseEntity::PyReceiveMessage( msg );
    }

    void RemoveFromEntityList( ::entity_list_ids_t listId ){
        C_BaseEntity::RemoveFromEntityList( listId );
    }

    virtual bool ShouldDraw(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "ShouldDraw: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling ShouldDraw(  ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_ShouldDraw = this->get_override( "ShouldDraw" );
        if( func_ShouldDraw.ptr() != Py_None )
            try {
                return func_ShouldDraw(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_BaseEntity::ShouldDraw(  );
            }
        else
            return this->C_BaseEntity::ShouldDraw(  );
    }
    
    bool default_ShouldDraw(  ) {
        return C_BaseEntity::ShouldDraw( );
    }

    virtual void Spawn(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Spawn: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Spawn(  ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Spawn = this->get_override( "Spawn" );
        if( func_Spawn.ptr() != Py_None )
            try {
                func_Spawn(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::Spawn(  );
            }
        else
            this->C_BaseEntity::Spawn(  );
    }
    
    void default_Spawn(  ) {
        C_BaseEntity::Spawn( );
    }

    virtual void StartTouch( ::C_BaseEntity * pOther ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "StartTouch: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling StartTouch( boost::python::ptr(pOther) ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_StartTouch = this->get_override( "StartTouch" );
        if( func_StartTouch.ptr() != Py_None )
            try {
                func_StartTouch( boost::python::ptr(pOther) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::StartTouch( boost::python::ptr(pOther) );
            }
        else
            this->C_BaseEntity::StartTouch( boost::python::ptr(pOther) );
    }
    
    void default_StartTouch( ::C_BaseEntity * pOther ) {
        C_BaseEntity::StartTouch( boost::python::ptr(pOther) );
    }

    virtual void UpdateOnRemove(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "UpdateOnRemove: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling UpdateOnRemove(  ) of Class: C_BaseEntity\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_UpdateOnRemove = this->get_override( "UpdateOnRemove" );
        if( func_UpdateOnRemove.ptr() != Py_None )
            try {
                func_UpdateOnRemove(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_BaseEntity::UpdateOnRemove(  );
            }
        else
            this->C_BaseEntity::UpdateOnRemove(  );
    }
    
    void default_UpdateOnRemove(  ) {
        C_BaseEntity::UpdateOnRemove( );
    }

    virtual ClientClass* GetClientClass() {
        if( GetCurrentThreadId() != g_hPythonThreadID )
            return C_BaseAnimating::GetClientClass();
        ClientClass *pClientClass = SrcPySystem()->Get<ClientClass *>("pyClientClass", GetPyInstance(), NULL, true);
        if( pClientClass )
            return pClientClass;
        return C_BaseAnimating::GetClientClass();
    }

    virtual bool TestCollision( ::Ray_t const & ray, unsigned int mask, ::trace_t & trace ) {
                #if defined(_WIN32)
                #if defined(_DEBUG)
                Assert( GetCurrentThreadId() == g_hPythonThreadID );
                #elif defined(PY_CHECKTHREADID)
                if( GetCurrentThreadId() != g_hPythonThreadID )
                    Error( "TestCollision: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
                #endif // _DEBUG/PY_CHECKTHREADID
                #endif // _WIN32
                #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
                if( py_log_overrides.GetBool() )
                    Msg("Calling TestCollision( boost::ref(ray), mask, boost::ref(trace) ) of Class: C_BaseAnimating\n");
                #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
                bp::override func_TestCollision = this->get_override( "TestCollision" );
                if( func_TestCollision.ptr() != Py_None )
                    try {
                        return func_TestCollision( PyRay_t(ray), mask, boost::ref(trace) );
                    } catch(bp::error_already_set &) {
                        PyErr_Print();
                        return this->C_BaseAnimating::TestCollision( boost::ref(ray), mask, boost::ref(trace) );
                    }
                else
                    return this->C_BaseAnimating::TestCollision( boost::ref(ray), mask, boost::ref(trace) );
            }
            
            bool default_TestCollision( ::Ray_t const & ray, unsigned int mask, ::trace_t & trace ) {
                return C_BaseAnimating::TestCollision( boost::ref(ray), mask, boost::ref(trace) );
            }

    virtual PyObject *GetPySelf() const { return bp::detail::wrapper_base_::get_owner(*this); }

};

void register_C_BaseAnimating_class(){

    { //::C_BaseAnimating
        typedef bp::class_< C_BaseAnimating_wrapper, bp::bases< C_BaseEntity >, boost::noncopyable > C_BaseAnimating_exposer_t;
        C_BaseAnimating_exposer_t C_BaseAnimating_exposer = C_BaseAnimating_exposer_t( "C_BaseAnimating", bp::no_init );
        bp::scope C_BaseAnimating_scope( C_BaseAnimating_exposer );
        bp::scope().attr("NUM_POSEPAREMETERS") = (int)C_BaseAnimating::NUM_POSEPAREMETERS;
        bp::scope().attr("NUM_BONECTRLS") = (int)C_BaseAnimating::NUM_BONECTRLS;
        bp::class_< C_BaseAnimating::AutoAllowBoneAccess >( "AutoAllowBoneAccess", bp::init< bool, bool >(( bp::arg("bAllowForNormalModels"), bp::arg("bAllowForViewModels") )) );
        C_BaseAnimating_exposer.def( bp::init< >() );
        { //::C_BaseAnimating::AddToClientSideAnimationList
        
            typedef void ( ::C_BaseAnimating::*AddToClientSideAnimationList_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "AddToClientSideAnimationList"
                , AddToClientSideAnimationList_function_type( &::C_BaseAnimating::AddToClientSideAnimationList ) );
        
        }
        { //::C_BaseAnimating::ApplyBoneMatrixTransform
        
            typedef void ( ::C_BaseAnimating::*ApplyBoneMatrixTransform_function_type )( ::matrix3x4_t & ) ;
            
            C_BaseAnimating_exposer.def( 
                "ApplyBoneMatrixTransform"
                , ApplyBoneMatrixTransform_function_type( &::C_BaseAnimating::ApplyBoneMatrixTransform )
                , ( bp::arg("transform") ) );
        
        }
        { //::C_BaseAnimating::BecomeRagdollOnClient
        
            typedef ::C_BaseAnimating * ( ::C_BaseAnimating::*BecomeRagdollOnClient_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "BecomeRagdollOnClient"
                , BecomeRagdollOnClient_function_type( &::C_BaseAnimating::BecomeRagdollOnClient )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::C_BaseAnimating::CalcBoneMerge
        
            typedef void ( ::C_BaseAnimating::*CalcBoneMerge_function_type )( ::CStudioHdr *,int,::CBoneBitList & ) ;
            
            C_BaseAnimating_exposer.def( 
                "CalcBoneMerge"
                , CalcBoneMerge_function_type( &::C_BaseAnimating::CalcBoneMerge )
                , ( bp::arg("hdr"), bp::arg("boneMask"), bp::arg("boneComputed") ) );
        
        }
        { //::C_BaseAnimating::CalculateIKLocks
        
            typedef void ( ::C_BaseAnimating::*CalculateIKLocks_function_type )( float ) ;
            
            C_BaseAnimating_exposer.def( 
                "CalculateIKLocks"
                , CalculateIKLocks_function_type( &::C_BaseAnimating::CalculateIKLocks )
                , ( bp::arg("currentTime") ) );
        
        }
        { //::C_BaseAnimating::ClampCycle
        
            typedef float ( ::C_BaseAnimating::*ClampCycle_function_type )( float,bool ) ;
            
            C_BaseAnimating_exposer.def( 
                "ClampCycle"
                , ClampCycle_function_type( &::C_BaseAnimating::ClampCycle )
                , ( bp::arg("cycle"), bp::arg("isLooping") ) );
        
        }
        { //::C_BaseAnimating::CleanupToolRecordingState
        
            typedef void ( ::C_BaseAnimating::*CleanupToolRecordingState_function_type )( ::KeyValues * ) ;
            
            C_BaseAnimating_exposer.def( 
                "CleanupToolRecordingState"
                , CleanupToolRecordingState_function_type( &::C_BaseAnimating::CleanupToolRecordingState )
                , ( bp::arg("msg") ) );
        
        }
        { //::C_BaseAnimating::Clear
        
            typedef void ( ::C_BaseAnimating::*Clear_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "Clear"
                , Clear_function_type( &::C_BaseAnimating::Clear ) );
        
        }
        { //::C_BaseAnimating::ClearRagdoll
        
            typedef void ( ::C_BaseAnimating::*ClearRagdoll_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ClearRagdoll"
                , ClearRagdoll_function_type( &::C_BaseAnimating::ClearRagdoll ) );
        
        }
        { //::C_BaseAnimating::ClientSideAnimationChanged
        
            typedef void ( ::C_BaseAnimating::*ClientSideAnimationChanged_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ClientSideAnimationChanged"
                , ClientSideAnimationChanged_function_type( &::C_BaseAnimating::ClientSideAnimationChanged ) );
        
        }
        { //::C_BaseAnimating::ComputeClientSideAnimationFlags
        
            typedef unsigned int ( ::C_BaseAnimating::*ComputeClientSideAnimationFlags_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ComputeClientSideAnimationFlags"
                , ComputeClientSideAnimationFlags_function_type( &::C_BaseAnimating::ComputeClientSideAnimationFlags ) );
        
        }
        { //::C_BaseAnimating::ComputeEntitySpaceHitboxSurroundingBox
        
            typedef bool ( ::C_BaseAnimating::*ComputeEntitySpaceHitboxSurroundingBox_function_type )( ::Vector *,::Vector * ) ;
            
            C_BaseAnimating_exposer.def( 
                "ComputeEntitySpaceHitboxSurroundingBox"
                , ComputeEntitySpaceHitboxSurroundingBox_function_type( &::C_BaseAnimating::ComputeEntitySpaceHitboxSurroundingBox )
                , ( bp::arg("pVecWorldMins"), bp::arg("pVecWorldMaxs") ) );
        
        }
        { //::C_BaseAnimating::ComputeHitboxSurroundingBox
        
            typedef bool ( ::C_BaseAnimating::*ComputeHitboxSurroundingBox_function_type )( ::Vector *,::Vector * ) ;
            
            C_BaseAnimating_exposer.def( 
                "ComputeHitboxSurroundingBox"
                , ComputeHitboxSurroundingBox_function_type( &::C_BaseAnimating::ComputeHitboxSurroundingBox )
                , ( bp::arg("pVecWorldMins"), bp::arg("pVecWorldMaxs") ) );
        
        }
        { //::C_BaseAnimating::ControlMouth
        
            typedef void ( ::C_BaseAnimating::*ControlMouth_function_type )( ::CStudioHdr * ) ;
            
            C_BaseAnimating_exposer.def( 
                "ControlMouth"
                , ControlMouth_function_type( &::C_BaseAnimating::ControlMouth )
                , ( bp::arg("pStudioHdr") ) );
        
        }
        { //::C_BaseAnimating::CopySequenceTransitions
        
            typedef void ( ::C_BaseAnimating::*CopySequenceTransitions_function_type )( ::C_BaseAnimating * ) ;
            
            C_BaseAnimating_exposer.def( 
                "CopySequenceTransitions"
                , CopySequenceTransitions_function_type( &::C_BaseAnimating::CopySequenceTransitions )
                , ( bp::arg("pCopyFrom") ) );
        
        }
        { //::C_BaseAnimating::CreateRagdollCopy
        
            typedef ::C_BaseAnimating * ( ::C_BaseAnimating::*CreateRagdollCopy_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "CreateRagdollCopy"
                , CreateRagdollCopy_function_type( &::C_BaseAnimating::CreateRagdollCopy )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::C_BaseAnimating::CreateUnragdollInfo
        
            typedef void ( ::C_BaseAnimating::*CreateUnragdollInfo_function_type )( ::C_BaseAnimating * ) ;
            
            C_BaseAnimating_exposer.def( 
                "CreateUnragdollInfo"
                , CreateUnragdollInfo_function_type( &::C_BaseAnimating::CreateUnragdollInfo )
                , ( bp::arg("pRagdoll") ) );
        
        }
        { //::C_BaseAnimating::DisableJiggleBones
        
            typedef void ( ::C_BaseAnimating::*DisableJiggleBones_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "DisableJiggleBones"
                , DisableJiggleBones_function_type( &::C_BaseAnimating::DisableJiggleBones ) );
        
        }
        { //::C_BaseAnimating::DisableMuzzleFlash
        
            typedef void ( ::C_BaseAnimating::*DisableMuzzleFlash_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "DisableMuzzleFlash"
                , DisableMuzzleFlash_function_type( &::C_BaseAnimating::DisableMuzzleFlash ) );
        
        }
        { //::C_BaseAnimating::DispatchMuzzleEffect
        
            typedef bool ( ::C_BaseAnimating::*DispatchMuzzleEffect_function_type )( char const *,bool ) ;
            
            C_BaseAnimating_exposer.def( 
                "DispatchMuzzleEffect"
                , DispatchMuzzleEffect_function_type( &::C_BaseAnimating::DispatchMuzzleEffect )
                , ( bp::arg("options"), bp::arg("isFirstPerson") ) );
        
        }
        { //::C_BaseAnimating::DoAnimationEvents
        
            typedef void ( ::C_BaseAnimating::*DoAnimationEvents_function_type )( ::CStudioHdr * ) ;
            
            C_BaseAnimating_exposer.def( 
                "DoAnimationEvents"
                , DoAnimationEvents_function_type( &::C_BaseAnimating::DoAnimationEvents )
                , ( bp::arg("pStudio") ) );
        
        }
        { //::C_BaseAnimating::DoInternalDrawModel
        
            typedef void ( ::C_BaseAnimating::*DoInternalDrawModel_function_type )( ::ClientModelRenderInfo_t *,::DrawModelState_t *,::matrix3x4_t * ) ;
            
            C_BaseAnimating_exposer.def( 
                "DoInternalDrawModel"
                , DoInternalDrawModel_function_type( &::C_BaseAnimating::DoInternalDrawModel )
                , ( bp::arg("pInfo"), bp::arg("pState"), bp::arg("pBoneToWorldArray")=bp::object() ) );
        
        }
        { //::C_BaseAnimating::DoMuzzleFlash
        
            typedef void ( ::C_BaseAnimating::*DoMuzzleFlash_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "DoMuzzleFlash"
                , DoMuzzleFlash_function_type( &::C_BaseAnimating::DoMuzzleFlash ) );
        
        }
        { //::C_BaseAnimating::DrawClientHitboxes
        
            typedef void ( ::C_BaseAnimating::*DrawClientHitboxes_function_type )( float,bool ) ;
            
            C_BaseAnimating_exposer.def( 
                "DrawClientHitboxes"
                , DrawClientHitboxes_function_type( &::C_BaseAnimating::DrawClientHitboxes )
                , ( bp::arg("duration")=0.0f, bp::arg("monocolor")=(bool)(false) ) );
        
        }
        { //::C_BaseAnimating::DrawModel
        
            typedef int ( ::C_BaseAnimating::*DrawModel_function_type )( int,::RenderableInstance_t const & ) ;
            
            C_BaseAnimating_exposer.def( 
                "DrawModel"
                , DrawModel_function_type( &::C_BaseAnimating::DrawModel )
                , ( bp::arg("flags"), bp::arg("instance") ) );
        
        }
        { //::C_BaseAnimating::DrawSkeleton
        
            typedef void ( ::C_BaseAnimating::*DrawSkeleton_function_type )( ::CStudioHdr const *,int ) const;
            
            C_BaseAnimating_exposer.def( 
                "DrawSkeleton"
                , DrawSkeleton_function_type( &::C_BaseAnimating::DrawSkeleton )
                , ( bp::arg("pHdr"), bp::arg("iBoneMask") ) );
        
        }
        { //::C_BaseAnimating::EjectParticleBrass
        
            typedef void ( ::C_BaseAnimating::*EjectParticleBrass_function_type )( char const *,int const ) ;
            
            C_BaseAnimating_exposer.def( 
                "EjectParticleBrass"
                , EjectParticleBrass_function_type( &::C_BaseAnimating::EjectParticleBrass )
                , ( bp::arg("pEffectName"), bp::arg("iAttachment") ) );
        
        }
        { //::C_BaseAnimating::EnableJiggleBones
        
            typedef void ( ::C_BaseAnimating::*EnableJiggleBones_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "EnableJiggleBones"
                , EnableJiggleBones_function_type( &::C_BaseAnimating::EnableJiggleBones ) );
        
        }
        { //::C_BaseAnimating::ExtractBbox
        
            typedef void ( ::C_BaseAnimating::*ExtractBbox_function_type )( int,::Vector &,::Vector & ) ;
            
            C_BaseAnimating_exposer.def( 
                "ExtractBbox"
                , ExtractBbox_function_type( &::C_BaseAnimating::ExtractBbox )
                , ( bp::arg("nSequence"), bp::arg("mins"), bp::arg("maxs") ) );
        
        }
        { //::C_BaseAnimating::FindBodygroupByName
        
            typedef int ( ::C_BaseAnimating::*FindBodygroupByName_function_type )( char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "FindBodygroupByName"
                , FindBodygroupByName_function_type( &::C_BaseAnimating::FindBodygroupByName )
                , ( bp::arg("name") ) );
        
        }
        { //::C_BaseAnimating::FindFollowedEntity
        
            typedef ::C_BaseAnimating * ( ::C_BaseAnimating::*FindFollowedEntity_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "FindFollowedEntity"
                , FindFollowedEntity_function_type( &::C_BaseAnimating::FindFollowedEntity )
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::C_BaseAnimating::FindTransitionSequence
        
            typedef int ( ::C_BaseAnimating::*FindTransitionSequence_function_type )( int,int,int * ) ;
            
            C_BaseAnimating_exposer.def( 
                "FindTransitionSequence"
                , FindTransitionSequence_function_type( &::C_BaseAnimating::FindTransitionSequence )
                , ( bp::arg("iCurrentSequence"), bp::arg("iGoalSequence"), bp::arg("piDir") ) );
        
        }
        { //::C_BaseAnimating::FireEvent
        
            typedef void ( ::C_BaseAnimating::*FireEvent_function_type )( ::Vector const &,::QAngle const &,int,char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "FireEvent"
                , FireEvent_function_type( &::C_BaseAnimating::FireEvent )
                , ( bp::arg("origin"), bp::arg("angles"), bp::arg("event"), bp::arg("options") ) );
        
        }
        { //::C_BaseAnimating::FireObsoleteEvent
        
            typedef void ( ::C_BaseAnimating::*FireObsoleteEvent_function_type )( ::Vector const &,::QAngle const &,int,char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "FireObsoleteEvent"
                , FireObsoleteEvent_function_type( &::C_BaseAnimating::FireObsoleteEvent )
                , ( bp::arg("origin"), bp::arg("angles"), bp::arg("event"), bp::arg("options") ) );
        
        }
        { //::C_BaseAnimating::ForceClientSideAnimationOn
        
            typedef void ( ::C_BaseAnimating::*ForceClientSideAnimationOn_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ForceClientSideAnimationOn"
                , ForceClientSideAnimationOn_function_type( &::C_BaseAnimating::ForceClientSideAnimationOn ) );
        
        }
        { //::C_BaseAnimating::ForceSetupBonesAtTime
        
            typedef void ( ::C_BaseAnimating::*ForceSetupBonesAtTime_function_type )( ::matrix3x4a_t *,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "ForceSetupBonesAtTime"
                , ForceSetupBonesAtTime_function_type( &::C_BaseAnimating::ForceSetupBonesAtTime )
                , ( bp::arg("pBonesOut"), bp::arg("flTime") ) );
        
        }
        { //::C_BaseAnimating::ForceUseFastPath
        
            typedef void ( ::C_BaseAnimating::*ForceUseFastPath_function_type )( bool ) ;
            
            C_BaseAnimating_exposer.def( 
                "ForceUseFastPath"
                , ForceUseFastPath_function_type( &::C_BaseAnimating::ForceUseFastPath )
                , ( bp::arg("bUseFastPath") ) );
        
        }
        { //::C_BaseAnimating::ForcedMaterialOverride
        
            typedef void ( ::C_BaseAnimating::*ForcedMaterialOverride_function_type )( char const *,::OverrideType_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "ForcedMaterialOverride"
                , ForcedMaterialOverride_function_type( &::C_BaseAnimating::ForcedMaterialOverride )
                , ( bp::arg("newMaterial"), bp::arg("nOverrideType")=::OVERRIDE_NORMAL ) );
        
        }
        { //::C_BaseAnimating::FrameAdvance
        
            typedef float ( ::C_BaseAnimating::*FrameAdvance_function_type )( float ) ;
            
            C_BaseAnimating_exposer.def( 
                "FrameAdvance"
                , FrameAdvance_function_type( &::C_BaseAnimating::FrameAdvance )
                , ( bp::arg("flInterval")=0.0f ) );
        
        }
        { //::C_BaseAnimating::GetAnimTimeInterval
        
            typedef float ( ::C_BaseAnimating::*GetAnimTimeInterval_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "GetAnimTimeInterval"
                , GetAnimTimeInterval_function_type( &::C_BaseAnimating::GetAnimTimeInterval ) );
        
        }
        { //::C_BaseAnimating::GetAttachment
        
            typedef bool ( ::C_BaseAnimating::*GetAttachment_function_type )( char const *,::Vector & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetAttachment"
                , GetAttachment_function_type( &::C_BaseAnimating::GetAttachment )
                , ( bp::arg("szName"), bp::arg("absOrigin") ) );
        
        }
        { //::C_BaseAnimating::GetAttachment
        
            typedef bool ( ::C_BaseAnimating::*GetAttachment_function_type )( char const *,::Vector &,::QAngle & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetAttachment"
                , GetAttachment_function_type( &::C_BaseAnimating::GetAttachment )
                , ( bp::arg("szName"), bp::arg("absOrigin"), bp::arg("absAngles") ) );
        
        }
        { //::C_BaseAnimating::GetAttachment
        
            typedef bool ( ::C_BaseAnimating::*GetAttachment_function_type )( int,::Vector & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetAttachment"
                , GetAttachment_function_type( &::C_BaseAnimating::GetAttachment )
                , ( bp::arg("number"), bp::arg("origin") ) );
        
        }
        { //::C_BaseAnimating::GetAttachment
        
            typedef bool ( ::C_BaseAnimating::*GetAttachment_function_type )( int,::Vector &,::QAngle & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetAttachment"
                , GetAttachment_function_type( &::C_BaseAnimating::GetAttachment )
                , ( bp::arg("number"), bp::arg("origin"), bp::arg("angles") ) );
        
        }
        { //::C_BaseAnimating::GetAttachment
        
            typedef bool ( ::C_BaseAnimating::*GetAttachment_function_type )( int,::matrix3x4_t & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetAttachment"
                , GetAttachment_function_type( &::C_BaseAnimating::GetAttachment )
                , ( bp::arg("number"), bp::arg("matrix") ) );
        
        }
        { //::C_BaseAnimating::GetAttachmentLocal
        
            typedef bool ( ::C_BaseAnimating::*GetAttachmentLocal_function_type )( int,::matrix3x4_t & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetAttachmentLocal"
                , GetAttachmentLocal_function_type( &::C_BaseAnimating::GetAttachmentLocal )
                , ( bp::arg("iAttachment"), bp::arg("attachmentToLocal") ) );
        
        }
        { //::C_BaseAnimating::GetAttachmentLocal
        
            typedef bool ( ::C_BaseAnimating::*GetAttachmentLocal_function_type )( int,::Vector &,::QAngle & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetAttachmentLocal"
                , GetAttachmentLocal_function_type( &::C_BaseAnimating::GetAttachmentLocal )
                , ( bp::arg("iAttachment"), bp::arg("origin"), bp::arg("angles") ) );
        
        }
        { //::C_BaseAnimating::GetAttachmentLocal
        
            typedef bool ( ::C_BaseAnimating::*GetAttachmentLocal_function_type )( int,::Vector & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetAttachmentLocal"
                , GetAttachmentLocal_function_type( &::C_BaseAnimating::GetAttachmentLocal )
                , ( bp::arg("iAttachment"), bp::arg("origin") ) );
        
        }
        { //::C_BaseAnimating::GetBlendedLinearVelocity
        
            typedef void ( ::C_BaseAnimating::*GetBlendedLinearVelocity_function_type )( ::Vector * ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetBlendedLinearVelocity"
                , GetBlendedLinearVelocity_function_type( &::C_BaseAnimating::GetBlendedLinearVelocity )
                , ( bp::arg("pVec") ) );
        
        }
        { //::C_BaseAnimating::GetBody
        
            typedef int ( ::C_BaseAnimating::*GetBody_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetBody"
                , GetBody_function_type( &::C_BaseAnimating::GetBody ) );
        
        }
        { //::C_BaseAnimating::GetBodygroup
        
            typedef int ( ::C_BaseAnimating::*GetBodygroup_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetBodygroup"
                , GetBodygroup_function_type( &::C_BaseAnimating::GetBodygroup )
                , ( bp::arg("iGroup") ) );
        
        }
        { //::C_BaseAnimating::GetBodygroupCount
        
            typedef int ( ::C_BaseAnimating::*GetBodygroupCount_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetBodygroupCount"
                , GetBodygroupCount_function_type( &::C_BaseAnimating::GetBodygroupCount )
                , ( bp::arg("iGroup") ) );
        
        }
        { //::C_BaseAnimating::GetBodygroupName
        
            typedef char const * ( ::C_BaseAnimating::*GetBodygroupName_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetBodygroupName"
                , GetBodygroupName_function_type( &::C_BaseAnimating::GetBodygroupName )
                , ( bp::arg("iGroup") ) );
        
        }
        { //::C_BaseAnimating::GetBone
        
            typedef ::matrix3x4a_t const & ( ::C_BaseAnimating::*GetBone_function_type )( int ) const;
            
            C_BaseAnimating_exposer.def( 
                "GetBone"
                , GetBone_function_type( &::C_BaseAnimating::GetBone )
                , ( bp::arg("iBone") )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::C_BaseAnimating::GetBoneControllers
        
            typedef void ( ::C_BaseAnimating::*GetBoneControllers_function_type )( float * ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetBoneControllers"
                , GetBoneControllers_function_type( &::C_BaseAnimating::GetBoneControllers )
                , ( bp::arg("controllers") ) );
        
        }
        { //::C_BaseAnimating::GetBonePosition
        
            typedef void ( ::C_BaseAnimating::*GetBonePosition_function_type )( int,::Vector &,::QAngle & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetBonePosition"
                , GetBonePosition_function_type( &::C_BaseAnimating::GetBonePosition )
                , ( bp::arg("iBone"), bp::arg("origin"), bp::arg("angles") ) );
        
        }
        { //::C_BaseAnimating::GetBoneTransform
        
            typedef void ( ::C_BaseAnimating::*GetBoneTransform_function_type )( int,::matrix3x4_t & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetBoneTransform"
                , GetBoneTransform_function_type( &::C_BaseAnimating::GetBoneTransform )
                , ( bp::arg("iBone"), bp::arg("pBoneToWorld") ) );
        
        }
        { //::C_BaseAnimating::GetCachedBoneMatrix
        
            typedef void ( ::C_BaseAnimating::*GetCachedBoneMatrix_function_type )( int,::matrix3x4_t & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetCachedBoneMatrix"
                , GetCachedBoneMatrix_function_type( &::C_BaseAnimating::GetCachedBoneMatrix )
                , ( bp::arg("boneIndex"), bp::arg("out") ) );
        
        }
        { //::C_BaseAnimating::GetCollideType
        
            typedef ::CollideType_t ( ::C_BaseAnimating::*GetCollideType_function_type )(  ) ;
            typedef ::CollideType_t ( C_BaseAnimating_wrapper::*default_GetCollideType_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetCollideType"
                , GetCollideType_function_type(&::C_BaseAnimating::GetCollideType)
                , default_GetCollideType_function_type(&C_BaseAnimating_wrapper::default_GetCollideType) );
        
        }
        { //::C_BaseAnimating::GetCycle
        
            typedef float ( ::C_BaseAnimating::*GetCycle_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "GetCycle"
                , GetCycle_function_type( &::C_BaseAnimating::GetCycle ) );
        
        }
        { //::C_BaseAnimating::GetFlexControllerName
        
            typedef char const * ( ::C_BaseAnimating::*GetFlexControllerName_function_type )( ::LocalFlexController_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetFlexControllerName"
                , GetFlexControllerName_function_type( &::C_BaseAnimating::GetFlexControllerName )
                , ( bp::arg("iFlexController") ) );
        
        }
        { //::C_BaseAnimating::GetFlexControllerType
        
            typedef char const * ( ::C_BaseAnimating::*GetFlexControllerType_function_type )( ::LocalFlexController_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetFlexControllerType"
                , GetFlexControllerType_function_type( &::C_BaseAnimating::GetFlexControllerType )
                , ( bp::arg("iFlexController") ) );
        
        }
        { //::C_BaseAnimating::GetFlexDescFacs
        
            typedef char const * ( ::C_BaseAnimating::*GetFlexDescFacs_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetFlexDescFacs"
                , GetFlexDescFacs_function_type( &::C_BaseAnimating::GetFlexDescFacs )
                , ( bp::arg("iFlexDesc") ) );
        
        }
        { //::C_BaseAnimating::GetFrozenAmount
        
            typedef float ( ::C_BaseAnimating::*GetFrozenAmount_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetFrozenAmount"
                , GetFrozenAmount_function_type( &::C_BaseAnimating::GetFrozenAmount ) );
        
        }
        { //::C_BaseAnimating::GetGroundSpeed
        
            typedef float ( ::C_BaseAnimating::*GetGroundSpeed_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetGroundSpeed"
                , GetGroundSpeed_function_type( &::C_BaseAnimating::GetGroundSpeed ) );
        
        }
        { //::C_BaseAnimating::GetHitboxSet
        
            typedef int ( ::C_BaseAnimating::*GetHitboxSet_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetHitboxSet"
                , GetHitboxSet_function_type( &::C_BaseAnimating::GetHitboxSet ) );
        
        }
        { //::C_BaseAnimating::GetHitboxSetCount
        
            typedef int ( ::C_BaseAnimating::*GetHitboxSetCount_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetHitboxSetCount"
                , GetHitboxSetCount_function_type( &::C_BaseAnimating::GetHitboxSetCount ) );
        
        }
        { //::C_BaseAnimating::GetHitboxSetName
        
            typedef char const * ( ::C_BaseAnimating::*GetHitboxSetName_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetHitboxSetName"
                , GetHitboxSetName_function_type( &::C_BaseAnimating::GetHitboxSetName ) );
        
        }
        { //::C_BaseAnimating::GetModelPtr
        
            typedef ::CStudioHdr * ( ::C_BaseAnimating::*GetModelPtr_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "GetModelPtr"
                , GetModelPtr_function_type( &::C_BaseAnimating::GetModelPtr )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::C_BaseAnimating::GetModelScale
        
            typedef float ( ::C_BaseAnimating::*GetModelScale_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "GetModelScale"
                , GetModelScale_function_type( &::C_BaseAnimating::GetModelScale ) );
        
        }
        { //::C_BaseAnimating::GetNumBodyGroups
        
            typedef int ( ::C_BaseAnimating::*GetNumBodyGroups_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetNumBodyGroups"
                , GetNumBodyGroups_function_type( &::C_BaseAnimating::GetNumBodyGroups ) );
        
        }
        { //::C_BaseAnimating::GetNumFlexControllers
        
            typedef ::LocalFlexController_t ( ::C_BaseAnimating::*GetNumFlexControllers_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetNumFlexControllers"
                , GetNumFlexControllers_function_type( &::C_BaseAnimating::GetNumFlexControllers ) );
        
        }
        { //::C_BaseAnimating::GetPlaybackRate
        
            typedef float ( ::C_BaseAnimating::*GetPlaybackRate_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "GetPlaybackRate"
                , GetPlaybackRate_function_type( &::C_BaseAnimating::GetPlaybackRate ) );
        
        }
        { //::C_BaseAnimating::GetPoseParameter
        
            typedef float ( ::C_BaseAnimating::*GetPoseParameter_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetPoseParameter"
                , GetPoseParameter_function_type( &::C_BaseAnimating::GetPoseParameter )
                , ( bp::arg("iParameter") ) );
        
        }
        { //::C_BaseAnimating::GetPoseParameterRange
        
            typedef boost::python::tuple ( *GetPoseParameterRange_function_type )( ::C_BaseAnimating &,int );
            
            C_BaseAnimating_exposer.def( 
                "GetPoseParameterRange"
                , GetPoseParameterRange_function_type( &C_BaseAnimating_wrapper::GetPoseParameterRange )
                , ( bp::arg("inst"), bp::arg("iPoseParameter") ) );
        
        }
        { //::C_BaseAnimating::GetPoseParameterRaw
        
            typedef float ( ::C_BaseAnimating::*GetPoseParameterRaw_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetPoseParameterRaw"
                , GetPoseParameterRaw_function_type( &::C_BaseAnimating::GetPoseParameterRaw )
                , ( bp::arg("iPoseParameter") ) );
        
        }
        { //::C_BaseAnimating::GetPoseParameters
        
            typedef void ( ::C_BaseAnimating::*GetPoseParameters_function_type )( ::CStudioHdr *,float * ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetPoseParameters"
                , GetPoseParameters_function_type( &::C_BaseAnimating::GetPoseParameters )
                , ( bp::arg("pStudioHdr"), bp::arg("poseParameter") ) );
        
        }
        { //::C_BaseAnimating::GetPyNetworkType
        
            typedef int ( *GetPyNetworkType_function_type )(  );
            
            C_BaseAnimating_exposer.def( 
                "GetPyNetworkType"
                , GetPyNetworkType_function_type( &::C_BaseAnimating::GetPyNetworkType ) );
        
        }
        { //::C_BaseAnimating::GetRagdollInitBoneArrays
        
            typedef void ( ::C_BaseAnimating::*GetRagdollInitBoneArrays_function_type )( ::matrix3x4a_t *,::matrix3x4a_t *,::matrix3x4a_t *,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetRagdollInitBoneArrays"
                , GetRagdollInitBoneArrays_function_type( &::C_BaseAnimating::GetRagdollInitBoneArrays )
                , ( bp::arg("pDeltaBones0"), bp::arg("pDeltaBones1"), bp::arg("pCurrentBones"), bp::arg("boneDt") ) );
        
        }
        { //::C_BaseAnimating::GetRenderAngles
        
            typedef ::QAngle const & ( ::C_BaseAnimating::*GetRenderAngles_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetRenderAngles"
                , GetRenderAngles_function_type( &::C_BaseAnimating::GetRenderAngles )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::C_BaseAnimating::GetRenderBounds
        
            typedef void ( ::C_BaseAnimating::*GetRenderBounds_function_type )( ::Vector &,::Vector & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetRenderBounds"
                , GetRenderBounds_function_type( &::C_BaseAnimating::GetRenderBounds )
                , ( bp::arg("theMins"), bp::arg("theMaxs") ) );
        
        }
        { //::C_BaseAnimating::GetRenderData
        
            typedef bool ( ::C_BaseAnimating::*GetRenderData_function_type )( void *,::ModelDataCategory_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetRenderData"
                , GetRenderData_function_type( &::C_BaseAnimating::GetRenderData )
                , ( bp::arg("pData"), bp::arg("nCategory") ) );
        
        }
        { //::C_BaseAnimating::GetRenderFlags
        
            typedef int ( ::C_BaseAnimating::*GetRenderFlags_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetRenderFlags"
                , GetRenderFlags_function_type( &::C_BaseAnimating::GetRenderFlags ) );
        
        }
        { //::C_BaseAnimating::GetRenderOrigin
        
            typedef ::Vector const & ( ::C_BaseAnimating::*GetRenderOrigin_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetRenderOrigin"
                , GetRenderOrigin_function_type( &::C_BaseAnimating::GetRenderOrigin )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::C_BaseAnimating::GetSequence
        
            typedef int ( ::C_BaseAnimating::*GetSequence_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequence"
                , GetSequence_function_type( &::C_BaseAnimating::GetSequence ) );
        
        }
        { //::C_BaseAnimating::GetSequenceActivity
        
            typedef ::Activity ( ::C_BaseAnimating::*GetSequenceActivity_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequenceActivity"
                , GetSequenceActivity_function_type( &::C_BaseAnimating::GetSequenceActivity )
                , ( bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::GetSequenceActivityName
        
            typedef char const * ( ::C_BaseAnimating::*GetSequenceActivityName_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequenceActivityName"
                , GetSequenceActivityName_function_type( &::C_BaseAnimating::GetSequenceActivityName )
                , ( bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::GetSequenceCycleRate
        
            typedef float ( ::C_BaseAnimating::*GetSequenceCycleRate_function_type )( ::CStudioHdr *,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequenceCycleRate"
                , GetSequenceCycleRate_function_type( &::C_BaseAnimating::GetSequenceCycleRate )
                , ( bp::arg("pStudioHdr"), bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::GetSequenceGroundSpeed
        
            typedef float ( ::C_BaseAnimating::*GetSequenceGroundSpeed_function_type )( ::CStudioHdr *,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequenceGroundSpeed"
                , GetSequenceGroundSpeed_function_type( &::C_BaseAnimating::GetSequenceGroundSpeed )
                , ( bp::arg("pStudioHdr"), bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::GetSequenceGroundSpeed
        
            typedef float ( ::C_BaseAnimating::*GetSequenceGroundSpeed_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequenceGroundSpeed"
                , GetSequenceGroundSpeed_function_type( &::C_BaseAnimating::GetSequenceGroundSpeed )
                , ( bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::GetSequenceLinearMotion
        
            typedef void ( ::C_BaseAnimating::*GetSequenceLinearMotion_function_type )( int,::Vector * ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequenceLinearMotion"
                , GetSequenceLinearMotion_function_type( &::C_BaseAnimating::GetSequenceLinearMotion )
                , ( bp::arg("iSequence"), bp::arg("pVec") ) );
        
        }
        { //::C_BaseAnimating::GetSequenceLinearMotionAndDuration
        
            typedef float ( ::C_BaseAnimating::*GetSequenceLinearMotionAndDuration_function_type )( int,::Vector * ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequenceLinearMotionAndDuration"
                , GetSequenceLinearMotionAndDuration_function_type( &::C_BaseAnimating::GetSequenceLinearMotionAndDuration )
                , ( bp::arg("iSequence"), bp::arg("pVec") ) );
        
        }
        { //::C_BaseAnimating::GetSequenceMoveDist
        
            typedef float ( ::C_BaseAnimating::*GetSequenceMoveDist_function_type )( ::CStudioHdr *,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequenceMoveDist"
                , GetSequenceMoveDist_function_type( &::C_BaseAnimating::GetSequenceMoveDist )
                , ( bp::arg("pStudioHdr"), bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::GetSequenceMovement
        
            typedef bool ( ::C_BaseAnimating::*GetSequenceMovement_function_type )( int,float,float,::Vector &,::QAngle & ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequenceMovement"
                , GetSequenceMovement_function_type( &::C_BaseAnimating::GetSequenceMovement )
                , ( bp::arg("nSequence"), bp::arg("fromCycle"), bp::arg("toCycle"), bp::arg("deltaPosition"), bp::arg("deltaAngles") ) );
        
        }
        { //::C_BaseAnimating::GetSequenceName
        
            typedef char const * ( ::C_BaseAnimating::*GetSequenceName_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetSequenceName"
                , GetSequenceName_function_type( &::C_BaseAnimating::GetSequenceName )
                , ( bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::GetServerIntendedCycle
        
            typedef float ( ::C_BaseAnimating::*GetServerIntendedCycle_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetServerIntendedCycle"
                , GetServerIntendedCycle_function_type( &::C_BaseAnimating::GetServerIntendedCycle ) );
        
        }
        { //::C_BaseAnimating::GetToolRecordingState
        
            typedef void ( ::C_BaseAnimating::*GetToolRecordingState_function_type )( ::KeyValues * ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetToolRecordingState"
                , GetToolRecordingState_function_type( &::C_BaseAnimating::GetToolRecordingState )
                , ( bp::arg("msg") ) );
        
        }
        { //::C_BaseAnimating::GetUseFastPath
        
            typedef bool ( ::C_BaseAnimating::*GetUseFastPath_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetUseFastPath"
                , GetUseFastPath_function_type( &::C_BaseAnimating::GetUseFastPath ) );
        
        }
        { //::C_BaseAnimating::HitboxToWorldTransforms
        
            typedef bool ( ::C_BaseAnimating::*HitboxToWorldTransforms_function_type )( ::matrix3x4_t * * ) ;
            
            C_BaseAnimating_exposer.def( 
                "HitboxToWorldTransforms"
                , HitboxToWorldTransforms_function_type( &::C_BaseAnimating::HitboxToWorldTransforms )
                , ( bp::arg("pHitboxToWorld") ) );
        
        }
        { //::C_BaseAnimating::IgniteRagdoll
        
            typedef void ( ::C_BaseAnimating::*IgniteRagdoll_function_type )( ::C_BaseAnimating * ) ;
            
            C_BaseAnimating_exposer.def( 
                "IgniteRagdoll"
                , IgniteRagdoll_function_type( &::C_BaseAnimating::IgniteRagdoll )
                , ( bp::arg("pSource") ) );
        
        }
        { //::C_BaseAnimating::InThreadedBoneSetup
        
            typedef bool ( *InThreadedBoneSetup_function_type )(  );
            
            C_BaseAnimating_exposer.def( 
                "InThreadedBoneSetup"
                , InThreadedBoneSetup_function_type( &::C_BaseAnimating::InThreadedBoneSetup ) );
        
        }
        { //::C_BaseAnimating::InitAsClientRagdoll
        
            typedef bool ( ::C_BaseAnimating::*InitAsClientRagdoll_function_type )( ::matrix3x4_t const *,::matrix3x4_t const *,::matrix3x4_t const *,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "InitAsClientRagdoll"
                , InitAsClientRagdoll_function_type( &::C_BaseAnimating::InitAsClientRagdoll )
                , ( bp::arg("pDeltaBones0"), bp::arg("pDeltaBones1"), bp::arg("pCurrentBonePosition"), bp::arg("boneDt") ) );
        
        }
        { //::C_BaseAnimating::InitBoneSetupThreadPool
        
            typedef void ( *InitBoneSetupThreadPool_function_type )(  );
            
            C_BaseAnimating_exposer.def( 
                "InitBoneSetupThreadPool"
                , InitBoneSetupThreadPool_function_type( &::C_BaseAnimating::InitBoneSetupThreadPool ) );
        
        }
        { //::C_BaseAnimating::InitModelEffects
        
            typedef void ( ::C_BaseAnimating::*InitModelEffects_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "InitModelEffects"
                , InitModelEffects_function_type( &::C_BaseAnimating::InitModelEffects ) );
        
        }
        { //::C_BaseAnimating::InternalDrawModel
        
            typedef int ( ::C_BaseAnimating::*InternalDrawModel_function_type )( int,::RenderableInstance_t const & ) ;
            
            C_BaseAnimating_exposer.def( 
                "InternalDrawModel"
                , InternalDrawModel_function_type( &::C_BaseAnimating::InternalDrawModel )
                , ( bp::arg("flags"), bp::arg("instance") ) );
        
        }
        { //::C_BaseAnimating::Interpolate
        
            typedef bool ( ::C_BaseAnimating::*Interpolate_function_type )( float ) ;
            
            C_BaseAnimating_exposer.def( 
                "Interpolate"
                , Interpolate_function_type( &::C_BaseAnimating::Interpolate )
                , ( bp::arg("currentTime") ) );
        
        }
        { //::C_BaseAnimating::InvalidateAttachments
        
            typedef void ( ::C_BaseAnimating::*InvalidateAttachments_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "InvalidateAttachments"
                , InvalidateAttachments_function_type( &::C_BaseAnimating::InvalidateAttachments ) );
        
        }
        { //::C_BaseAnimating::InvalidateBoneCache
        
            typedef void ( ::C_BaseAnimating::*InvalidateBoneCache_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "InvalidateBoneCache"
                , InvalidateBoneCache_function_type( &::C_BaseAnimating::InvalidateBoneCache ) );
        
        }
        { //::C_BaseAnimating::InvalidateBoneCaches
        
            typedef void ( *InvalidateBoneCaches_function_type )(  );
            
            C_BaseAnimating_exposer.def( 
                "InvalidateBoneCaches"
                , InvalidateBoneCaches_function_type( &::C_BaseAnimating::InvalidateBoneCaches ) );
        
        }
        { //::C_BaseAnimating::InvalidateMdlCache
        
            typedef void ( ::C_BaseAnimating::*InvalidateMdlCache_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "InvalidateMdlCache"
                , InvalidateMdlCache_function_type( &::C_BaseAnimating::InvalidateMdlCache ) );
        
        }
        { //::C_BaseAnimating::IsActivityFinished
        
            typedef bool ( ::C_BaseAnimating::*IsActivityFinished_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "IsActivityFinished"
                , IsActivityFinished_function_type( &::C_BaseAnimating::IsActivityFinished ) );
        
        }
        { //::C_BaseAnimating::IsBoneCacheValid
        
            typedef bool ( ::C_BaseAnimating::*IsBoneCacheValid_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "IsBoneCacheValid"
                , IsBoneCacheValid_function_type( &::C_BaseAnimating::IsBoneCacheValid ) );
        
        }
        { //::C_BaseAnimating::IsClientRagdoll
        
            typedef bool ( ::C_BaseAnimating::*IsClientRagdoll_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "IsClientRagdoll"
                , IsClientRagdoll_function_type( &::C_BaseAnimating::IsClientRagdoll ) );
        
        }
        { //::C_BaseAnimating::IsModelScaleFractional
        
            typedef bool ( ::C_BaseAnimating::*IsModelScaleFractional_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "IsModelScaleFractional"
                , IsModelScaleFractional_function_type( &::C_BaseAnimating::IsModelScaleFractional ) );
        
        }
        { //::C_BaseAnimating::IsOnFire
        
            typedef bool ( ::C_BaseAnimating::*IsOnFire_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "IsOnFire"
                , IsOnFire_function_type( &::C_BaseAnimating::IsOnFire ) );
        
        }
        { //::C_BaseAnimating::IsRagdoll
        
            typedef bool ( ::C_BaseAnimating::*IsRagdoll_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "IsRagdoll"
                , IsRagdoll_function_type( &::C_BaseAnimating::IsRagdoll ) );
        
        }
        { //::C_BaseAnimating::IsSelfAnimating
        
            typedef bool ( ::C_BaseAnimating::*IsSelfAnimating_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "IsSelfAnimating"
                , IsSelfAnimating_function_type( &::C_BaseAnimating::IsSelfAnimating ) );
        
        }
        { //::C_BaseAnimating::IsSequenceFinished
        
            typedef bool ( ::C_BaseAnimating::*IsSequenceFinished_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "IsSequenceFinished"
                , IsSequenceFinished_function_type( &::C_BaseAnimating::IsSequenceFinished ) );
        
        }
        { //::C_BaseAnimating::IsSequenceLooping
        
            typedef bool ( ::C_BaseAnimating::*IsSequenceLooping_function_type )( ::CStudioHdr *,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "IsSequenceLooping"
                , IsSequenceLooping_function_type( &::C_BaseAnimating::IsSequenceLooping )
                , ( bp::arg("pStudioHdr"), bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::IsSequenceLooping
        
            typedef bool ( ::C_BaseAnimating::*IsSequenceLooping_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "IsSequenceLooping"
                , IsSequenceLooping_function_type( &::C_BaseAnimating::IsSequenceLooping )
                , ( bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::IsUsingClientSideAnimation
        
            typedef bool ( ::C_BaseAnimating::*IsUsingClientSideAnimation_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "IsUsingClientSideAnimation"
                , IsUsingClientSideAnimation_function_type( &::C_BaseAnimating::IsUsingClientSideAnimation ) );
        
        }
        { //::C_BaseAnimating::IsViewModel
        
            typedef bool ( ::C_BaseAnimating::*IsViewModel_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "IsViewModel"
                , IsViewModel_function_type( &::C_BaseAnimating::IsViewModel ) );
        
        }
        { //::C_BaseAnimating::IsViewModelOrAttachment
        
            typedef bool ( ::C_BaseAnimating::*IsViewModelOrAttachment_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "IsViewModelOrAttachment"
                , IsViewModelOrAttachment_function_type( &::C_BaseAnimating::IsViewModelOrAttachment ) );
        
        }
        { //::C_BaseAnimating::LookupActivity
        
            typedef int ( ::C_BaseAnimating::*LookupActivity_function_type )( char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "LookupActivity"
                , LookupActivity_function_type( &::C_BaseAnimating::LookupActivity )
                , ( bp::arg("label") ) );
        
        }
        { //::C_BaseAnimating::LookupAttachment
        
            typedef int ( ::C_BaseAnimating::*LookupAttachment_function_type )( char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "LookupAttachment"
                , LookupAttachment_function_type( &::C_BaseAnimating::LookupAttachment )
                , ( bp::arg("pAttachmentName") ) );
        
        }
        { //::C_BaseAnimating::LookupBone
        
            typedef int ( ::C_BaseAnimating::*LookupBone_function_type )( char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "LookupBone"
                , LookupBone_function_type( &::C_BaseAnimating::LookupBone )
                , ( bp::arg("szName") ) );
        
        }
        { //::C_BaseAnimating::LookupPoseParameter
        
            typedef int ( ::C_BaseAnimating::*LookupPoseParameter_function_type )( ::CStudioHdr *,char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "LookupPoseParameter"
                , LookupPoseParameter_function_type( &::C_BaseAnimating::LookupPoseParameter )
                , ( bp::arg("pStudioHdr"), bp::arg("szName") ) );
        
        }
        { //::C_BaseAnimating::LookupPoseParameter
        
            typedef int ( ::C_BaseAnimating::*LookupPoseParameter_function_type )( char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "LookupPoseParameter"
                , LookupPoseParameter_function_type( &::C_BaseAnimating::LookupPoseParameter )
                , ( bp::arg("szName") ) );
        
        }
        { //::C_BaseAnimating::LookupRandomAttachment
        
            typedef int ( ::C_BaseAnimating::*LookupRandomAttachment_function_type )( char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "LookupRandomAttachment"
                , LookupRandomAttachment_function_type( &::C_BaseAnimating::LookupRandomAttachment )
                , ( bp::arg("pAttachmentNameSubstring") ) );
        
        }
        { //::C_BaseAnimating::LookupSequence
        
            typedef int ( ::C_BaseAnimating::*LookupSequence_function_type )( char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "LookupSequence"
                , LookupSequence_function_type( &::C_BaseAnimating::LookupSequence )
                , ( bp::arg("label") ) );
        
        }
        { //::C_BaseAnimating::MarkForThreadedBoneSetup
        
            typedef void ( ::C_BaseAnimating::*MarkForThreadedBoneSetup_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "MarkForThreadedBoneSetup"
                , MarkForThreadedBoneSetup_function_type( &::C_BaseAnimating::MarkForThreadedBoneSetup ) );
        
        }
        { //::C_BaseAnimating::OnDataChanged
        
            typedef void ( ::C_BaseAnimating::*OnDataChanged_function_type )( ::DataUpdateType_t ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_OnDataChanged_function_type )( ::DataUpdateType_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "OnDataChanged"
                , OnDataChanged_function_type(&::C_BaseAnimating::OnDataChanged)
                , default_OnDataChanged_function_type(&C_BaseAnimating_wrapper::default_OnDataChanged)
                , ( bp::arg("updateType") ) );
        
        }
        { //::C_BaseAnimating::OnInternalDrawModel
        
            typedef bool ( ::C_BaseAnimating::*OnInternalDrawModel_function_type )( ::ClientModelRenderInfo_t * ) ;
            
            C_BaseAnimating_exposer.def( 
                "OnInternalDrawModel"
                , OnInternalDrawModel_function_type( &::C_BaseAnimating::OnInternalDrawModel )
                , ( bp::arg("pInfo") ) );
        
        }
        { //::C_BaseAnimating::OnNewSequence
        
            typedef void ( ::C_BaseAnimating::*OnNewSequence_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "OnNewSequence"
                , OnNewSequence_function_type( &::C_BaseAnimating::OnNewSequence ) );
        
        }
        { //::C_BaseAnimating::OnPostInternalDrawModel
        
            typedef bool ( ::C_BaseAnimating::*OnPostInternalDrawModel_function_type )( ::ClientModelRenderInfo_t * ) ;
            
            C_BaseAnimating_exposer.def( 
                "OnPostInternalDrawModel"
                , OnPostInternalDrawModel_function_type( &::C_BaseAnimating::OnPostInternalDrawModel )
                , ( bp::arg("pInfo") ) );
        
        }
        { //::C_BaseAnimating::OnPreDataChanged
        
            typedef void ( ::C_BaseAnimating::*OnPreDataChanged_function_type )( ::DataUpdateType_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "OnPreDataChanged"
                , OnPreDataChanged_function_type( &::C_BaseAnimating::OnPreDataChanged )
                , ( bp::arg("updateType") ) );
        
        }
        { //::C_BaseAnimating::PopBoneAccess
        
            typedef void ( *PopBoneAccess_function_type )( char const * );
            
            C_BaseAnimating_exposer.def( 
                "PopBoneAccess"
                , PopBoneAccess_function_type( &::C_BaseAnimating::PopBoneAccess )
                , ( bp::arg("tagPop") ) );
        
        }
        { //::C_BaseAnimating::PostDataUpdate
        
            typedef void ( ::C_BaseAnimating::*PostDataUpdate_function_type )( ::DataUpdateType_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "PostDataUpdate"
                , PostDataUpdate_function_type( &::C_BaseAnimating::PostDataUpdate )
                , ( bp::arg("updateType") ) );
        
        }
        { //::C_BaseAnimating::PreDataUpdate
        
            typedef void ( ::C_BaseAnimating::*PreDataUpdate_function_type )( ::DataUpdateType_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "PreDataUpdate"
                , PreDataUpdate_function_type( &::C_BaseAnimating::PreDataUpdate )
                , ( bp::arg("updateType") ) );
        
        }
        { //::C_BaseAnimating::ProcessMuzzleFlashEvent
        
            typedef void ( ::C_BaseAnimating::*ProcessMuzzleFlashEvent_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ProcessMuzzleFlashEvent"
                , ProcessMuzzleFlashEvent_function_type( &::C_BaseAnimating::ProcessMuzzleFlashEvent ) );
        
        }
        { //::C_BaseAnimating::PushAllowBoneAccess
        
            typedef void ( *PushAllowBoneAccess_function_type )( bool,bool,char const * );
            
            C_BaseAnimating_exposer.def( 
                "PushAllowBoneAccess"
                , PushAllowBoneAccess_function_type( &::C_BaseAnimating::PushAllowBoneAccess )
                , ( bp::arg("bAllowForNormalModels"), bp::arg("bAllowForViewModels"), bp::arg("tagPush") ) );
        
        }
        { //::C_BaseAnimating::PyOnNewModel
        
            typedef void ( ::C_BaseAnimating::*OnNewModel_function_type )(  ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_OnNewModel_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "OnNewModel"
                , OnNewModel_function_type(&::C_BaseAnimating::PyOnNewModel)
                , default_OnNewModel_function_type(&C_BaseAnimating_wrapper::default_OnNewModel) );
        
        }
        { //::C_BaseAnimating::RagdollMoved
        
            typedef void ( ::C_BaseAnimating::*RagdollMoved_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "RagdollMoved"
                , RagdollMoved_function_type( &::C_BaseAnimating::RagdollMoved ) );
        
        }
        { //::C_BaseAnimating::ReachedEndOfSequence
        
            typedef void ( ::C_BaseAnimating::*ReachedEndOfSequence_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ReachedEndOfSequence"
                , ReachedEndOfSequence_function_type( &::C_BaseAnimating::ReachedEndOfSequence ) );
        
        }
        { //::C_BaseAnimating::RemoveFromClientSideAnimationList
        
            typedef void ( ::C_BaseAnimating::*RemoveFromClientSideAnimationList_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "RemoveFromClientSideAnimationList"
                , RemoveFromClientSideAnimationList_function_type( &::C_BaseAnimating::RemoveFromClientSideAnimationList ) );
        
        }
        { //::C_BaseAnimating::ResetLatched
        
            typedef void ( ::C_BaseAnimating::*ResetLatched_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ResetLatched"
                , ResetLatched_function_type( &::C_BaseAnimating::ResetLatched ) );
        
        }
        { //::C_BaseAnimating::ResetSequence
        
            typedef void ( ::C_BaseAnimating::*ResetSequence_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "ResetSequence"
                , ResetSequence_function_type( &::C_BaseAnimating::ResetSequence )
                , ( bp::arg("nSequence") ) );
        
        }
        { //::C_BaseAnimating::ResetSequenceInfo
        
            typedef void ( ::C_BaseAnimating::*ResetSequenceInfo_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ResetSequenceInfo"
                , ResetSequenceInfo_function_type( &::C_BaseAnimating::ResetSequenceInfo ) );
        
        }
        { //::C_BaseAnimating::SaveRagdollInfo
        
            typedef void ( ::C_BaseAnimating::*SaveRagdollInfo_function_type )( int,::matrix3x4_t const &,::CBoneAccessor & ) ;
            
            C_BaseAnimating_exposer.def( 
                "SaveRagdollInfo"
                , SaveRagdollInfo_function_type( &::C_BaseAnimating::SaveRagdollInfo )
                , ( bp::arg("numbones"), bp::arg("cameraTransform"), bp::arg("pBoneToWorld") ) );
        
        }
        { //::C_BaseAnimating::ScriptSetPoseParameter
        
            typedef void ( ::C_BaseAnimating::*ScriptSetPoseParameter_function_type )( char const *,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "ScriptSetPoseParameter"
                , ScriptSetPoseParameter_function_type( &::C_BaseAnimating::ScriptSetPoseParameter )
                , ( bp::arg("szName"), bp::arg("fValue") ) );
        
        }
        { //::C_BaseAnimating::SelectWeightedSequence
        
            typedef int ( ::C_BaseAnimating::*SelectWeightedSequence_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "SelectWeightedSequence"
                , SelectWeightedSequence_function_type( &::C_BaseAnimating::SelectWeightedSequence )
                , ( bp::arg("activity") ) );
        
        }
        { //::C_BaseAnimating::SelectWeightedSequenceFromModifiers
        
            typedef int ( ::C_BaseAnimating::*SelectWeightedSequenceFromModifiers_function_type )( ::Activity,::CUtlSymbol *,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "SelectWeightedSequenceFromModifiers"
                , SelectWeightedSequenceFromModifiers_function_type( &::C_BaseAnimating::SelectWeightedSequenceFromModifiers )
                , ( bp::arg("activity"), bp::arg("pActivityModifiers"), bp::arg("iModifierCount") ) );
        
        }
        { //::C_BaseAnimating::SequenceDuration
        
            typedef float ( ::C_BaseAnimating::*SequenceDuration_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "SequenceDuration"
                , SequenceDuration_function_type( &::C_BaseAnimating::SequenceDuration ) );
        
        }
        { //::C_BaseAnimating::SequenceDuration
        
            typedef float ( ::C_BaseAnimating::*SequenceDuration_function_type )( ::CStudioHdr *,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "SequenceDuration"
                , SequenceDuration_function_type( &::C_BaseAnimating::SequenceDuration )
                , ( bp::arg("pStudioHdr"), bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::SequenceDuration
        
            typedef float ( ::C_BaseAnimating::*SequenceDuration_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "SequenceDuration"
                , SequenceDuration_function_type( &::C_BaseAnimating::SequenceDuration )
                , ( bp::arg("iSequence") ) );
        
        }
        { //::C_BaseAnimating::SequenceLoops
        
            typedef bool ( ::C_BaseAnimating::*SequenceLoops_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "SequenceLoops"
                , SequenceLoops_function_type( &::C_BaseAnimating::SequenceLoops ) );
        
        }
        { //::C_BaseAnimating::SetBody
        
            typedef void ( ::C_BaseAnimating::*SetBody_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetBody"
                , SetBody_function_type( &::C_BaseAnimating::SetBody )
                , ( bp::arg("iBody") ) );
        
        }
        { //::C_BaseAnimating::SetBodygroup
        
            typedef void ( ::C_BaseAnimating::*SetBodygroup_function_type )( int,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetBodygroup"
                , SetBodygroup_function_type( &::C_BaseAnimating::SetBodygroup )
                , ( bp::arg("iGroup"), bp::arg("iValue") ) );
        
        }
        { //::C_BaseAnimating::SetBoneController
        
            typedef float ( ::C_BaseAnimating::*SetBoneController_function_type )( int,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetBoneController"
                , SetBoneController_function_type( &::C_BaseAnimating::SetBoneController )
                , ( bp::arg("iController"), bp::arg("flValue") ) );
        
        }
        { //::C_BaseAnimating::SetCycle
        
            typedef void ( ::C_BaseAnimating::*SetCycle_function_type )( float ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetCycle"
                , SetCycle_function_type( &::C_BaseAnimating::SetCycle )
                , ( bp::arg("flCycle") ) );
        
        }
        { //::C_BaseAnimating::SetHitboxSet
        
            typedef void ( ::C_BaseAnimating::*SetHitboxSet_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetHitboxSet"
                , SetHitboxSet_function_type( &::C_BaseAnimating::SetHitboxSet )
                , ( bp::arg("setnum") ) );
        
        }
        { //::C_BaseAnimating::SetHitboxSetByName
        
            typedef void ( ::C_BaseAnimating::*SetHitboxSetByName_function_type )( char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetHitboxSetByName"
                , SetHitboxSetByName_function_type( &::C_BaseAnimating::SetHitboxSetByName )
                , ( bp::arg("setname") ) );
        
        }
        { //::C_BaseAnimating::SetModelScale
        
            typedef void ( ::C_BaseAnimating::*SetModelScale_function_type )( float ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetModelScale"
                , SetModelScale_function_type( &::C_BaseAnimating::SetModelScale )
                , ( bp::arg("scale") ) );
        
        }
        { //::C_BaseAnimating::SetMovementPoseParams
        
            typedef void ( ::C_BaseAnimating::*SetMovementPoseParams_function_type )( ::Vector const &,int,int,int,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetMovementPoseParams"
                , SetMovementPoseParams_function_type( &::C_BaseAnimating::SetMovementPoseParams )
                , ( bp::arg("vecLocalVelocity"), bp::arg("iMoveX"), bp::arg("iMoveY"), bp::arg("iXSign")=(int)(1), bp::arg("iYSign")=(int)(1) ) );
        
        }
        { //::C_BaseAnimating::SetPlaybackRate
        
            typedef void ( ::C_BaseAnimating::*SetPlaybackRate_function_type )( float ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetPlaybackRate"
                , SetPlaybackRate_function_type( &::C_BaseAnimating::SetPlaybackRate )
                , ( bp::arg("rate") ) );
        
        }
        { //::C_BaseAnimating::SetPoseParameter
        
            typedef float ( ::C_BaseAnimating::*SetPoseParameter_function_type )( ::CStudioHdr *,char const *,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetPoseParameter"
                , SetPoseParameter_function_type( &::C_BaseAnimating::SetPoseParameter )
                , ( bp::arg("pStudioHdr"), bp::arg("szName"), bp::arg("flValue") ) );
        
        }
        { //::C_BaseAnimating::SetPoseParameter
        
            typedef float ( ::C_BaseAnimating::*SetPoseParameter_function_type )( char const *,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetPoseParameter"
                , SetPoseParameter_function_type( &::C_BaseAnimating::SetPoseParameter )
                , ( bp::arg("szName"), bp::arg("flValue") ) );
        
        }
        { //::C_BaseAnimating::SetPoseParameter
        
            typedef float ( ::C_BaseAnimating::*SetPoseParameter_function_type )( ::CStudioHdr *,int,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetPoseParameter"
                , SetPoseParameter_function_type( &::C_BaseAnimating::SetPoseParameter )
                , ( bp::arg("pStudioHdr"), bp::arg("iParameter"), bp::arg("flValue") ) );
        
        }
        { //::C_BaseAnimating::SetPoseParameter
        
            typedef float ( ::C_BaseAnimating::*SetPoseParameter_function_type )( int,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetPoseParameter"
                , SetPoseParameter_function_type( &::C_BaseAnimating::SetPoseParameter )
                , ( bp::arg("iParameter"), bp::arg("flValue") ) );
        
        }
        { //::C_BaseAnimating::SetPredictable
        
            typedef void ( ::C_BaseAnimating::*SetPredictable_function_type )( bool ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetPredictable"
                , SetPredictable_function_type( &::C_BaseAnimating::SetPredictable )
                , ( bp::arg("state") ) );
        
        }
        { //::C_BaseAnimating::SetReceivedSequence
        
            typedef void ( ::C_BaseAnimating::*SetReceivedSequence_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetReceivedSequence"
                , SetReceivedSequence_function_type( &::C_BaseAnimating::SetReceivedSequence ) );
        
        }
        { //::C_BaseAnimating::SetSequence
        
            typedef void ( ::C_BaseAnimating::*SetSequence_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetSequence"
                , SetSequence_function_type( &::C_BaseAnimating::SetSequence )
                , ( bp::arg("nSequence") ) );
        
        }
        { //::C_BaseAnimating::SetServerIntendedCycle
        
            typedef void ( ::C_BaseAnimating::*SetServerIntendedCycle_function_type )( float ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetServerIntendedCycle"
                , SetServerIntendedCycle_function_type( &::C_BaseAnimating::SetServerIntendedCycle )
                , ( bp::arg("intended") ) );
        
        }
        { //::C_BaseAnimating::SetupBones
        
            typedef bool ( ::C_BaseAnimating::*SetupBones_function_type )( ::matrix3x4a_t *,int,int,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "SetupBones"
                , SetupBones_function_type( &::C_BaseAnimating::SetupBones )
                , ( bp::arg("pBoneToWorldOut"), bp::arg("nMaxBones"), bp::arg("boneMask"), bp::arg("currentTime") ) );
        
        }
        { //::C_BaseAnimating::SetupBonesOnBaseAnimating
        
            typedef void ( *SetupBonesOnBaseAnimating_function_type )( ::C_BaseAnimating * & );
            
            C_BaseAnimating_exposer.def( 
                "SetupBonesOnBaseAnimating"
                , SetupBonesOnBaseAnimating_function_type( &::C_BaseAnimating::SetupBonesOnBaseAnimating )
                , ( bp::arg("pBaseAnimating") ) );
        
        }
        { //::C_BaseAnimating::ShadowCastType
        
            typedef ::ShadowType_t ( ::C_BaseAnimating::*ShadowCastType_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ShadowCastType"
                , ShadowCastType_function_type( &::C_BaseAnimating::ShadowCastType ) );
        
        }
        { //::C_BaseAnimating::ShouldMuzzleFlash
        
            typedef bool ( ::C_BaseAnimating::*ShouldMuzzleFlash_function_type )(  ) const;
            
            C_BaseAnimating_exposer.def( 
                "ShouldMuzzleFlash"
                , ShouldMuzzleFlash_function_type( &::C_BaseAnimating::ShouldMuzzleFlash ) );
        
        }
        { //::C_BaseAnimating::ShouldResetSequenceOnNewModel
        
            typedef bool ( ::C_BaseAnimating::*ShouldResetSequenceOnNewModel_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ShouldResetSequenceOnNewModel"
                , ShouldResetSequenceOnNewModel_function_type( &::C_BaseAnimating::ShouldResetSequenceOnNewModel ) );
        
        }
        { //::C_BaseAnimating::ShutdownBoneSetupThreadPool
        
            typedef void ( *ShutdownBoneSetupThreadPool_function_type )(  );
            
            C_BaseAnimating_exposer.def( 
                "ShutdownBoneSetupThreadPool"
                , ShutdownBoneSetupThreadPool_function_type( &::C_BaseAnimating::ShutdownBoneSetupThreadPool ) );
        
        }
        { //::C_BaseAnimating::Simulate
        
            typedef bool ( ::C_BaseAnimating::*Simulate_function_type )(  ) ;
            typedef bool ( C_BaseAnimating_wrapper::*default_Simulate_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "Simulate"
                , Simulate_function_type(&::C_BaseAnimating::Simulate)
                , default_Simulate_function_type(&C_BaseAnimating_wrapper::default_Simulate) );
        
        }
        { //::C_BaseAnimating::StudioFrameAdvance
        
            typedef void ( ::C_BaseAnimating::*StudioFrameAdvance_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "StudioFrameAdvance"
                , StudioFrameAdvance_function_type( &::C_BaseAnimating::StudioFrameAdvance ) );
        
        }
        { //::C_BaseAnimating::ThreadedBoneSetup
        
            typedef void ( *ThreadedBoneSetup_function_type )(  );
            
            C_BaseAnimating_exposer.def( 
                "ThreadedBoneSetup"
                , ThreadedBoneSetup_function_type( &::C_BaseAnimating::ThreadedBoneSetup ) );
        
        }
        { //::C_BaseAnimating::TransferDissolveFrom
        
            typedef void ( ::C_BaseAnimating::*TransferDissolveFrom_function_type )( ::C_BaseAnimating * ) ;
            
            C_BaseAnimating_exposer.def( 
                "TransferDissolveFrom"
                , TransferDissolveFrom_function_type( &::C_BaseAnimating::TransferDissolveFrom )
                , ( bp::arg("pSource") ) );
        
        }
        { //::C_BaseAnimating::UncorrectViewModelAttachment
        
            typedef void ( ::C_BaseAnimating::*UncorrectViewModelAttachment_function_type )( ::Vector & ) ;
            
            C_BaseAnimating_exposer.def( 
                "UncorrectViewModelAttachment"
                , UncorrectViewModelAttachment_function_type( &::C_BaseAnimating::UncorrectViewModelAttachment )
                , ( bp::arg("vOrigin") ) );
        
        }
        { //::C_BaseAnimating::UpdateClientSideAnimation
        
            typedef void ( ::C_BaseAnimating::*UpdateClientSideAnimation_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "UpdateClientSideAnimation"
                , UpdateClientSideAnimation_function_type( &::C_BaseAnimating::UpdateClientSideAnimation ) );
        
        }
        { //::C_BaseAnimating::UpdateClientSideAnimations
        
            typedef void ( *UpdateClientSideAnimations_function_type )(  );
            
            C_BaseAnimating_exposer.def( 
                "UpdateClientSideAnimations"
                , UpdateClientSideAnimations_function_type( &::C_BaseAnimating::UpdateClientSideAnimations ) );
        
        }
        { //::C_BaseAnimating::UpdateIKLocks
        
            typedef void ( ::C_BaseAnimating::*UpdateIKLocks_function_type )( float ) ;
            
            C_BaseAnimating_exposer.def( 
                "UpdateIKLocks"
                , UpdateIKLocks_function_type( &::C_BaseAnimating::UpdateIKLocks )
                , ( bp::arg("currentTime") ) );
        
        }
        { //::C_BaseAnimating::UseClientSideAnimation
        
            typedef void ( ::C_BaseAnimating::*UseClientSideAnimation_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "UseClientSideAnimation"
                , UseClientSideAnimation_function_type( &::C_BaseAnimating::UseClientSideAnimation ) );
        
        }
        { //::C_BaseAnimating::VPhysicsUpdate
        
            typedef void ( ::C_BaseAnimating::*VPhysicsUpdate_function_type )( ::IPhysicsObject * ) ;
            
            C_BaseAnimating_exposer.def( 
                "VPhysicsUpdate"
                , VPhysicsUpdate_function_type( &::C_BaseAnimating::VPhysicsUpdate )
                , ( bp::arg("pPhysics") ) );
        
        }
        { //::C_BaseEntity::Activate
        
            typedef void ( ::C_BaseEntity::*Activate_function_type )(  ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_Activate_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "Activate"
                , Activate_function_type(&::C_BaseEntity::Activate)
                , default_Activate_function_type(&C_BaseAnimating_wrapper::default_Activate) );
        
        }
        { //::C_BaseEntity::AddToEntityList
        
            typedef void ( C_BaseAnimating_wrapper::*AddToEntityList_function_type )( ::entity_list_ids_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "AddToEntityList"
                , AddToEntityList_function_type( &C_BaseAnimating_wrapper::AddToEntityList )
                , ( bp::arg("listId") ) );
        
        }
        { //::C_BaseEntity::ClientThink
        
            typedef void ( ::C_BaseEntity::*ClientThink_function_type )(  ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_ClientThink_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ClientThink"
                , ClientThink_function_type(&::C_BaseEntity::ClientThink)
                , default_ClientThink_function_type(&C_BaseAnimating_wrapper::default_ClientThink) );
        
        }
        { //::C_BaseEntity::ComputeWorldSpaceSurroundingBox
        
            typedef void ( ::C_BaseEntity::*ComputeWorldSpaceSurroundingBox_function_type )( ::Vector *,::Vector * ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_ComputeWorldSpaceSurroundingBox_function_type )( ::Vector *,::Vector * ) ;
            
            C_BaseAnimating_exposer.def( 
                "ComputeWorldSpaceSurroundingBox"
                , ComputeWorldSpaceSurroundingBox_function_type(&::C_BaseEntity::ComputeWorldSpaceSurroundingBox)
                , default_ComputeWorldSpaceSurroundingBox_function_type(&C_BaseAnimating_wrapper::default_ComputeWorldSpaceSurroundingBox)
                , ( bp::arg("pVecWorldMins"), bp::arg("pVecWorldMaxs") ) );
        
        }
        { //::C_BaseEntity::CreateVPhysics
        
            typedef bool ( ::C_BaseEntity::*CreateVPhysics_function_type )(  ) ;
            typedef bool ( C_BaseAnimating_wrapper::*default_CreateVPhysics_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "CreateVPhysics"
                , CreateVPhysics_function_type(&::C_BaseEntity::CreateVPhysics)
                , default_CreateVPhysics_function_type(&C_BaseAnimating_wrapper::default_CreateVPhysics) );
        
        }
        { //::C_BaseEntity::DoImpactEffect
        
            typedef void ( ::C_BaseEntity::*DoImpactEffect_function_type )( ::trace_t &,int ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_DoImpactEffect_function_type )( ::trace_t &,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "DoImpactEffect"
                , DoImpactEffect_function_type(&::C_BaseEntity::DoImpactEffect)
                , default_DoImpactEffect_function_type(&C_BaseAnimating_wrapper::default_DoImpactEffect)
                , ( bp::arg("tr"), bp::arg("nDamageType") ) );
        
        }
        { //::C_BaseEntity::EndTouch
        
            typedef void ( ::C_BaseEntity::*EndTouch_function_type )( ::C_BaseEntity * ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_EndTouch_function_type )( ::C_BaseEntity * ) ;
            
            C_BaseAnimating_exposer.def( 
                "EndTouch"
                , EndTouch_function_type(&::C_BaseEntity::EndTouch)
                , default_EndTouch_function_type(&C_BaseAnimating_wrapper::default_EndTouch)
                , ( bp::arg("pOther") ) );
        
        }
        { //::C_BaseEntity::GetIMouse
        
            typedef ::IMouse * ( ::C_BaseEntity::*GetIMouse_function_type )(  ) ;
            typedef ::IMouse * ( C_BaseAnimating_wrapper::*default_GetIMouse_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetIMouse"
                , GetIMouse_function_type(&::C_BaseEntity::GetIMouse)
                , default_GetIMouse_function_type(&C_BaseAnimating_wrapper::default_GetIMouse)
                , bp::return_value_policy< bp::return_by_value >() );
        
        }
        { //::C_BaseEntity::GetTracerType
        
            typedef char const * ( ::C_BaseEntity::*GetTracerType_function_type )(  ) ;
            typedef char const * ( C_BaseAnimating_wrapper::*default_GetTracerType_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "GetTracerType"
                , GetTracerType_function_type(&::C_BaseEntity::GetTracerType)
                , default_GetTracerType_function_type(&C_BaseAnimating_wrapper::default_GetTracerType) );
        
        }
        { //::C_BaseEntity::KeyValue
        
            typedef bool ( ::C_BaseEntity::*KeyValue_function_type )( char const *,char const * ) ;
            typedef bool ( C_BaseAnimating_wrapper::*default_KeyValue_function_type )( char const *,char const * ) ;
            
            C_BaseAnimating_exposer.def( 
                "KeyValue"
                , KeyValue_function_type(&::C_BaseEntity::KeyValue)
                , default_KeyValue_function_type(&C_BaseAnimating_wrapper::default_KeyValue)
                , ( bp::arg("szKeyName"), bp::arg("szValue") ) );
        
        }
        { //::C_BaseEntity::KeyValue
        
            typedef bool ( ::C_BaseEntity::*KeyValue_function_type )( char const *,float ) ;
            typedef bool ( C_BaseAnimating_wrapper::*default_KeyValue_function_type )( char const *,float ) ;
            
            C_BaseAnimating_exposer.def( 
                "KeyValue"
                , KeyValue_function_type(&::C_BaseEntity::KeyValue)
                , default_KeyValue_function_type(&C_BaseAnimating_wrapper::default_KeyValue)
                , ( bp::arg("szKeyName"), bp::arg("flValue") ) );
        
        }
        { //::C_BaseEntity::KeyValue
        
            typedef bool ( ::C_BaseEntity::*KeyValue_function_type )( char const *,int ) ;
            typedef bool ( C_BaseAnimating_wrapper::*default_KeyValue_function_type )( char const *,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "KeyValue"
                , KeyValue_function_type(&::C_BaseEntity::KeyValue)
                , default_KeyValue_function_type(&C_BaseAnimating_wrapper::default_KeyValue)
                , ( bp::arg("szKeyName"), bp::arg("nValue") ) );
        
        }
        { //::C_BaseEntity::KeyValue
        
            typedef bool ( ::C_BaseEntity::*KeyValue_function_type )( char const *,::Vector const & ) ;
            typedef bool ( C_BaseAnimating_wrapper::*default_KeyValue_function_type )( char const *,::Vector const & ) ;
            
            C_BaseAnimating_exposer.def( 
                "KeyValue"
                , KeyValue_function_type(&::C_BaseEntity::KeyValue)
                , default_KeyValue_function_type(&C_BaseAnimating_wrapper::default_KeyValue)
                , ( bp::arg("szKeyName"), bp::arg("vecValue") ) );
        
        }
        { //::C_BaseEntity::MakeTracer
        
            typedef void ( ::C_BaseEntity::*MakeTracer_function_type )( ::Vector const &,::trace_t const &,int ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_MakeTracer_function_type )( ::Vector const &,::trace_t const &,int ) ;
            
            C_BaseAnimating_exposer.def( 
                "MakeTracer"
                , MakeTracer_function_type(&::C_BaseEntity::MakeTracer)
                , default_MakeTracer_function_type(&C_BaseAnimating_wrapper::default_MakeTracer)
                , ( bp::arg("vecTracerSrc"), bp::arg("tr"), bp::arg("iTracerType") ) );
        
        }
        { //::C_BaseEntity::OnChangeOwnerNumber
        
            typedef void ( ::C_BaseEntity::*OnChangeOwnerNumber_function_type )( int ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_OnChangeOwnerNumber_function_type )( int ) ;
            
            C_BaseAnimating_exposer.def( 
                "OnChangeOwnerNumber"
                , OnChangeOwnerNumber_function_type(&::C_BaseEntity::OnChangeOwnerNumber)
                , default_OnChangeOwnerNumber_function_type(&C_BaseAnimating_wrapper::default_OnChangeOwnerNumber)
                , ( bp::arg("old_owner_number") ) );
        
        }
        { //::C_BaseEntity::OnRestore
        
            typedef void ( ::C_BaseEntity::*OnRestore_function_type )(  ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_OnRestore_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "OnRestore"
                , OnRestore_function_type(&::C_BaseEntity::OnRestore)
                , default_OnRestore_function_type(&C_BaseAnimating_wrapper::default_OnRestore) );
        
        }
        { //::C_BaseEntity::Precache
        
            typedef void ( ::C_BaseEntity::*Precache_function_type )(  ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_Precache_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "Precache"
                , Precache_function_type(&::C_BaseEntity::Precache)
                , default_Precache_function_type(&C_BaseAnimating_wrapper::default_Precache) );
        
        }
        { //::C_BaseEntity::PyNotifyShouldTransmit
        
            typedef void ( ::C_BaseEntity::*NotifyShouldTransmit_function_type )( ::ShouldTransmitState_t ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_NotifyShouldTransmit_function_type )( ::ShouldTransmitState_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "NotifyShouldTransmit"
                , NotifyShouldTransmit_function_type(&::C_BaseEntity::PyNotifyShouldTransmit)
                , default_NotifyShouldTransmit_function_type(&C_BaseAnimating_wrapper::default_NotifyShouldTransmit)
                , ( bp::arg("state") ) );
        
        }
        { //::C_BaseEntity::PyReceiveMessage
        
            typedef void ( ::C_BaseEntity::*ReceiveMessage_function_type )( ::boost::python::list ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_ReceiveMessage_function_type )( ::boost::python::list ) ;
            
            C_BaseAnimating_exposer.def( 
                "ReceiveMessage"
                , ReceiveMessage_function_type(&::C_BaseEntity::PyReceiveMessage)
                , default_ReceiveMessage_function_type(&C_BaseAnimating_wrapper::default_ReceiveMessage)
                , ( bp::arg("msg") ) );
        
        }
        { //::C_BaseEntity::RemoveFromEntityList
        
            typedef void ( C_BaseAnimating_wrapper::*RemoveFromEntityList_function_type )( ::entity_list_ids_t ) ;
            
            C_BaseAnimating_exposer.def( 
                "RemoveFromEntityList"
                , RemoveFromEntityList_function_type( &C_BaseAnimating_wrapper::RemoveFromEntityList )
                , ( bp::arg("listId") ) );
        
        }
        { //::C_BaseEntity::ShouldDraw
        
            typedef bool ( ::C_BaseEntity::*ShouldDraw_function_type )(  ) ;
            typedef bool ( C_BaseAnimating_wrapper::*default_ShouldDraw_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "ShouldDraw"
                , ShouldDraw_function_type(&::C_BaseEntity::ShouldDraw)
                , default_ShouldDraw_function_type(&C_BaseAnimating_wrapper::default_ShouldDraw) );
        
        }
        { //::C_BaseEntity::Spawn
        
            typedef void ( ::C_BaseEntity::*Spawn_function_type )(  ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_Spawn_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "Spawn"
                , Spawn_function_type(&::C_BaseEntity::Spawn)
                , default_Spawn_function_type(&C_BaseAnimating_wrapper::default_Spawn) );
        
        }
        { //::C_BaseEntity::StartTouch
        
            typedef void ( ::C_BaseEntity::*StartTouch_function_type )( ::C_BaseEntity * ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_StartTouch_function_type )( ::C_BaseEntity * ) ;
            
            C_BaseAnimating_exposer.def( 
                "StartTouch"
                , StartTouch_function_type(&::C_BaseEntity::StartTouch)
                , default_StartTouch_function_type(&C_BaseAnimating_wrapper::default_StartTouch)
                , ( bp::arg("pOther") ) );
        
        }
        { //::C_BaseEntity::UpdateOnRemove
        
            typedef void ( ::C_BaseEntity::*UpdateOnRemove_function_type )(  ) ;
            typedef void ( C_BaseAnimating_wrapper::*default_UpdateOnRemove_function_type )(  ) ;
            
            C_BaseAnimating_exposer.def( 
                "UpdateOnRemove"
                , UpdateOnRemove_function_type(&::C_BaseEntity::UpdateOnRemove)
                , default_UpdateOnRemove_function_type(&C_BaseAnimating_wrapper::default_UpdateOnRemove) );
        
        }
        C_BaseAnimating_exposer.staticmethod( "GetPyNetworkType" );
        C_BaseAnimating_exposer.staticmethod( "InThreadedBoneSetup" );
        C_BaseAnimating_exposer.staticmethod( "InitBoneSetupThreadPool" );
        C_BaseAnimating_exposer.staticmethod( "InvalidateBoneCaches" );
        C_BaseAnimating_exposer.staticmethod( "PopBoneAccess" );
        C_BaseAnimating_exposer.staticmethod( "PushAllowBoneAccess" );
        C_BaseAnimating_exposer.staticmethod( "SetupBonesOnBaseAnimating" );
        C_BaseAnimating_exposer.staticmethod( "ShutdownBoneSetupThreadPool" );
        C_BaseAnimating_exposer.staticmethod( "ThreadedBoneSetup" );
        C_BaseAnimating_exposer.staticmethod( "UpdateClientSideAnimations" );
        { //property "skin"[fget=::C_BaseAnimating::GetSkin, fset=::C_BaseAnimating::SetSkin]
        
            typedef int ( ::C_BaseAnimating::*fget )(  ) ;
            typedef void ( ::C_BaseAnimating::*fset )( int ) ;
            
            C_BaseAnimating_exposer.add_property( 
                "skin"
                , fget( &::C_BaseAnimating::GetSkin )
                , fset( &::C_BaseAnimating::SetSkin ) );
        
        }
        { //property "customlightingoffset"[fget=::C_BaseAnimating::GetCustomLightingOffset, fset=::C_BaseAnimating::SetCustomLightingOffset]
        
            typedef ::Vector const & ( ::C_BaseAnimating::*fget )(  ) ;
            typedef void ( ::C_BaseAnimating::*fset )( ::Vector const & ) ;
            
            C_BaseAnimating_exposer.add_property( 
                "customlightingoffset"
                , bp::make_function( 
                      fget( &::C_BaseAnimating::GetCustomLightingOffset )
                    , bp::return_value_policy< bp::copy_const_reference >() ) 
                , fset( &::C_BaseAnimating::SetCustomLightingOffset ) );
        
        }
        { //::C_BaseAnimating::TestCollision
            
                typedef bool ( ::C_BaseAnimating::*TestCollision_function_type )( ::Ray_t const &,unsigned int,::trace_t & ) ;
                typedef bool ( C_BaseAnimating_wrapper::*default_TestCollision_function_type )( ::Ray_t const &,unsigned int,::trace_t & ) ;

                C_BaseAnimating_exposer.def( 
                    "TestCollision"
                    , TestCollision_function_type(&::C_BaseAnimating::TestCollision)
                    , default_TestCollision_function_type(&C_BaseAnimating_wrapper::default_TestCollision)
                    , ( bp::arg("ray"), bp::arg("mask"), bp::arg("trace") ) );

            }
    }

}

